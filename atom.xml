<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一缕烟气</title>
  
  <subtitle>沧海月明珠有泪，蓝田日暖玉生烟</subtitle>
  <link href="https://wrr123.github.io/atom.xml" rel="self"/>
  
  <link href="https://wrr123.github.io/"/>
  <updated>2021-03-29T12:22:26.391Z</updated>
  <id>https://wrr123.github.io/</id>
  
  <author>
    <name>田园隐士</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gitee配置ssh公匙</title>
    <link href="https://wrr123.github.io/2021/03/29/gitee%E9%85%8D%E7%BD%AEssh%E5%85%AC%E5%8C%99/"/>
    <id>https://wrr123.github.io/2021/03/29/gitee%E9%85%8D%E7%BD%AEssh%E5%85%AC%E5%8C%99/</id>
    <published>2021-03-29T08:45:55.000Z</published>
    <updated>2021-03-29T12:22:26.391Z</updated>
    
    <content type="html"><![CDATA[<p>从github仓库或者gitee仓库拉取代码时，我们既可以通过HTTP的方式，也可以通过SSH的方式。</p><p>HTTP可能比较方便，但是SSH的方式安全性比较高。</p><p>使用Jenkins自动部署时，需要用到SSH的方式拉取部署代码。</p><span id="more"></span><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>创建公匙</p><p>进入用户目录下的<code>.ssh</code>目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment"># 如果.ssh目录不存在，则自行创建</span></span><br><span class="line">mkdir ~/.ssh</span><br></pre></td></tr></table></figure><p>输入以下命令生成<strong>密匙对</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;邮箱地址&#39;</span><br></pre></td></tr></table></figure><p>在命令行提示下，你可以修改公匙存储文件的名称。</p></li><li><p>添加公匙</p><p>进入你的Gitee网站，在 <strong>设置</strong> - <strong>安全设置</strong> 下，找到 <strong>SSH密匙</strong>，添加密匙。</p><p>密匙内容为上面生成的文件<code>id_rsa_*.pub</code>的内容。一般以 <strong>ssh-rsa</strong> 开头。</p></li><li><p>测试连接</p><p>打开命令窗口，输入以下的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure></li><li><p>其它说明</p></li></ol><h4 id="查看某个ip地址的端口是否连接着"><a href="#查看某个ip地址的端口是否连接着" class="headerlink" title="查看某个ip地址的端口是否连接着"></a>查看某个ip地址的端口是否连接着</h4><p>使用 <strong>telnet</strong> 命令。</p><p><code>telnet ip port</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从github仓库或者gitee仓库拉取代码时，我们既可以通过HTTP的方式，也可以通过SSH的方式。&lt;/p&gt;
&lt;p&gt;HTTP可能比较方便，但是SSH的方式安全性比较高。&lt;/p&gt;
&lt;p&gt;使用Jenkins自动部署时，需要用到SSH的方式拉取部署代码。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://wrr123.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://wrr123.github.io/tags/git/"/>
    
    <category term="gitee" scheme="https://wrr123.github.io/tags/gitee/"/>
    
  </entry>
  
  <entry>
    <title>sentinel修改规则持久化</title>
    <link href="https://wrr123.github.io/2021/03/29/sentinel%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://wrr123.github.io/2021/03/29/sentinel%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2021-03-29T05:46:08.000Z</published>
    <updated>2021-03-29T12:22:26.391Z</updated>
    
    <content type="html"><![CDATA[<p>以前我们只能通过Nacos或者Apollo界面修改限流规则才能得到持久化存储，而在Sentinel Dashboard界面修改限流规则，虽然能够生效，但是不能持久化存储。</p><span id="more"></span><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>下图是之前实现的限流规则持久化方案的配置数据流向图：</p><p><img src="http://wrr123.github.io/2021/03/29/sentinel%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/001.png" alt></p><ul><li>蓝色箭头 代表了限流规则由 <strong>配置中心</strong> 发起修改的更新路径</li><li>橙色箭头 代表了限流规则由 <strong>Sentinel Dashboard</strong> 发起修改的更新路径</li></ul><blockquote><p>从图中可以很明显的看到，<code>Sentinel Dashboard</code>与业务服务之间本身是可以互通获取最新限流规则的，这在没有整合配置中心来存储限流规则的时候就已经存在这样的机制。最主要的区别是：配置中心的修改都可以实时的刷新到业务服务，从而被<code>Sentinel Dashboard</code>读取到，但是对于这些规则的更新到达各个业务服务之后，并没有一个机制去同步到配置中心，作为配置中心的客户端也不会提供这样的逆向更新方法。</p></blockquote><h4 id="Sentinel-Dashboard中修改规则同步到Apollo"><a href="#Sentinel-Dashboard中修改规则同步到Apollo" class="headerlink" title="Sentinel Dashboard中修改规则同步到Apollo"></a>Sentinel Dashboard中修改规则同步到Apollo</h4><h4 id="Sentinel-Dashboard中修改规则同步到Nacos"><a href="#Sentinel-Dashboard中修改规则同步到Nacos" class="headerlink" title="Sentinel Dashboard中修改规则同步到Nacos"></a>Sentinel Dashboard中修改规则同步到Nacos</h4><h4 id="SentinelResource注解使用详解"><a href="#SentinelResource注解使用详解" class="headerlink" title="@SentinelResource注解使用详解"></a>@SentinelResource注解使用详解</h4><p>在实际的应用中，我们可能需要限流的层面不仅限于接口，可能 <strong>对于某个方法的调用限流，对于某个外部资源的调用限流等都希望控制。</strong></p><h5 id="自定义资源点"><a href="#自定义资源点" class="headerlink" title="自定义资源点"></a>自定义资源点</h5><ol><li>在应用主类上加上注解支持的配置</li><li>在需要通过Sentinel来控制流量的地方使用 <code>@SentinelResource</code> 注解</li></ol><h5 id="如何实现限流和熔断降级"><a href="#如何实现限流和熔断降级" class="headerlink" title="如何实现限流和熔断降级"></a>如何实现限流和熔断降级</h5><h6 id="实现限流控制"><a href="#实现限流控制" class="headerlink" title="实现限流控制"></a>实现限流控制</h6><ol><li>在web层调用这个被保护的方法</li><li>启动应用，启动sentinel dashboard。发送几个请求到接口上，你会发现sentinel控制台上多出了你设置的资源点名称。</li></ol><h6 id="实现限流的异常处理"><a href="#实现限流的异常处理" class="headerlink" title="实现限流的异常处理"></a>实现限流的异常处理</h6><h6 id="实现熔断降级"><a href="#实现熔断降级" class="headerlink" title="实现熔断降级"></a>实现熔断降级</h6><h6 id="熔断的降级处理"><a href="#熔断的降级处理" class="headerlink" title="熔断的降级处理"></a>熔断的降级处理</h6>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前我们只能通过Nacos或者Apollo界面修改限流规则才能得到持久化存储，而在Sentinel Dashboard界面修改限流规则，虽然能够生效，但是不能持久化存储。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://wrr123.github.io/categories/java/"/>
    
    
    <category term="Spring Cloud" scheme="https://wrr123.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>sentinel-apollo</title>
    <link href="https://wrr123.github.io/2021/03/29/sentinel-apollo/"/>
    <id>https://wrr123.github.io/2021/03/29/sentinel-apollo/</id>
    <published>2021-03-29T02:57:31.000Z</published>
    <updated>2021-03-29T12:22:26.391Z</updated>
    
    <content type="html"><![CDATA[<p>Apollo是国内用的非常多的配置中心，现在我们来讨论下，Sentinel如何将限流规则存储在Apollo中。</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;Apollo是国内用的非常多的配置中心，现在我们来讨论下，Sentinel如何将限流规则存储在Apollo中。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://wrr123.github.io/categories/java/"/>
    
    
    <category term="Spring Cloud" scheme="https://wrr123.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>sentinel-nacos</title>
    <link href="https://wrr123.github.io/2021/03/29/sentinel-nacos/"/>
    <id>https://wrr123.github.io/2021/03/29/sentinel-nacos/</id>
    <published>2021-03-29T02:31:30.000Z</published>
    <updated>2021-03-29T12:22:26.391Z</updated>
    
    <content type="html"><![CDATA[<p>sentinel的限流规则的持久化问题。</p><p>实际上，现在我们在sentinel dashboard上设置的限流规则在应用重启之后就会丢失，那么我们该如何来持久化我们的限流规则呢？</p><span id="more"></span><h4 id="使用Nacos存储限流规则"><a href="#使用Nacos存储限流规则" class="headerlink" title="使用Nacos存储限流规则"></a>使用Nacos存储限流规则</h4><p>Sentinel目前本身支持了多种不同的数据源来持久化规则配置，如</p><ul><li>文件配置</li><li>Nacos配置</li><li>ZooKeeper配置</li><li>Apollo配置</li></ul><p>我们现在重点来看下 <strong>Nacos配置。</strong></p><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p>先启动好Nacos和Sentinel Dashboard。</p><h5 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h5><ol><li><p>引入jar包</p></li><li><p>配置信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-sentinel-datasource-nacos</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8003</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel dashboard</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.transport.dashboard</span>=<span class="string">localhost:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel datasource nacos ：http://blog.didispace.com/spring-cloud-alibaba-sentinel-2-1/</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.dataId</span>=<span class="string">$&#123;spring.application.name&#125;-sentinel</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.groupId</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.rule-type</span>=<span class="string">flow</span></span><br></pre></td></tr></table></figure></li><li><p>创建主类和一个测试用的rest接口</p></li><li><p>Nacos中创建限流规则的配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;/hello&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;grade&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;count&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;strategy&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;controlBehavior&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;clusterMode&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>启动应用，并进行验证。</p></li></ol><h4 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h4><p>在经过上面的整合之后，对限流规则的修改就存在两个地方了：<code>Sentinel控制台</code>，<code>Nacos控制台</code>。</p><blockquote><ul><li>Sentinel控制台中修改规则：仅存在于服务的内存中，不会修改Nacos中的配置值，重启后恢复原来的值。</li><li>Nacos控制台中修改规则：服务的内存中规则会更新，Nacos中持久化规则也会更新，重启后依然保持。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;sentinel的限流规则的持久化问题。&lt;/p&gt;
&lt;p&gt;实际上，现在我们在sentinel dashboard上设置的限流规则在应用重启之后就会丢失，那么我们该如何来持久化我们的限流规则呢？&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://wrr123.github.io/categories/java/"/>
    
    
    <category term="Spring Cloud" scheme="https://wrr123.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>alibaba-sentinel</title>
    <link href="https://wrr123.github.io/2021/03/29/alibaba-sentinel/"/>
    <id>https://wrr123.github.io/2021/03/29/alibaba-sentinel/</id>
    <published>2021-03-29T01:27:51.000Z</published>
    <updated>2021-03-29T12:22:26.389Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前置问题：java运行jar包时，指定启动端口？"><a href="#前置问题：java运行jar包时，指定启动端口？" class="headerlink" title="前置问题：java运行jar包时，指定启动端口？"></a>前置问题：java运行jar包时，指定启动端口？</h4><p>在最后面加上<code>--server.port</code></p><p>一个栗子：</p><p><code>java -jar xxx.jar --server.port=9090</code></p><span id="more"></span><h4 id="部署Sentinel-Dashboard"><a href="#部署Sentinel-Dashboard" class="headerlink" title="部署Sentinel Dashboard"></a>部署Sentinel Dashboard</h4><h5 id="通过命令行启动"><a href="#通过命令行启动" class="headerlink" title="通过命令行启动"></a>通过命令行启动</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.6.0.jar</span><br></pre></td></tr></table></figure><p>它的默认用户名和密码都是<code>sentinel</code>.</p><p>你也可以在启动命令中增加下面的参数进行配置：</p><ul><li><p><code>-Dsentinel.dashboard.auth.username=sentinel</code> 用于指定控制台的登录名</p></li><li><p><code>-Dsentinel.dashboard.auth.password=123456</code> 用于指定控制台的登陆密码</p><p>如果省略了上面的两个参数，则默认用户名和密码都为<code>sentinel</code>。</p></li><li><p><code>-Dserver.servlet.session.timeout=7200</code> 用于指定Spring Boot服务端session的过期时间，如7200表示7200秒，60m表示60分钟，默认为30分钟。</p></li></ul><h5 id="整合Sentinel"><a href="#整合Sentinel" class="headerlink" title="整合Sentinel"></a>整合Sentinel</h5><ol><li><p>在pom.xml文件中引入Spring Cloud Alibaba的Sentinel模块</p></li><li><p>在Spring Cloud应用中通过<code>spring.cloud.sentinel.transport.dashboard</code>参数配置sentinel dashboard的访问地址</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-sentinel-rate-limiting</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel dashboard</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.transport.dashboard</span>=<span class="string">localhost:8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建应用主类，并提供一个rest接口</p></li><li><p>启动应用，可通过postman或curl访问几下rest接口。</p></li></ol><h4 id="配置限流规则"><a href="#配置限流规则" class="headerlink" title="配置限流规则"></a>配置限流规则</h4><p><img src="http://wrr123.github.io/2021/03/29/alibaba-sentinel/001.png" alt></p><p>在Sentinel的某个服务下，点击<code>镞点链路</code>菜单，然后在右边界面，点击对应接口的<code>流控</code>按钮，弹出下面的界面：</p><p><img src="http://wrr123.github.io/2021/03/29/alibaba-sentinel/002.png" alt></p><p>配置完成，点击新增即可。</p><h5 id="验证限流规则"><a href="#验证限流规则" class="headerlink" title="验证限流规则"></a>验证限流规则</h5><p>你可以多访问几次，看看会不会被限流。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前置问题：java运行jar包时，指定启动端口？&quot;&gt;&lt;a href=&quot;#前置问题：java运行jar包时，指定启动端口？&quot; class=&quot;headerlink&quot; title=&quot;前置问题：java运行jar包时，指定启动端口？&quot;&gt;&lt;/a&gt;前置问题：java运行jar包时，指定启动端口？&lt;/h4&gt;&lt;p&gt;在最后面加上&lt;code&gt;--server.port&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个栗子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -jar xxx.jar --server.port=9090&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://wrr123.github.io/categories/java/"/>
    
    
    <category term="Spring Cloud" scheme="https://wrr123.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>springcloud-sentinel篇</title>
    <link href="https://wrr123.github.io/2021/03/28/springcloud-sentinel%E7%AF%87/"/>
    <id>https://wrr123.github.io/2021/03/28/springcloud-sentinel%E7%AF%87/</id>
    <published>2021-03-28T03:50:58.000Z</published>
    <updated>2021-03-30T00:05:49.101Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sentinel是什么"><a href="#sentinel是什么" class="headerlink" title="sentinel是什么"></a>sentinel是什么</h4><p>Sentinel的官方标题为 <strong>分布式系统的流量防卫兵。</strong> 从名字上看，很容易就能猜到它是用来作服务稳定性保障的。以前 <strong>Hystrix</strong> 也是用于服务稳定性保障的，但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，未来除了Spring Cloud官方推荐的 <strong>resilience4j</strong> 之外，Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。</p><span id="more"></span><h4 id="使用Sentinel实现接口限流"><a href="#使用Sentinel实现接口限流" class="headerlink" title="使用Sentinel实现接口限流"></a>使用Sentinel实现接口限流</h4><p>它分为两个部分：</p><ul><li><p>sentinel-dashboard</p><p>  与hystrix-dashboard类似，但是这个更为强大一些。除了提供实现监控之外，还提供了流控规则、熔断规则的在线维护等功能。</p></li><li><p>客户端整合</p><p>  每个微服务客户端都需要整合sentinel的客户端封装与配置，才能将监控信息上报给dashboard展示以及实时地更改限流或熔断规则等。</p></li></ul><h5 id="部署Sentinel-Dashboard"><a href="#部署Sentinel-Dashboard" class="headerlink" title="部署Sentinel Dashboard"></a>部署Sentinel Dashboard</h5><p>这是一个jar包，可通过命令行启动：</p><p><code>java -jar sentinel-dashboard-1.6.0.jar</code></p><p>如果你需要自定义端口的话，可以在启动命令上增加参数来调整，比如<code>-Dserver.port=8080</code>。</p><h5 id="Spring-Cloud整合Sentinel"><a href="#Spring-Cloud整合Sentinel" class="headerlink" title="Spring Cloud整合Sentinel"></a>Spring Cloud整合Sentinel</h5>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;sentinel是什么&quot;&gt;&lt;a href=&quot;#sentinel是什么&quot; class=&quot;headerlink&quot; title=&quot;sentinel是什么&quot;&gt;&lt;/a&gt;sentinel是什么&lt;/h4&gt;&lt;p&gt;Sentinel的官方标题为 &lt;strong&gt;分布式系统的流量防卫兵。&lt;/strong&gt; 从名字上看，很容易就能猜到它是用来作服务稳定性保障的。以前 &lt;strong&gt;Hystrix&lt;/strong&gt; 也是用于服务稳定性保障的，但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，未来除了Spring Cloud官方推荐的 &lt;strong&gt;resilience4j&lt;/strong&gt; 之外，Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://wrr123.github.io/categories/java/"/>
    
    
    <category term="springcloud" scheme="https://wrr123.github.io/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>springcloud-learning</title>
    <link href="https://wrr123.github.io/2021/03/25/springcloud-learning/"/>
    <id>https://wrr123.github.io/2021/03/25/springcloud-learning/</id>
    <published>2021-03-25T03:24:30.000Z</published>
    <updated>2021-03-29T12:22:26.392Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud的两个版本Edgware和Finchley。</p><h4 id="主要探讨Spring-Cloud各个版本之间的问题。"><a href="#主要探讨Spring-Cloud各个版本之间的问题。" class="headerlink" title="主要探讨Spring Cloud各个版本之间的问题。"></a>主要探讨Spring Cloud各个版本之间的问题。</h4><span id="more"></span><h5 id="consul多实例注册的问题处理"><a href="#consul多实例注册的问题处理" class="headerlink" title="consul多实例注册的问题处理"></a>consul多实例注册的问题处理</h5><ul><li><p>通过配置属性指定新的规则</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 粗暴的使用随机数来组织实例名</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.instance-id</span>=<span class="string">$&#123;spring.application.name&#125;-$&#123;random.int[10000,99999]&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>通过扩展<code>ConsulServiceRegistry</code>来重设实例名</p><p>重写其中的<code>register</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsulServiceRegistry</span> <span class="keyword">extends</span> <span class="title">ConsulServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConsulServiceRegistry</span><span class="params">(ConsulClient client, ConsulDiscoveryProperties properties, TtlScheduler ttlScheduler, HeartbeatProperties heartbeatProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(client, properties, ttlScheduler, heartbeatProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(ConsulRegistration reg)</span> </span>&#123;</span><br><span class="line">        reg.getService().setId(reg.getService().getName() + “-” + reg.getService().getAddress() + “-” + reg.getService().getPort());</span><br><span class="line">        <span class="keyword">super</span>.register(reg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Spring-Cloud-Alibaba与Spring-Boot、Spring-Cloud之间的关系"><a href="#Spring-Cloud-Alibaba与Spring-Boot、Spring-Cloud之间的关系" class="headerlink" title="Spring Cloud Alibaba与Spring Boot、Spring Cloud之间的关系"></a>Spring Cloud Alibaba与Spring Boot、Spring Cloud之间的关系</h5><h5 id="它们之间的兼容性"><a href="#它们之间的兼容性" class="headerlink" title="它们之间的兼容性"></a>它们之间的兼容性</h5><div class="table-container"><table><thead><tr><th>Spring Boot</th><th>Spring Cloud</th><th>Spring Cloud Alibaba</th></tr></thead><tbody><tr><td>2.1.x</td><td>Greenwich</td><td>0.9.x</td></tr><tr><td>2.0.x</td><td>Finchley</td><td>0.2.x</td></tr><tr><td>1.5.x</td><td>Edgware</td><td>0.1.x</td></tr><tr><td>1.5.x</td><td>Dalston</td><td>0.1.x</td></tr></tbody></table></div><h5 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>它暂时还处在Spring Cloud的孵化器中。</p><h6 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h6><p>它不是一个简单的组件，<strong>而是一个综合套件。</strong>其中涵盖了非常多的内容：</p><ul><li>服务治理</li><li>配置管理</li><li>限流降级</li><li>对阿里开源生态（Dubbo、RocketMQ等）支持的诸多组件</li></ul><p>它将红极一时的Dubbo，以及阿里巴巴的强力消息中间件RocketMQ融入Spring Cloud体系。</p><h5 id="Spring-Cloud-Alibaba到底坑不坑"><a href="#Spring-Cloud-Alibaba到底坑不坑" class="headerlink" title="Spring Cloud Alibaba到底坑不坑"></a>Spring Cloud Alibaba到底坑不坑</h5><ol><li>远程调用RPC</li><li>注册中心</li><li>熔断、限流</li></ol><h4 id="注册和配置中心-Nacos"><a href="#注册和配置中心-Nacos" class="headerlink" title="注册和配置中心 Nacos"></a>注册和配置中心 Nacos</h4><h5 id="什么是Nacos"><a href="#什么是Nacos" class="headerlink" title="什么是Nacos"></a>什么是Nacos</h5><p>它致力于帮助您发现、配置和管理微服务。它提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>它帮助您更敏捷和容易地构建、交付和管理微服务平台。</p><p>它是构建以”服务“为中心的现代应用架构（例如微服务范式、云原生范式）的服务基础设施。</p><h5 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h5><p>根据不同平台，执行不同命令，启动单机版Nacos服务：</p><ul><li>Linux/Unix/Mac：<code>sh startup.sh -m standalone</code></li><li>Windows：<code>cmd startup.cmd -m standalone</code></li></ul><p><strong>默认用户名密码为：nacos</strong></p><h5 id="构建应用接入Nacos注册中心"><a href="#构建应用接入Nacos注册中心" class="headerlink" title="构建应用接入Nacos注册中心"></a>构建应用接入Nacos注册中心</h5><h6 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h6><ol><li>配置pom.xml文件</li><li>创建应用主类，并实现一个HTTP接口</li><li>配置文件配置服务名称和Nacos地址</li><li>启动应用。可使用<code>-Dserver.port=8001</code>的形式在本机以不同端口上启动多个实例。</li></ol><h6 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h6><p>基本类似于上面的几个步骤，但是主类中的实现是不同的。</p><p><em>此时已经实现对服务提供方实例的负载均衡了，但是操作还是比较繁琐，需要改进。</em></p><h4 id="支持几种服务消费方式（RestTemplate、WebClient、Feign）"><a href="#支持几种服务消费方式（RestTemplate、WebClient、Feign）" class="headerlink" title="支持几种服务消费方式（RestTemplate、WebClient、Feign）"></a>支持几种服务消费方式（RestTemplate、WebClient、Feign）</h4><h5 id="使用RestTemplate"><a href="#使用RestTemplate" class="headerlink" title="使用RestTemplate"></a>使用RestTemplate</h5><h5 id="使用WebClient"><a href="#使用WebClient" class="headerlink" title="使用WebClient"></a>使用WebClient</h5><h5 id="使用Feign"><a href="#使用Feign" class="headerlink" title="使用Feign"></a>使用Feign</h5><h4 id="Nacos配置的多环境管理"><a href="#Nacos配置的多环境管理" class="headerlink" title="Nacos配置的多环境管理"></a>Nacos配置的多环境管理</h4><ul><li>Data Id</li><li>Group</li></ul><h4 id="Nacos的数据持久化"><a href="#Nacos的数据持久化" class="headerlink" title="Nacos的数据持久化"></a>Nacos的数据持久化</h4><p>在Nacos的conf文件夹下，有MySql的数据库初始化文件，<code>nacos-mysql.sql</code>。</p><p>修改下<code>conf/application.properties</code>文件，增加支持MySQL数据源配置，添加（<strong>目前仅支持MySQL</strong>）数据源的url、用户名和密码。</p><h4 id="Nacos的集群部署"><a href="#Nacos的集群部署" class="headerlink" title="Nacos的集群部署"></a>Nacos的集群部署</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Cloud的两个版本Edgware和Finchley。&lt;/p&gt;
&lt;h4 id=&quot;主要探讨Spring-Cloud各个版本之间的问题。&quot;&gt;&lt;a href=&quot;#主要探讨Spring-Cloud各个版本之间的问题。&quot; class=&quot;headerlink&quot; title=&quot;主要探讨Spring Cloud各个版本之间的问题。&quot;&gt;&lt;/a&gt;主要探讨Spring Cloud各个版本之间的问题。&lt;/h4&gt;</summary>
    
    
    
    <category term="java" scheme="https://wrr123.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://wrr123.github.io/tags/java/"/>
    
    <category term="SpringCloud" scheme="https://wrr123.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>git-bisect使用</title>
    <link href="https://wrr123.github.io/2021/03/25/git-bisect%E4%BD%BF%E7%94%A8/"/>
    <id>https://wrr123.github.io/2021/03/25/git-bisect%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-25T02:04:55.000Z</published>
    <updated>2021-03-29T12:22:26.390Z</updated>
    
    <content type="html"><![CDATA[<p><code>git bisect</code>可以通过二分查找的方式来定位引入BUG的提交。</p><p>有分为两种定位方法：</p><ul><li>人工单步定位</li><li>自动二分定位</li></ul><span id="more"></span><h4 id="人工单步定位"><a href="#人工单步定位" class="headerlink" title="人工单步定位"></a>人工单步定位</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git bisect start [终点](存在错误的提交) [起点]（好的提交）</span></span><br><span class="line">git bisect start HEAD 4d83cf</span><br><span class="line"><span class="comment"># 上述命令执行之后，代码库会进入中间点的提交，如果正常，执行</span></span><br><span class="line">git bisect good</span><br><span class="line"><span class="comment"># 如果异常，执行</span></span><br><span class="line">git bisect bad</span><br><span class="line"><span class="comment"># 重复指定上述两步的操作，直到只剩最后一次提交</span></span><br><span class="line"><span class="comment"># 退出bisect</span></span><br><span class="line">git bisect reset</span><br></pre></td></tr></table></figure><h4 id="自动二分定位"><a href="#自动二分定位" class="headerlink" title="自动二分定位"></a>自动二分定位</h4><p>可以使用<code>git bisect run 脚本</code>来自动判断是正常还是异常。</p><p>一个栗子：</p><blockquote><p>假设判断当前待定位BUG存在的方式是<code>make</code>命令是否执行成功，那么就可以用以下命令来进行自动二分定位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># git bisect start HEAD v1.2 --    &#x2F;&#x2F; 当前HEAD为bad标记，v1.2为good标记  </span><br><span class="line"># git bisect run make              &#x2F;&#x2F; 指定自动二分定位，判断方式：make是否指定成功  </span><br><span class="line"># git bisect reset                 &#x2F;&#x2F; 结果bisect过程</span><br></pre></td></tr></table></figure><p><code>git bisect run [cmd]</code>依靠cmd的返回值来判断当前commit对应的是bad commit还是good commit。简单来讲就是返回0表示good，非零表示bad。当然非零具体值也有不同的含义，具体还是仔细看看<code>git bisect --help</code>比较靠谱。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;git bisect&lt;/code&gt;可以通过二分查找的方式来定位引入BUG的提交。&lt;/p&gt;
&lt;p&gt;有分为两种定位方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人工单步定位&lt;/li&gt;
&lt;li&gt;自动二分定位&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="git" scheme="https://wrr123.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://wrr123.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>分布式服务跟踪</title>
    <link href="https://wrr123.github.io/2021/03/23/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B7%9F%E8%B8%AA/"/>
    <id>https://wrr123.github.io/2021/03/23/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B7%9F%E8%B8%AA/</id>
    <published>2021-03-23T09:43:21.000Z</published>
    <updated>2021-03-29T12:22:26.392Z</updated>
    
    <content type="html"><![CDATA[<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h4&gt;</summary>
      
    
    
    
    <category term="java" scheme="https://wrr123.github.io/categories/java/"/>
    
    
    <category term="Dalston" scheme="https://wrr123.github.io/tags/Dalston/"/>
    
  </entry>
  
  <entry>
    <title>消息驱动的微服务</title>
    <link href="https://wrr123.github.io/2021/03/23/%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://wrr123.github.io/2021/03/23/%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-03-23T08:09:13.000Z</published>
    <updated>2021-03-29T12:22:26.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>先了解下Spring Cloud Stream。</p><p>它是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独立的、可用于生产的Spring应用程序。它通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动的微服务应用。</p><blockquote><p>Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。简单的说，Spring Cloud Stream本质上就是整合了Spring Boot和Spring Integration，实现了一套轻量级的消息驱动的微服务框架。通过使用Spring Cloud Stream，可以有效地简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。</p></blockquote><p>两个著名的消息中间件的自动化配置：</p><ul><li><code>RabbitMQ</code></li><li><code>Kafka</code></li></ul><span id="more"></span><h5 id="构建一个Spring-Cloud-Stream消费者"><a href="#构建一个Spring-Cloud-Stream消费者" class="headerlink" title="构建一个Spring Cloud Stream消费者"></a>构建一个Spring Cloud Stream消费者</h5><ul><li><p>创建工程</p></li><li><p>在<code>pom.xml</code>文件中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建用于接收来自<code>RabbitMQ</code>消息的消费者<code>SinkReceiver</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinkReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SinkReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Received: &quot;</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个正常的类似Spring Boot的应用主类。</p></li></ul><h4 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h4><p><code>Binder</code>绑定器是Spring Cloud Stream中一个非常重要的概念。</p><h5 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h5><p>相对于点对点队列实现的消息通信来说，Spring Cloud Stream采用的发布-订阅模式可以有效地降低消息生产者与消费者之间地耦合，当我们需要对同一类消息增加一种处理方式时，只需要增加一个应用程序并将输入通道绑定到既有的<code>Topic</code>中就可以实现功能的扩展，而不需要改变原来已经实现的任何内容。</p><h5 id="消费组"><a href="#消费组" class="headerlink" title="消费组"></a>消费组</h5><p>消费组中只会有一个实例对消息进行消费。</p><p>消费分区</p><p>当生产者将消息数据发送给多个消费者实例时，保证拥有共同特征的的消息数据始终是由同一个消费者实例接收和处理。</p><h4 id="使用消息组实现消息消费的负载均衡"><a href="#使用消息组实现消息消费的负载均衡" class="headerlink" title="使用消息组实现消息消费的负载均衡"></a>使用消息组实现消息消费的负载均衡</h4>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h4&gt;&lt;p&gt;先了解下Spring Cloud Stream。&lt;/p&gt;
&lt;p&gt;它是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独立的、可用于生产的Spring应用程序。它通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动的微服务应用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。简单的说，Spring Cloud Stream本质上就是整合了Spring Boot和Spring Integration，实现了一套轻量级的消息驱动的微服务框架。通过使用Spring Cloud Stream，可以有效地简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个著名的消息中间件的自动化配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RabbitMQ&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kafka&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="java" scheme="https://wrr123.github.io/categories/java/"/>
    
    
    <category term="Dalston" scheme="https://wrr123.github.io/tags/Dalston/"/>
    
  </entry>
  
  <entry>
    <title>服务网关-Dalston</title>
    <link href="https://wrr123.github.io/2021/03/23/%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3-Dalston/"/>
    <id>https://wrr123.github.io/2021/03/23/%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3-Dalston/</id>
    <published>2021-03-23T05:59:57.000Z</published>
    <updated>2021-03-23T11:24:10.583Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>我们需要将 <strong>权限控制</strong> 这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强一些的负载均衡器，就是 <strong>服务网关</strong>。</p><ul><li><p>创建项目，在pom.xml中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建应用主类，并使用<code>@EnableZuulProxy</code>注解开启Zuul的功能。</p></li><li><p>创建配置文件<code>application.yaml</code>，并加入服务名、端口号、eureka注册中心的地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka.didispace.com/eureka/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><h5 id="传统的路由配置"><a href="#传统的路由配置" class="headerlink" title="传统的路由配置"></a>传统的路由配置</h5><p>所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与路由实例的映射关系来实现API网关对外部请求的路由。</p><ul><li><p>单实例配置</p><p>通过一组参数对<code>zuul.routes.&lt;route&gt;.path 与 zuul.routes.&lt;route&gt;.url</code>的方式配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.url</span>=<span class="string">http://localhost:8080/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>多实例配置</p><p>通过一组参数对<code>zuul.routes.&lt;route&gt;.path 与 zuul.routes.&lt;route&gt;.serviceId</code>的方式配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.serviceId</span>=<span class="string">user-service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">ribbon.eureka.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">user-service.ribbon.listOfServers</span>=<span class="string">http://localhost:8080/,http://localhost:8081/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>ribbon.eureka.enabled</code>：由于<code>zuul.routes..serviceId</code>指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的<code>serviceId</code>是获取不到对应实例清单的。</li><li><code>user-service.ribbon.listOfServers</code>：该参数内容与<code>zuul.routes..serviceId</code>的配置相对应，开头的<code>user-service</code>对应了<code>serviceId</code>的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。</li></ul></li></ul><h5 id="服务路由配置"><a href="#服务路由配置" class="headerlink" title="服务路由配置"></a>服务路由配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">api-a:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/api-a/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">eureka-client</span></span><br></pre></td></tr></table></figure><p><code>serviceId</code>用来指定路由的具体服务名，<code>path</code>用来配置匹配的请求表达式。</p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。</p><p>通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器或拦截器了。</p><p>为了在API网关中实现对客户端请求的校验，我们将需要使用Spring Cloud Zuul的另一个功能，<strong>过滤器</strong>。</p><p>Zuul允许开发者在API网关上通过定义过滤器来实现对请求的过滤或拦截，实现的方法非常简单，我们只需要继承<code>ZuulFilter</code>抽象类并实现它定义的四个抽象方法就可以完成对请求的拦截和过滤了。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(AccessFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">      log.info(<span class="string">&quot;send &#123;&#125; request to &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURL().toString());</span><br><span class="line"></span><br><span class="line">        Object accessToken = request.getParameter(<span class="string">&quot;accessToken&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(accessToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;access token is empty&quot;</span>);</span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;access token ok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四个方法的作用：</p><blockquote><ul><li><code>filterType</code>：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为<code>pre</code>，代表会在请求被路由之前执行。</li><li><code>filterOrder</code>：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。</li><li><code>shouldFilter</code>：判断该过滤器是否需要被执行。这里我们直接返回了<code>true</code>，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。</li><li><code>run</code>：过滤器的具体逻辑。这里我们通过<code>ctx.setSendZuulResponse(false)</code>令zuul过滤该请求，不对其进行路由，然后通过<code>ctx.setResponseStatusCode(401)</code>设置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过<code>ctx.setResponseBody(body)</code>对返回body内容进行编辑等。</li></ul></blockquote><h4 id="API文档汇总"><a href="#API文档汇总" class="headerlink" title="API文档汇总"></a>API文档汇总</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><h5 id="构建API网关并整合Swagger"><a href="#构建API网关并整合Swagger" class="headerlink" title="构建API网关并整合Swagger"></a>构建API网关并整合Swagger</h5><p><strong><code>@Primary</code>注解的含义：（当一个接口有多个不同实现时，添加了这个注解）此实现，优先被注入。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h4&gt;&lt;p&gt;我们需要将 &lt;strong&gt;权限控制&lt;/strong&gt; 这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的</summary>
      
    
    
    
    
    <category term="Dalston" scheme="https://wrr123.github.io/tags/Dalston/"/>
    
  </entry>
  
  <entry>
    <title>服务容错保护</title>
    <link href="https://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4/"/>
    <id>https://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4/</id>
    <published>2021-03-22T08:42:29.000Z</published>
    <updated>2021-03-23T11:24:10.581Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Hystrix服务降级"><a href="#Hystrix服务降级" class="headerlink" title="Hystrix服务降级"></a>Hystrix服务降级</h4><blockquote><p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。</p></blockquote><span id="more"></span><ul><li><p>引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在应用主类中使用<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>注解开启Hystrix的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解<code>@SpringCloudApplication</code>是上述三个注解的合并。</strong></p></li><li><p>改造消费方式，在为具体执行逻辑的函数上增加<code>@HystrixCommand</code>注解来指定服务降级方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConsumerService consumerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> consumerService.consumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://eureka-client/dc&quot;</span>, String.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;fallback&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Hystrix依赖隔离"><a href="#Hystrix依赖隔离" class="headerlink" title="Hystrix依赖隔离"></a>Hystrix依赖隔离</h4><blockquote><p>“舱壁模式”对于熟悉Docker的读者一定不陌生，Docker通过“舱壁模式”实现进程的隔离，使得容器与容器之间不会互相影响。而Hystrix则使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。</p><p>通过对依赖服务的线程池隔离实现，可以带来如下优势：</p><ul><li>应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。</li><li>可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。</li><li>当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。</li><li>当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（后续会通过Spring Cloud Config与Spring Cloud Bus的联合使用来介绍）来处理它。</li><li>当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。</li><li>除了上面通过线程池隔离服务发挥的优点之外，每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。</li></ul><p>总之，通过对依赖服务实现线程池隔离，让我们的应用更加健壮，不会因为个别依赖服务出现问题而引起非相关服务的异常。同时，也使得我们的应用变得更加灵活，可以在不停止服务的情况下，配合动态配置刷新实现性能配置上的调整。</p></blockquote><p>Hystrix中除了使用线程池之外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销要远比线程池的开销小得多，但是它不能设置超时和实现异步访问。所以，只有在依赖服务是足够可靠的情况下才使用信号量。</p><p>在HystrixCommand和HystrixObservableCommand中2处支持信号量的使用：</p><ul><li><p>命令执行</p><p>如果隔离策略参数<code>execution.isolation.strategy</code>设置为<code>SEMAPHORE</code>，Hystrix会使用信号量替代线程池来控制依赖服务的并发控制。</p></li><li><p>降级逻辑</p><p>当Hystrix尝试降级逻辑的时候，它会在调用线程中使用信号量。</p></li></ul><h4 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h4><p>”断路器“本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，”断路器“能够及时地切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障时之后，通过断路器的故障监控，直接切断原来的主逻辑调用。<strong>但是，在Hystrix中的断路器除了切断主逻辑的功能之外，还有更复杂的逻辑。</strong></p><p>断路器的三个重要参数：</p><ol><li><p>快照时间窗</p><p>断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</p></li><li><p>请求总数下限</p><p>在快照时间窗内，必须满足请求总数下限才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即使所有的请求都超时或其它的原因失败，断路器都不会打开。</p></li><li><p>错误百分比下限</p><p>当请求总数在快照时间窗内超出了下限，比如发生了30次调用，如果这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候断路器就会打开。</p></li></ol><h4 id="Hystrix监控面板"><a href="#Hystrix监控面板" class="headerlink" title="Hystrix监控面板"></a>Hystrix监控面板</h4><h5 id="Hystrix-Dashboard支持三种不同的监控方式："><a href="#Hystrix-Dashboard支持三种不同的监控方式：" class="headerlink" title="Hystrix Dashboard支持三种不同的监控方式："></a>Hystrix Dashboard支持三种不同的监控方式：</h5><ol><li>默认的集群监控</li><li>指定的集群监控</li><li>单体应用的集群监控</li></ol><h5 id="进入监控界面"><a href="#进入监控界面" class="headerlink" title="进入监控界面"></a>进入监控界面</h5><ol><li><p>保证服务实例引入了jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>确保在服务实例的主类中使用了注解<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>，开启了断路器功能。</p></li></ol><p>监控界面的一些数量指标解释：</p><ul><li><p>实心圆</p><p>颜色代表了实例的健康程度，健康度从绿色、黄色、橙色、红色依次递减。</p></li><li><p>曲线</p><p>用来记录2分钟内流量的相对变化。</p></li></ul><p><img src="http://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4/001.png" alt></p><h4 id="Hystrix监控数据聚合"><a href="#Hystrix监控数据聚合" class="headerlink" title="Hystrix监控数据聚合"></a>Hystrix监控数据聚合</h4><p>因在生产环境我们的服务都是高可用的，故引入一个新的工具，<strong>Turbine。</strong></p><h5 id="通过HTTP收集聚合"><a href="#通过HTTP收集聚合" class="headerlink" title="通过HTTP收集聚合"></a>通过HTTP收集聚合</h5><ul><li><p>创建一个turbine的项目，引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建应用主类，加上注解<code>@EnableTurbine</code>,来开启Turbine。</p></li><li><p>在<code>application.properties</code>配置文件中，加入Eureka和Turbine的相关配置信息。</p><p>参数说明：</p><ul><li><code>turbine.app-config</code>参数指定了需要收集监控信息的服务名；</li><li><code>turbine.cluster-name-expression</code> 参数指定了集群名称为default，当我们服务数量非常多的时候，可以启动多个Turbine服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需要在Hystrix Stream的URL中通过<code>cluster</code>参数来指定；</li><li><code>turbine.combine-host-port</code>参数设置为<code>true</code>，可以让同一主机上的服务通过主机名与端口号的组合来进行区分，默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。</li></ul></li></ul><h5 id="通过消息代理收集聚合"><a href="#通过消息代理收集聚合" class="headerlink" title="通过消息代理收集聚合"></a>通过消息代理收集聚合</h5><p>我们也可以将所有需要收集的监控信息都输出到消息代理中，然后Turbine服务再从消息代理中异步地获取这些监控信息，最后将这些监控信息聚合并输出到Hystrix Dashboard中。</p><ul><li><p>创建工程，修改pom.xml，添加jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在应用主类中使用<code>@EnableTurbineStream</code>注解来启用Turbine Strean的配置。</p></li><li><p>配置<code>application.properties</code>文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">turbine-amqp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8989</span></span><br><span class="line"><span class="meta">management.port</span>=<span class="string">8990</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:1001/eureka/</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Hystrix服务降级&quot;&gt;&lt;a href=&quot;#Hystrix服务降级&quot; class=&quot;headerlink&quot; title=&quot;Hystrix服务降级&quot;&gt;&lt;/a&gt;Hystrix服务降级&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Dalston" scheme="https://wrr123.github.io/tags/Dalston/"/>
    
  </entry>
  
  <entry>
    <title>服务配置中心-Dalston</title>
    <link href="https://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-Dalston/"/>
    <id>https://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-Dalston/</id>
    <published>2021-03-22T07:52:01.000Z</published>
    <updated>2021-03-23T11:24:10.583Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。</p></blockquote><span id="more"></span><h4 id="准备配置仓库"><a href="#准备配置仓库" class="headerlink" title="准备配置仓库"></a>准备配置仓库</h4><ul><li>准备一个git仓库，可以在码云或者github上创建都可以。</li></ul><h4 id="构建配置中心"><a href="#构建配置中心" class="headerlink" title="构建配置中心"></a>构建配置中心</h4><ol><li><p>引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建SpringBoot主类，并添加<code>@EnableConfigServer</code>注解，开启Spring Cloud Config的服务端功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>application.yml</code>中配置服务的基本信息以及Git仓库的相关信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://git.oschina.net/didispace/config-repo-demo/</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1201</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="构建客户端"><a href="#构建客户端" class="headerlink" title="构建客户端"></a>构建客户端</h4><ol><li><p>创建一个springBoot应用，并引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Spring Boot的应用主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>bootstrap.yml</code>配置，来指定获取配置文件的<code>config-server-git</code>位置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:1201/</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Dalston" scheme="https://wrr123.github.io/tags/Dalston/"/>
    
  </entry>
  
  <entry>
    <title>服务消费-Dalston</title>
    <link href="https://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9-Dalston/"/>
    <id>https://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9-Dalston/</id>
    <published>2021-03-22T06:38:12.000Z</published>
    <updated>2021-03-23T11:24:10.582Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="使用LoadBalancerClient"><a href="#使用LoadBalancerClient" class="headerlink" title="使用LoadBalancerClient"></a>使用LoadBalancerClient</h5><p>在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括<code>DiscoveryClient</code>，以及<code>LoadBalancerClient</code>等等。</p><p><code>LoadBalancerClient</code>接口就是一个负载均衡客户端的抽象定义。</p><ul><li>引入jar包</li><li>配置<code>application.properties</code>文件</li><li>创建应用主类。初始化<code>RestTemplate</code>,用来真正发起REST请求。<code>@EnableDiscoveryClient</code>注解用来将当前应用加入到服务治理体系中。</li><li>创建一个接口用来消费<code>eureka-client</code>提供的接口。</li></ul><span id="more"></span><h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><p>通过 <code>LoadBalancerClient</code> 接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。</p><p>因此，我们需要来看看针对客户端负载均衡的工具包：<code>Spring Cloud Ribbon</code>。</p><p>它是基于 Netflix Ribbon 实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置<code>RibbonServerList</code>来设置服务端列表去轮询访问以达到均衡负载的作用。</p><blockquote><p>当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。</p><p>而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。</p></blockquote><ul><li><p>引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改应用主类。为RestTemplate增加<code>@LoadBalanced</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://eureka-client/dc&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><p>Spring Cloud Feign 是一套基于 Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务端变得更加简单。我们只需要通过创建接口并用注解来配置它，即可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。它还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p><h4 id="Feign实现文件上传"><a href="#Feign实现文件上传" class="headerlink" title="Feign实现文件上传"></a>Feign实现文件上传</h4>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h4&gt;&lt;h5 id=&quot;使用LoadBalancerClient&quot;&gt;&lt;a href=&quot;#使用LoadBalancerClient&quot; class=&quot;headerlink&quot; title=&quot;使用LoadBalancerClient&quot;&gt;&lt;/a&gt;使用LoadBalancerClient&lt;/h5&gt;&lt;p&gt;在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括&lt;code&gt;DiscoveryClient&lt;/code&gt;，以及&lt;code&gt;LoadBalancerClient&lt;/code&gt;等等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LoadBalancerClient&lt;/code&gt;接口就是一个负载均衡客户端的抽象定义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引入jar包&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;application.properties&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;创建应用主类。初始化&lt;code&gt;RestTemplate&lt;/code&gt;,用来真正发起REST请求。&lt;code&gt;@EnableDiscoveryClient&lt;/code&gt;注解用来将当前应用加入到服务治理体系中。&lt;/li&gt;
&lt;li&gt;创建一个接口用来消费&lt;code&gt;eureka-client&lt;/code&gt;提供的接口。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Dalston" scheme="https://wrr123.github.io/tags/Dalston/"/>
    
  </entry>
  
  <entry>
    <title>服务注册和发现-Dalston</title>
    <link href="https://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0-Dalston/"/>
    <id>https://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0-Dalston/</id>
    <published>2021-03-22T03:26:36.000Z</published>
    <updated>2021-03-23T11:24:10.582Z</updated>
    
    <content type="html"><![CDATA[<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>简单地说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务和服务间通过诸如<code>RESTful API</code>的方式互相调用。</p><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>Spring Cloud应用中可以支持不同的服务治理框架，比如：</p><ul><li>Netflix Eureka</li><li>Consul</li><li>Zookeeper</li></ul><h5 id="Spring-Cloud-Euraka"><a href="#Spring-Cloud-Euraka" class="headerlink" title="Spring Cloud Euraka"></a>Spring Cloud Euraka</h5><ol><li><p>创建“服务注册中心”</p><ul><li><p>引入jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>@EnableEurekaServer</code>注解启动一个服务注册中心提供给其它应用进行对话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class)</span><br><span class="line">                    .web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在默认情况下，该服务注册中心也会将自己作为客户端来注册它自己，所以我们需要禁用它的客户端注册行为。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-server</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建“服务提供方”</p><ul><li><p>引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在应用主类上加上注解<code>@EnableDiscoveryClient</code>，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(</span><br><span class="line">            ComputeServiceApplication.class)</span><br><span class="line">            .web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现一个简单的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dc&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String services = <span class="string">&quot;Services: &quot;</span> + discoveryClient.getServices();</span><br><span class="line">        System.out.println(services);</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对<code>application.properties</code>配置文件做一些配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定微服务的名称，后续在调用的时候只需要使用该名称就可以进行服务的访问</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">2001</span></span><br><span class="line"><span class="comment"># 对应服务注册中心的配置内容，指定服务注册中心的位置</span></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:1001/eureka/</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h5><p>   Spring Cloud Consul项目是针对Consul的服务治理实现。Consul是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。</p><p>它包含下面的几个特性：</p><ul><li>服务发现</li><li>健康检查</li><li>Key/Value存储</li><li>多数据中心</li></ul><h6 id="Consul的服务端开启"><a href="#Consul的服务端开启" class="headerlink" title="Consul的服务端开启"></a>Consul的服务端开启</h6><p>Consul的服务端是通过命令行来直接启动的，不需要在java端启动。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;微服务架构&quot;&gt;&lt;a href=&quot;#微服务架构&quot; class=&quot;headerlink&quot; title=&quot;微服务架构&quot;&gt;&lt;/a&gt;微服务架构&lt;/h4&gt;&lt;p&gt;简单地说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立</summary>
      
    
    
    
    
    <category term="Dalston" scheme="https://wrr123.github.io/tags/Dalston/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket-how2j</title>
    <link href="https://wrr123.github.io/2021/03/22/WebSocket-how2j/"/>
    <id>https://wrr123.github.io/2021/03/22/WebSocket-how2j/</id>
    <published>2021-03-22T02:02:07.000Z</published>
    <updated>2021-03-23T11:24:10.573Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>以前，当服务器端有个数据的更新，如果浏览器端需要获取更新后的数据，只能不停的刷新页面，或者使用Ajax技术每个一段时间向服务器轮询访问服务器数据。</p><p>现在，使用了WebSocket技术之后，当服务器有了新的数据，会主动通知浏览器。</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li><p>节约宽带。</p><p>不停的轮询服务端数据这种方式，使用的是http协议，head信息很大，有效数据占比低，而使用WebSocket方式，头信息很小，有效数据占比高。</p></li><li><p>无浪费。</p><p>轮询方式有可能轮询10次，才碰到服务器的数据更新，那么前9次的轮询都白费了，因为没拿到变化的数据；而WebSocket是由服务器主动发送，来的都是新数据。</p></li><li><p>实时性。</p><p>考虑到服务器压力，使用的轮询方式不可能很短的时间间隔，否则服务器压力太大，所有轮询时间间隔都是比较长，设置十几秒。而WebSocket是由服务器主动推送过来，实时性是最高的。</p></li></ol><h4 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h4><h5 id="注解-ServerEndpoint-quot-path-quot-把它标记为一个WebSocket-Server"><a href="#注解-ServerEndpoint-quot-path-quot-把它标记为一个WebSocket-Server" class="headerlink" title="注解@ServerEndpoint(&quot;/path/..&quot;) 把它标记为一个WebSocket Server"></a>注解<code>@ServerEndpoint(&quot;/path/..&quot;)</code> 把它标记为一个WebSocket Server</h5><p><code>/path/..</code> 表示有通过这个地址访问该服务。</p><ul><li><code>OnOpen</code>表示有浏览器链接过来的时候被调用</li><li><code>OnClose</code>表示浏览器发出关闭请求的时候被调用</li><li><code>OnMessage</code>表示浏览器发消息的时候被调用</li><li><code>OnError</code>表示有错误发生，比如网络断开了等等</li><li><code>sendMessage</code>用于向浏览器回发信息</li></ul><p>其中OnOpen发生的时候，即有链接过来的时候，会把当前WebSocket Serve丢在ServerManager里管理起来，这样tomcat才知道总共有哪些Server，方便以后进行群发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.bitcoin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnError;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServerEndpoint</span> 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,</span></span><br><span class="line"><span class="comment"> * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/bitcoinServer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitCoinServer</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        ServerManager.add(<span class="keyword">this</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServerManager.remove(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自客户端的消息:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="struts注意事项"><a href="#struts注意事项" class="headerlink" title="struts注意事项"></a>struts注意事项</h4><p>因为Struts会把所有的请求都拦截下来，所以需要加一个例外：</p><p><code>&lt;constant name=&quot;struts.action.excludePattern&quot; value=&quot;/ws/bitcoinServer&quot; /&gt;</code></p><p>以保证WebSocket请求能够被正常捕捉住，不然就被Struts搞跑了。</p><h4 id="nginx注意事项"><a href="#nginx注意事项" class="headerlink" title="nginx注意事项"></a>nginx注意事项</h4><p>如果做了nginx和tomcat整合的话，那么nginx需要加上一段话，才能够正常的把WebSocket请求交给tomcat，不然tomcat也不知道怎么处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;ws&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:11180;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;以前，当服务器端有个数据的更新，如果浏览器端需要获取更新后的数据，只能不停的刷新页面，或者使用Ajax技术每个一段时间向服务器轮询访问服务器</summary>
      
    
    
    
    
    <category term="how2j" scheme="https://wrr123.github.io/tags/how2j/"/>
    
  </entry>
  
  <entry>
    <title>idea-how2j</title>
    <link href="https://wrr123.github.io/2021/03/19/idea-how2j/"/>
    <id>https://wrr123.github.io/2021/03/19/idea-how2j/</id>
    <published>2021-03-19T01:59:36.000Z</published>
    <updated>2021-03-23T11:24:10.575Z</updated>
    
    <content type="html"><![CDATA[<h4 id="IDEA基础"><a href="#IDEA基础" class="headerlink" title="IDEA基础"></a>IDEA基础</h4><h5 id="idea配置文件位置"><a href="#idea配置文件位置" class="headerlink" title="idea配置文件位置"></a>idea配置文件位置</h5><ul><li><p>打开<code>idea.properties</code></p></li><li><p>修改配置位置</p><p><img src="http://wrr123.github.io/2021/03/19/idea-how2j/001.png" alt="p"></p></li><li><p>重新启动idea</p></li></ul><span id="more"></span><h5 id="java-project"><a href="#java-project" class="headerlink" title="java project"></a>java project</h5><h5 id="增加jar（如果需要用到第三方的jar包）"><a href="#增加jar（如果需要用到第三方的jar包）" class="headerlink" title="增加jar（如果需要用到第三方的jar包）"></a>增加jar（如果需要用到第三方的jar包）</h5><ul><li><p>下载好jar包，并放到文件的<code>lib</code>目录下</p></li><li><p>添加jar到路径</p><p>右键<code>lib</code>目录-&gt;<code>Add as Library...</code>,弹出个对话框，点击ok即可。</p><p><img src="http://wrr123.github.io/2021/03/19/idea-how2j/002.png" alt></p></li><li><p>再次运行项目就可以了</p></li></ul><h5 id="Web-Project"><a href="#Web-Project" class="headerlink" title="Web Project"></a>Web Project</h5><ul><li><p>新建项目</p><p>菜单-&gt;File-&gt;New-&gt;Project-&gt;Web Application-&gt;OK</p></li><li><p>新建目录，直到项目建立完成</p></li><li><p>新建<code>HelloServlet</code></p><p>下载servlet所需的jar包，并放在项目的lib目录下</p></li><li><p>指定输出目录</p><ol><li><p>打开project structure</p></li><li><p>设置project complier output</p><p><img src="http://wrr123.github.io/2021/03/19/idea-how2j/003.png" alt></p></li></ol></li><li><p>修改web.xml文件，配置servlet的映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h5><h5 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h5><h5 id="Eclipse-Web项目"><a href="#Eclipse-Web项目" class="headerlink" title="Eclipse Web项目"></a>Eclipse Web项目</h5><h5 id="maven项目没有resources目录怎么办？"><a href="#maven项目没有resources目录怎么办？" class="headerlink" title="maven项目没有resources目录怎么办？"></a>maven项目没有resources目录怎么办？</h5><ul><li>打开project structure</li><li>点击左边的Modules<ul><li>点击Sources</li><li>点击Main</li><li>点击New Folder，然后输入 resoureces</li></ul></li><li>右键resources，将其标记为<code>resources</code></li></ul><h4 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h4><h5 id="maven在idea下的配置"><a href="#maven在idea下的配置" class="headerlink" title="maven在idea下的配置"></a>maven在idea下的配置</h5><h5 id="一个简单的maven-project"><a href="#一个简单的maven-project" class="headerlink" title="一个简单的maven project"></a>一个简单的maven project</h5><h5 id="maven增加jar包"><a href="#maven增加jar包" class="headerlink" title="maven增加jar包"></a>maven增加jar包</h5><h5 id="新建maven-web项目"><a href="#新建maven-web项目" class="headerlink" title="新建maven web项目"></a>新建maven web项目</h5><h6 id="注解-WebServlet"><a href="#注解-WebServlet" class="headerlink" title="注解@WebServlet"></a>注解<code>@WebServlet</code></h6><p>在Servlet3.0之后，我们可以不在web.xml文件中配置servlet，只需要加上<code>@WebServlet</code>注解就可以修改servlet的属性了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(description = &quot;a enter for wechat&quot;, urlPatterns = &#123; &quot;/aaa&quot;&#125;,loadOnStartup=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatIndexServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="父子项目"><a href="#父子项目" class="headerlink" title="父子项目"></a>父子项目</h5><ul><li><p>创建一个项目，将pom.xml文件的<code>&lt;packaging/&gt;</code>标签设置为<code>pom</code>。</p></li><li><p>创建子项目，<code>New -&gt; Module</code></p><p>此时，在父项目中会生成一个标签<code>&lt;modules /&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>childMavneProject<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><h4 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h4>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;IDEA基础&quot;&gt;&lt;a href=&quot;#IDEA基础&quot; class=&quot;headerlink&quot; title=&quot;IDEA基础&quot;&gt;&lt;/a&gt;IDEA基础&lt;/h4&gt;&lt;h5 id=&quot;idea配置文件位置&quot;&gt;&lt;a href=&quot;#idea配置文件位置&quot; class=&quot;headerlink&quot; title=&quot;idea配置文件位置&quot;&gt;&lt;/a&gt;idea配置文件位置&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开&lt;code&gt;idea.properties&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改配置位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wrr123.github.io/2021/03/19/idea-how2j/001.png&quot; alt=&quot;p&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重新启动idea&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="how2j" scheme="https://wrr123.github.io/tags/how2j/"/>
    
  </entry>
  
  <entry>
    <title>springCloud-basis</title>
    <link href="https://wrr123.github.io/2021/03/17/springCloud-basis/"/>
    <id>https://wrr123.github.io/2021/03/17/springCloud-basis/</id>
    <published>2021-03-17T05:56:49.000Z</published>
    <updated>2021-03-23T11:24:10.579Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5个SpringCloud注释"><a href="#5个SpringCloud注释" class="headerlink" title="5个SpringCloud注释"></a>5个SpringCloud注释</h4><ol><li><p><code>@EnableConfigServer</code></p><p>它将你的应用程序转换为一个服务器，其他应用程序可以使用它来获取配置。这是一个非常有用的注释，用于使用Spring云开发Java中的服务，在那里可以有一个专用Java服务来配置。</p></li><li><p><code>@EnableEurekaServer</code></p><p>它使你的应用程序成为<code>Eureka</code>发现服务，其他应用程序可以使用它来定位服务。</p></li><li><p><code>@EnableDiscoveryClient</code></p><p>它使你的应用程序注册到服务发现中，并通过它发现其他服务。</p></li><li><p><code>@EnableCircuitBreaker</code></p><p>它配置了<code>Hystrix</code>断路器协议。</p><p>如果你必须构建一个使用断路器模式的微服务器应用程序，那么你直到当方法调用失败时，它可以适当地降低功能。</p><p>使用断路器模式还允许微服务在相关服务发生故障时继续运行，防止级联故障，从而给故障服务时间恢复。</p></li><li><p><code>@HystrixCommand(fallbackMethod=&quot;fallbackMethodName&quot;)</code></p><p>如果方法不能正常成功，那么这个注解将标记这些方法返回到另一个方法。</p><p><strong>目前，这只适用于标记有<code>@Component</code> 或 <code>@Service</code> 注释的类。</strong></p></li></ol><span id="more"></span><h4 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h4><h5 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h5><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p><p>Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：</p><ul><li>Spring Cloud Config</li><li>Spring Cloud Netflix</li><li>Spring Cloud CloudFoundry</li><li>Spring Cloud AWS</li><li>Spring Cloud Security</li><li>Spring Cloud Commons</li><li>Spring Cloud Zookeeper</li><li>Spring Cloud CLI</li><li>…</li></ul><h5 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h5><p>简单地说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务之间通过诸如<code>RESTful API</code>的方式互相调用。</p><h5 id="服务注册和发现-1"><a href="#服务注册和发现-1" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h5><p>这里我们会用到Spring Cloud的一个子项目，<code>Spring Cloud Netflix</code>，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。</p><p>通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p><p>它主要提供的模块包括：服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）、客户端负载均衡（Ribbon）等。</p><h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><h5 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h5><p>Ribbon是一个基于HTTP和TCP客户端的负载均衡器。Feign中也会适用Ribbon。</p><p>Ribbon可以在通过客户端中配置的<code>ribbonServerList</code>服务端列表去轮询访问以达到负载均衡的作用。</p><p>当Ribbon和Eureka联合使用时，ribbonServerList会被<code>DiscoveryEnabledNIWSServerList</code>重写，扩展成从Eureka注册中心获取服务端列表。同时它也会用<code>NIWSDiscoveryPing</code>来取代<code>Ping</code>，它将职责委托给Eureka来确定服务端是否已经启动。</p><h6 id="注解-LoadBalanced"><a href="#注解-LoadBalanced" class="headerlink" title="注解@LoadBalanced"></a>注解<code>@LoadBalanced</code></h6><p>开启负载均衡能力</p><h5 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h5><p>Feign是一个声明式的Web Service客户端，它使得编写Web Service客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它即可完成。它具备可插拔的注解支持，包括Feign注解和JAX-RS注解。Feign也支持可插拔的编码器和解码器。Spring Cloud为Feign增加了Spring MVC注解的支持，还整合了Ribbon和Eureka来提供负载均衡的HTTP的客户端实现。</p><h4 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h4><p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，最终导致自身服务的瘫痪。</p><blockquote><p>举个例子，在一个电商网站中，我们可能会将系统拆分成，用户、订单、库存、积分、评论等一系列的服务单元。用户创建一个订单的时候，在调用订单服务创建订单的时候，会向库存服务来请求出货（判断是否有足够库存来出货）。此时若库存服务因网络原因无法被访问到，导致创建订单服务的线程进入等待库存申请服务的响应，在漫长的等待之后用户会因为请求库存失败而得到创建订单失败的结果。如果在高并发情况之下，因这些等待线程在等待库存服务的响应而未能释放，使得后续到来的创建订单请求被阻塞，最终导致订单服务也不可用。</p></blockquote><p>在微服务架构中，存在着那么多的服务单元，若一个单元出现故障，就会因依赖关系形成故障蔓延，最终导致整个系统的瘫痪，这样的架构相较传统架构就更加的不稳定。为了解决这个问题，因此产生了断路器模式。</p><h5 id="什么是断路器"><a href="#什么是断路器" class="headerlink" title="什么是断路器"></a>什么是断路器</h5><blockquote><p>“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p></blockquote><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p><h5 id="Netflix-Hystrix"><a href="#Netflix-Hystrix" class="headerlink" title="Netflix Hystrix"></a>Netflix Hystrix</h5><p>在Spring Cloud 中使用了Hystrix来实现断路器的功能。</p><p>Hystrix是NetFlix开源的微服务框架套件之一，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。</p><p>Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</p><ul><li>Robbin中引入Hystrix</li><li>Feign使用Hystrix</li></ul><h4 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h4><p>Spring Cloud Config 为服务端和客户端提供了分布式系统的外部化配置支持。配置服务器为各应用的所有环境提供了一个中心化的外部配置。它实现了对服务端和客户端对Spring Environment和PropertySource抽象的映射，所以它除了适用于Spring构建的应用程序，也可以在任何其他语言运行的应用程序中使用。作为一个应用可以通过部署管道来进行测试或投入生产，我们可以分别为这些环境创建配置，并且在需要迁移环境的时候获取对应环境的配置来运行。</p><p><strong>它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库。</strong></p><h5 id="构建Config-Server"><a href="#构建Config-Server" class="headerlink" title="构建Config Server"></a>构建Config Server</h5><p>通过Spring Cloud来构建一个Config Server，需要三步：</p><ol><li><p>pom.xml引入 <code>spring-cloud-config-server</code>依赖</p></li><li><p>创建Spring Boot的程序主类，并添加<code>@EnableConfigServer</code>注解，开启Config Server</p></li><li><p><code>application.properties</code>中配置服务信息以及git信息</p><p>一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=config-server</span><br><span class="line">server.port=<span class="number">7001</span></span><br><span class="line"></span><br><span class="line"># git管理配置</span><br><span class="line">spring.cloud.config.server.git.uri=http:<span class="comment">//git.oschina.net/didispace/SpringBoot-Learning/</span></span><br><span class="line">spring.cloud.config.server.git.searchPaths=Chapter9-<span class="number">1</span>-<span class="number">4</span>/config-repo</span><br><span class="line">spring.cloud.config.server.git.username=username</span><br><span class="line">spring.cloud.config.server.git.password=password</span><br></pre></td></tr></table></figure></li></ol><h5 id="服务端验证"><a href="#服务端验证" class="headerlink" title="服务端验证"></a>服务端验证</h5><p><img src="http://wrr123.github.io/2021/03/17/springCloud-basis/001.png" alt></p><h5 id="微服务端映射配置"><a href="#微服务端映射配置" class="headerlink" title="微服务端映射配置"></a>微服务端映射配置</h5><h6 id="在微服务应用中获取配置信息"><a href="#在微服务应用中获取配置信息" class="headerlink" title="在微服务应用中获取配置信息"></a>在微服务应用中获取配置信息</h6><ul><li><p>创建一个Spring Boot应用，在pom.xml中引入spring-cloud-starter-config依赖</p></li><li><p>创建最基本的spring-boot启动主类</p></li><li><p>创建<code>bootstrap.properties</code>配置，来指定config server</p><p>一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=didispace</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">spring.cloud.config.label=master</span><br><span class="line">spring.cloud.config.uri=http:<span class="comment">//localhost:7001/</span></span><br><span class="line">server.port=<span class="number">7002</span></span><br></pre></td></tr></table></figure><p><strong>这里需要格外注意：上面这些属性必须配置在<code>bootstrap.properties</code>中，config部分内容才能被正确加载。因为config的相关配置会先于<code>application.properties</code>，而<code>bootstrap.properties</code>的加载也是先于<code>application.properties</code>。</strong></p></li><li><p>创建一个REST API来返回配置中心的 <code>form</code> 属性</p></li></ul><h4 id="分布式配置中心（续）"><a href="#分布式配置中心（续）" class="headerlink" title="分布式配置中心（续）"></a>分布式配置中心（续）</h4><h5 id="上一章spring-cloud-config的使用"><a href="#上一章spring-cloud-config的使用" class="headerlink" title="上一章spring cloud config的使用"></a>上一章spring cloud config的使用</h5><ul><li>构建了config-server，连接到Git仓库</li><li>在Git上创建了一个config-repo目录，用来存储配置信息</li><li>构建了config-client，来获取git中的配置信息</li></ul><h5 id="高可用问题"><a href="#高可用问题" class="headerlink" title="高可用问题"></a>高可用问题</h5><h6 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h6><p>通常在生产环境，Config Server与服务注册中心一样，我们也需要将其扩展为高可用的集群。</p><p><img src="http://wrr123.github.io/2021/03/17/springCloud-basis/002.png" alt></p><h6 id="注册为服务"><a href="#注册为服务" class="headerlink" title="注册为服务"></a>注册为服务</h6><p>虽然通过服务器负载均衡已经能够实现，但是作为架构内的配置管理，本身其实也是可以看作架构中的一个微服务。所以，另外一种更为简单的方法就是把config-server也注册为服务，这样所有客户端就能以服务的方式进行访问。通过这种方法，只需要启动多个指向同一个Git仓库位置的config-server就能实现高可用了。</p><p><strong>注解@RefreshScope的含义</strong></p><ul><li>在类上实现对象属性的动态更新</li></ul><h4 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h4><h5 id="now："><a href="#now：" class="headerlink" title="now："></a>now：</h5><p>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hyxtrix的熔断机制来避免在微服务架构中，个别服务出现异常时引起的故障蔓延。</p><h5 id="服务网关-1"><a href="#服务网关-1" class="headerlink" title="服务网关"></a>服务网关</h5><p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，他还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p><h5 id="开始使用Zuul"><a href="#开始使用Zuul" class="headerlink" title="开始使用Zuul"></a>开始使用Zuul</h5><ul><li><p>引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>这里用了<code>@SpringCloudApplication</code>注解，之前没有提过，通过源码我们看到，它整合了<code>@SpringBootApplication</code>、<code>@EnableDiscoveryClient</code>、<code>@EnableCircuitBreaker</code>，主要目的还是简化配置。</strong></p><h5 id="Zuul配置"><a href="#Zuul配置" class="headerlink" title="Zuul配置"></a>Zuul配置</h5><h6 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h6><p>在Zuul中提供了两种映射方式：</p><ol><li><p>通过url直接映射</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># routes to url</span></span><br><span class="line"><span class="meta">zuul.routes.api-a-url.path</span>=<span class="string">/api-a-url/**</span></span><br><span class="line"><span class="meta">zuul.routes.api-a-url.url</span>=<span class="string">http://localhost:2222/</span></span><br></pre></td></tr></table></figure></li><li><p>将Zuul注册到eureka server上去发现其他服务，就可以实现对ServerId的映射</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zuul.routes.api-a.path</span>=<span class="string">/api-a/**</span></span><br><span class="line"><span class="meta">zuul.routes.api-a.serviceId</span>=<span class="string">service-A</span></span><br><span class="line"></span><br><span class="line"><span class="meta">zuul.routes.api-b.path</span>=<span class="string">/api-b/**</span></span><br><span class="line"><span class="meta">zuul.routes.api-b.serviceId</span>=<span class="string">service-B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:1111/eureka/</span></span><br></pre></td></tr></table></figure><p><strong>推荐使用serviceId的映射方式，除了对Zuul维护上更加友好之外，serviceId映射方式还支持了断路器，对于服务故障的情况下，可以有效的防止故障蔓延到服务网关上而影响整个系统的对外服务</strong></p></li></ol><h6 id="服务过滤"><a href="#服务过滤" class="headerlink" title="服务过滤"></a>服务过滤</h6><p>在完成服务路由之后，我们对外开发服务还需要一些安全措施来保护客户端只能访问它应该访问到的资源。</p><p>所以我们需要利用Zuul的过滤器来实现我们对外服务的安全控制。</p><p>在服务网关中定义过滤器只需要继承<code>ZuulFilter</code>抽象类实现其定义的四个抽象函数就可对请求进行拦截与过滤。</p><p>需要重写实现下面的四个方法：</p><ul><li><code>filterType</code>：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：<ul><li><code>pre</code>：可以在请求被路由之前调用</li></ul></li><li><code>routing</code>：在路由请求时候被调用<ul><li><code>post</code>：在routing和error过滤器之后被调用</li></ul></li><li><p><code>error</code>：处理请求时发生错误时被调用</p></li><li><p><code>filterOrder</code>：通过int值来定义过滤器的执行顺序</p></li><li><p><code>shouldFilter</code>：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可实现过滤器的开关。在上例中，我们直接返回true，所以该过滤器总是生效。</p></li><li><p><code>run</code>：过滤器的具体逻辑。需要注意，这里我们通过<code>ctx.setSendZuulResponse(false)</code>令zuul过滤该请求，不对其进行路由，然后通过<code>ctx.setResponseStatusCode(401)</code>设置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过<code>ctx.setResponseBody(body)</code>对返回body内容进行编辑等。</p></li></ul><h5 id="为什么服务网关是微服务架构的重要部分？"><a href="#为什么服务网关是微服务架构的重要部分？" class="headerlink" title="为什么服务网关是微服务架构的重要部分？"></a>为什么服务网关是微服务架构的重要部分？</h5><ul><li>不仅仅实现了路由功能来屏蔽诸多服务细节，更实现了服务级别、均衡负载的路由。</li><li>实现了接口权限校验与微服务业务逻辑的解耦。通过服务网关中的过滤器，在各生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，保证了微服务的无状态性，同时降低了微服务的测试难度，让服务本身更集中关注业务逻辑的处理。</li><li>实现了断路器，不会因为具体微服务的故障而导致服务网关的阻塞，依然可以对外服务。</li></ul><h4 id="高可用的服务注册中心"><a href="#高可用的服务注册中心" class="headerlink" title="高可用的服务注册中心"></a>高可用的服务注册中心</h4><p>我们之前的服务注册中心是单点的，并不是适用于线上生产环境，因此构建高可用的Eureka Server集群就显得很重要了。</p><h5 id="Eureka-Server的高可用"><a href="#Eureka-Server的高可用" class="headerlink" title="Eureka Server的高可用"></a>Eureka Server的高可用</h5><p>Eureka Server除了单点运行之外，还可以通过运行多个实例，并进行互相注册的方式来实现高可用的部署，所以我们只需要将Eureka Server配置其他可用的serviceUrl就能实现高可用部署。</p><h5 id="服务注册和发现-2"><a href="#服务注册和发现-2" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=compute-service</span><br><span class="line">server.port=2222</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的配置主要对<code>eureka.client.serviceUrl.defaultZone</code>属性做了改动，将注册中心指向了之前我们搭建的peer1与peer2。</p><h5 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h5><p>Eureka Server的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。</p><p><strong>两两注册的方式可以实现集群中节点完全对等的效果，实现最高可用性集群，任何一台注册中心故障都不会影响服务的注册和发现。</strong></p><h4 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h4><p>一个问题：如何实现对配置信息的实时更新。</p><p>虽然我们已经可以通过<code>/refresh</code>接口和GIT仓库的web hook来实现Git仓库中的内容修改触发应用程序的属性更新。但是随着系统的不断扩张，会变得越来越难以维护，而消息代理中间件是解决这个问题的最佳方案。</p><p><strong>消息中间代理件可以将消息路由到一个或多个目的地。</strong></p><h5 id="RabbitMQ实现"><a href="#RabbitMQ实现" class="headerlink" title="RabbitMQ实现"></a>RabbitMQ实现</h5><ul><li><p>添加jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在配置文件中增加关于RabbitMQ的连接和用户信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">springcloud</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li><li><p>启动config-server-eureka，再启动两个config-client-eureka（分别在不同的端口上，比如7002、7003），我们可以在config-client-eureka中的控制台中看到如下内容，在启动时候，客户端程序多了一个<code>/bus/refresh</code>请求</p></li><li><p>先访问两个config-client-eureka的<code>/from</code>请求，会返回当前<code>config-repo/didispace-dev.properties</code>中的from属性。</p></li><li>接着，我们修改<code>config-repo/didispace-dev.properties</code>中的from属性值，并发送POST请求到其中的一个<code>/bus/refresh</code>。</li><li>最后，我们再分别访问启动的两个config-client-eureka的<code>/from</code>请求，此时这两个请求都会返回最新的<code>config-repo/didispace-dev.properties</code>中的from属性。</li></ul><h4 id="消息总线（续：Kafka）"><a href="#消息总线（续：Kafka）" class="headerlink" title="消息总线（续：Kafka）"></a>消息总线（续：Kafka）</h4><h5 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h5><p>Kafka是一个由LinkedIn开发的分布式消息系统。</p><p>Kafka是基于消息发布、订阅模式实现的消息系统，其主要设计目标如下：</p><ul><li>消息持久化：以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐：在廉价的商用机器上也能支持单机每秒100K条以上的吞吐量</li><li>分布式：支持消息分区以及分布式消费，并保证分区内的消息顺序</li><li>跨平台：支持不同技术平台的客户端（如：Java、PHP、Python等）</li><li>实时性：支持实时数据处理和离线数据处理</li><li>伸缩性：支持水平扩展</li></ul><p>Kafka中涉及的一些概念：</p><ul><li>Broker：Kafka集群包含一个或多个服务器，这些服务器被称为Broker。</li><li>Topic：逻辑上同Rabbit的Queue队列相似，每条发布到Kafka集群的消息都必须有一个Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个Broker上，但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li>Partition：Partition是物理概念上的分区，为了提供系统吞吐率，在物理上每个Topic会分成一个或多个Partition，每个Partition对应一个文件夹（存储对应分区的消息内容和索引文件）。</li><li>Producer：消息生产者，负责生产消息并发送到Kafka Broker。</li><li>Consumer：消息消费者，向Kafka Broker读取消息并处理的客户端。</li><li>Consumer Group：每个Consumer属于一个特定的组（可为每个Consumer指定属于一个组，若不指定则属于默认组），组可以用来实现一条消息被组内多个成员消费等功能。</li></ul><h5 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h5><ol><li>启动ZooKeeper</li><li>启动Kafka</li><li>创建Topic</li><li>创建消息生产者</li><li>创建消息消费者</li></ol><h5 id="整合Spring-Cloud-Bus"><a href="#整合Spring-Cloud-Bus" class="headerlink" title="整合Spring Cloud Bus"></a>整合Spring Cloud Bus</h5>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;5个SpringCloud注释&quot;&gt;&lt;a href=&quot;#5个SpringCloud注释&quot; class=&quot;headerlink&quot; title=&quot;5个SpringCloud注释&quot;&gt;&lt;/a&gt;5个SpringCloud注释&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;@EnableConfigServer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它将你的应用程序转换为一个服务器，其他应用程序可以使用它来获取配置。这是一个非常有用的注释，用于使用Spring云开发Java中的服务，在那里可以有一个专用Java服务来配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;@EnableEurekaServer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它使你的应用程序成为&lt;code&gt;Eureka&lt;/code&gt;发现服务，其他应用程序可以使用它来定位服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;@EnableDiscoveryClient&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它使你的应用程序注册到服务发现中，并通过它发现其他服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;@EnableCircuitBreaker&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它配置了&lt;code&gt;Hystrix&lt;/code&gt;断路器协议。&lt;/p&gt;
&lt;p&gt;如果你必须构建一个使用断路器模式的微服务器应用程序，那么你直到当方法调用失败时，它可以适当地降低功能。&lt;/p&gt;
&lt;p&gt;使用断路器模式还允许微服务在相关服务发生故障时继续运行，防止级联故障，从而给故障服务时间恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;@HystrixCommand(fallbackMethod=&amp;quot;fallbackMethodName&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果方法不能正常成功，那么这个注解将标记这些方法返回到另一个方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前，这只适用于标记有&lt;code&gt;@Component&lt;/code&gt; 或 &lt;code&gt;@Service&lt;/code&gt; 注释的类。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://wrr123.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java8特性详解</title>
    <link href="https://wrr123.github.io/2021/03/16/java8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wrr123.github.io/2021/03/16/java8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-16T01:28:26.000Z</published>
    <updated>2021-03-23T11:24:10.577Z</updated>
    
    <content type="html"><![CDATA[<h4 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h4><p><img src="http://wrr123.github.io/2021/03/16/java8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/Java8.png" alt></p><span id="more"></span><h4 id="函数编程（Lambda表达式）"><a href="#函数编程（Lambda表达式）" class="headerlink" title="函数编程（Lambda表达式）"></a>函数编程（Lambda表达式）</h4><p>面向对象编程是对数据进行抽象；<strong>函数式编程是对行为进行抽象。</strong></p><p>核心思想：</p><ul><li>使用不可变值和函数，函数对一个值进行处理，映射成另一个值。</li></ul><h5 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h5><p>lambda表达式仅能放入 <strong>预定义使用了@Functional注解的函数式接口，自带一个抽象函数的方法，或者SAM（Single Abstract Method 单个抽象方法）类型。</strong></p><ul><li>Lambda内部可以使用静态、非静态和局部变量，这成为lambda内的变量捕获。</li><li>Lambda表达式在java中又可成为 <strong>闭包或匿名函数。</strong></li><li>Lambda表达式有个限制，那就是只能引用final或final局部变量，这就是说不能在lambda表达式内部修改定义在域外的变量。</li></ul><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li>惰性求值方法</li><li>及早求值方法</li></ul><h5 id="stream-和-parallelStream"><a href="#stream-和-parallelStream" class="headerlink" title="stream 和 parallelStream"></a>stream 和 parallelStream</h5><p>每个stream都有两种模式：顺序执行和并行执行。</p><h5 id="Stream中常用的方法"><a href="#Stream中常用的方法" class="headerlink" title="Stream中常用的方法"></a>Stream中常用的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream(), parallelStream()</span><br><span class="line">filter()</span><br><span class="line">findAny() findFirst()</span><br><span class="line">sort</span><br></pre></td></tr></table></figure><p><code>forEach</code> void</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(), reduce()</span><br></pre></td></tr></table></figure><p><code>flatMap()</code> - 将多个Stream连接成一个Stream</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">collect(Collectors.toList())</span><br><span class="line">distinct, limit</span><br><span class="line">count</span><br><span class="line">min, max, summaryStatistics</span><br></pre></td></tr></table></figure><h4 id="Optional类深度解析"><a href="#Optional类深度解析" class="headerlink" title="Optional类深度解析"></a>Optional类深度解析</h4><p>这是一个可以为null的容器对象。如果值存在则<code>isPresent()</code>方法会返回true，调用<code>get()</code>方法会返回该对象。</p><h5 id="Optional类包含的方法"><a href="#Optional类包含的方法" class="headerlink" title="Optional类包含的方法"></a>Optional类包含的方法</h5><ul><li><p><code>of</code> 为非null的值创建一个Optional。如果你传了一个null，则会报错<code>NullPointerException</code>。</p></li><li><p><code>ofNullable</code> 为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。</p></li><li><p><code>isPresent</code> 如果值存在，则返回true，否则返回false。</p></li><li><p><code>get</code> 如果Optional有值则将其返回，否则抛出<code>NoSuchElementException</code>。</p></li><li><p><code>ifPresent</code> 如果Optional实例有值，则为其调用<code>consumer</code>，否则不做处理。</p></li><li><p><code>orElse</code> 如果有值则将其返回，否则返回指定的其他值。</p></li><li><p><code>orElseGet</code> <code>orElseGet</code> 和 <code>orElse</code> 类似，区别在于得到的默认值。<code>orElse</code>将和optional中元素类型相同的值作为默认值，<code>orElseGet</code>方法可以接受<code>Supplier</code>接口的实现用来生成默认值。</p></li><li><p><code>orElseThrow</code> 如果有值将其返回，否则抛出<code>Supplier</code>接口创建的异常。</p></li><li><p><code>map</code> 如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。</p></li><li><p><code>flatMap</code> </p><blockquote><p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map(Funtion)方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。</p></blockquote></li><li><p><code>filter</code>  通过传入限定条件对Optional实例的值进行过滤。</p></li></ul><p>一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Optional实例，也可以通过方法返回值得到。</span></span><br><span class="line">    Optional&lt;String&gt; name = Optional.of(<span class="string">&quot;Sanaulla&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建没有值的Optional实例，例如值为&#x27;null&#x27;</span></span><br><span class="line">    Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//isPresent方法用来检查Optional实例是否有值。</span></span><br><span class="line">    <span class="keyword">if</span> (name.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//调用get()返回Optional值。</span></span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//在Optional实例上调用get()抛出NoSuchElementException。</span></span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ifPresent方法接受lambda表达式参数。</span></span><br><span class="line">    <span class="comment">//如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span></span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;The length of the value is: &quot;</span> + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span></span><br><span class="line">    System.out.println(empty.orElse(<span class="string">&quot;There is no value present!&quot;</span>));</span><br><span class="line">    System.out.println(name.orElse(<span class="string">&quot;There is some value!&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//orElseGet与orElse类似，区别在于传入的默认值。</span></span><br><span class="line">    <span class="comment">//orElseGet接受lambda表达式生成默认值。</span></span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; <span class="string">&quot;Default Value&quot;</span>));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; <span class="string">&quot;Default Value&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//orElseThrow与orElse方法类似，区别在于返回值。</span></span><br><span class="line">      <span class="comment">//orElseThrow抛出由传入的lambda表达式/方法生成异常。</span></span><br><span class="line">      empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map方法通过传入的lambda表达式修改Optonal实例默认值。 </span></span><br><span class="line">    <span class="comment">//lambda表达式返回值会包装为Optional实例。</span></span><br><span class="line">    Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">&quot;No value found&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//flatMap与map(Funtion)非常相似，区别在于lambda表达式的返回值。</span></span><br><span class="line">    <span class="comment">//map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span></span><br><span class="line">    <span class="comment">//但是flatMap方法的lambda返回值总是Optional类型。</span></span><br><span class="line">    upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">&quot;No value found&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter方法检查Optiona值是否满足给定条件。</span></span><br><span class="line">    <span class="comment">//如果满足返回Optional实例值，否则返回空Optional。</span></span><br><span class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(longName.orElse(<span class="string">&quot;The name is less than 6 characters&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一个示例，Optional值不满足给定条件。</span></span><br><span class="line">    Optional&lt;String&gt; anotherName = Optional.of(<span class="string">&quot;Sana&quot;</span>);</span><br><span class="line">    Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(shortName.orElse(<span class="string">&quot;The name is less than 6 characters&quot;</span>));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><h5 id="什么叫默认方法？"><a href="#什么叫默认方法？" class="headerlink" title="什么叫默认方法？"></a>什么叫默认方法？</h5><p>简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个<code>default</code>关键字即可。</p><h6 id="为什么会出现默认方法？"><a href="#为什么会出现默认方法？" class="headerlink" title="为什么会出现默认方法？"></a>为什么会出现默认方法？</h6><blockquote><p>为什么要有这个特性? 首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p></blockquote><h6 id="java8抽象类和接口的对比"><a href="#java8抽象类和接口的对比" class="headerlink" title="java8抽象类和接口的对比"></a>java8抽象类和接口的对比</h6><div class="table-container"><table><thead><tr><th>相同点</th><th>不同点</th></tr></thead><tbody><tr><td>都是抽象类型</td><td>抽象类不可以多重继承，而接口可以（无论是多重类型继承还是多重行为继承）</td></tr><tr><td>都可以有实现方法（java8以前不行）</td><td>抽象类和接口所反映出的设计理念不同。抽象类表示的是<code>is-a</code>的关系，而接口表示的是<code>like-a</code>的关系</td></tr><tr><td>都可以不需要实现类或继承类去实现所有的方法</td><td>抽象类的变量默认是friendly型，其值可以在子类中重新定义，也可以重新赋值；接口中定义的变量默认是<code>public static final</code>型，且必须给其初值，所以实现类中不能改变其值</td></tr></tbody></table></div><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><ul><li>在java8之前，注解只能是在声明的地方所使用，比如类、方法、属性；</li><li>java8里面，注解可以应用在任何地方。</li></ul><h5 id="类型注解的作用"><a href="#类型注解的作用" class="headerlink" title="类型注解的作用"></a>类型注解的作用</h5><p>类型注解被用来支持在Java的程序中做强制类型检查。配合插件式的<code>check framework</code>，可以在编译的时候检测出<code>runtime error</code>，以提高代码质量。这就是类型注解的作用了。</p><h4 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>允许在同一申明类型（类、属性、方法）上，多次使用同一个注解。</p><p>一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Authorities.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     <span class="function">String <span class="title">role</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatAnnotationUseNewVersion</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Authority(role=&quot;Admin&quot;)</span></span><br><span class="line">    <span class="meta">@Authority(role=&quot;Manager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型推断优化"><a href="#类型推断优化" class="headerlink" title="类型推断优化"></a>类型推断优化</h4><h5 id="什么叫泛型？"><a href="#什么叫泛型？" class="headerlink" title="什么叫泛型？"></a>什么叫泛型？</h5><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。通俗点讲，就是“类型的变量”。这种类型变量可以用在类、接口和方法的创建中。</p><h5 id="java8的泛型类型推断改进"><a href="#java8的泛型类型推断改进" class="headerlink" title="java8的泛型类型推断改进"></a>java8的泛型类型推断改进</h5><ol><li>支持通过方法上下文推断泛型目标类型</li><li>支持在方法调用链路中，泛型类型推断传递到最后一个方法。</li></ol><h4 id="JRE精简"><a href="#JRE精简" class="headerlink" title="JRE精简"></a>JRE精简</h4><h5 id="JRE精简的好处"><a href="#JRE精简的好处" class="headerlink" title="JRE精简的好处"></a>JRE精简的好处</h5><ul><li>更小的Java环境需要更少的计算资源</li><li>一个较小的运行时环境可以更好的优化性能和启动时间</li><li>消除未使用的代码从安全的角度总是好的</li><li>这些打包的应用程序可以下载速度更快</li></ul><h5 id="jdeps工具使用"><a href="#jdeps工具使用" class="headerlink" title="jdeps工具使用"></a>jdeps工具使用</h5><h4 id="移除Permgen"><a href="#移除Permgen" class="headerlink" title="移除Permgen"></a>移除Permgen</h4><h5 id="Permgen-Space简单介绍"><a href="#Permgen-Space简单介绍" class="headerlink" title="Permgen Space简单介绍"></a>Permgen Space简单介绍</h5><p>PermGen Space的全称为<code>Permanent Generation Space</code>，是指内存的永久保存区域。</p><blockquote><p>说说为什么会内存益出: 这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。</p></blockquote><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>它是java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p><p>四种不同的同步块：</p><ol><li>实例方法</li><li>静态方法</li><li>实例方法的同步块</li><li>静态方法的同步块</li></ol><h5 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h5><h5 id="StampedLock-1"><a href="#StampedLock-1" class="headerlink" title="StampedLock"></a>StampedLock</h5><h4 id="LocalDate-LocalDateTime"><a href="#LocalDate-LocalDateTime" class="headerlink" title="LocalDate/LocalDateTime"></a>LocalDate/LocalDateTime</h4><h4 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h4><h4 id="其他更新"><a href="#其他更新" class="headerlink" title="其他更新"></a>其他更新</h4><h5 id="处理数值"><a href="#处理数值" class="headerlink" title="处理数值"></a>处理数值</h5><p>java8添加了严格的数学运算。</p><p>一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Math.addExact(Integer.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">    <span class="comment">// =&gt; integer overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h5><p>java8可以将文件用于函数式数据流。</p><p>一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;Path&gt; stream = Files.list(Paths.get(<span class="string">&quot;&quot;</span>))) &#123;</span><br><span class="line">    String joined = stream</span><br><span class="line">        .map(String::valueOf)</span><br><span class="line">        .filter(path -&gt; !path.startsWith(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">        .sorted()</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;List: &quot;</span> + joined);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Path start = Paths.get(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> maxDepth = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;Path&gt; stream = Files.find(start, maxDepth, (path, attr) -&gt;</span><br><span class="line">        String.valueOf(path).endsWith(<span class="string">&quot;.js&quot;</span>))) &#123;</span><br><span class="line">    String joined = stream</span><br><span class="line">        .sorted()</span><br><span class="line">        .map(String::valueOf)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;Found: &quot;</span> + joined);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h5 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; stream = Files.lines(Paths.get(<span class="string">&quot;res/nashorn1.js&quot;</span>))) &#123;</span><br><span class="line">    stream</span><br><span class="line">        .filter(line -&gt; line.contains(<span class="string">&quot;print&quot;</span>))</span><br><span class="line">        .map(String::trim)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;知识体系&quot;&gt;&lt;a href=&quot;#知识体系&quot; class=&quot;headerlink&quot; title=&quot;知识体系&quot;&gt;&lt;/a&gt;知识体系&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://wrr123.github.io/2021/03/16/java8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/Java8.png&quot; alt&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://wrr123.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>springboot-how2j</title>
    <link href="https://wrr123.github.io/2021/03/14/springboot-how2j/"/>
    <id>https://wrr123.github.io/2021/03/14/springboot-how2j/</id>
    <published>2021-03-14T10:53:25.000Z</published>
    <updated>2021-03-14T11:07:37.571Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在学习SSM(H)的过程中，需要做大量的配置工作，其实很多配置行为本身只是手段，并不是目的。基于这个考虑，把该简化的简化，该省略的省略，开发人员只需关系业务功能就行了，这就是 <strong>Springboot.</strong></p><span id="more"></span><h4 id="部署-war方式"><a href="#部署-war方式" class="headerlink" title="部署-war方式"></a>部署-war方式</h4><ul><li><p>Application，新加<code>@ServletComponentScan</code>注解，并继承<code>SpringBootServletInitializer</code>。</p><p>  一个栗子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.springboot;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pom.xml </p><ul><li>新加打包为war的声明</li><li>spring-boot-starter-tomcat修改为 provided方式，以避免和独立 tomcat 容器的冲突.</li></ul></li><li><p>即可创建war包 <code>mvn clean package</code></p></li></ul><h4 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h4><ul><li>yml</li><li>properties</li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;在学习SSM(H)的过程中，需要做大量的配置工作，其实很多配置行为本身只是手段，并不是目的。基于这个考虑，把该简化的简化，该省略的省略，开发人员只需关系业务功能就行了，这就是 &lt;strong&gt;Springboot.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="how2j" scheme="https://wrr123.github.io/tags/how2j/"/>
    
  </entry>
  
</feed>
