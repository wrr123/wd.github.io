<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FAQ-JavaScript</title>
    <url>/2020/08/07/FAQ-JavaScript/</url>
    <content><![CDATA[<h4 id="数值0-0的布尔值是true-还是false？"><a href="#数值0-0的布尔值是true-还是false？" class="headerlink" title="数值0,-0的布尔值是true,还是false？"></a>数值<code>0,-0</code>的布尔值是true,还是false？</h4><p>几个栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!!<span class="number">0</span> <span class="comment">//false</span></span><br><span class="line">!!<span class="string">&#x27;0&#x27;</span> <span class="comment">//true</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span> <span class="comment">//false</span></span><br><span class="line">!![] <span class="comment">//true</span></span><br><span class="line">!!<span class="literal">NaN</span> <span class="comment">//false</span></span><br><span class="line">!!<span class="literal">undefined</span> <span class="comment">//false</span></span><br><span class="line">!!-<span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="延申：Boolean对象是一个布尔值的对象包装器。"><a href="#延申：Boolean对象是一个布尔值的对象包装器。" class="headerlink" title="延申：Boolean对象是一个布尔值的对象包装器。"></a>延申：<code>Boolean对象是一个布尔值的对象包装器。</code></h5><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>如果需要，作为第一个参数传递的值将转换为布尔值。</p>
<p>如果省略或值<code>0，-0，null，false，NaN，undefined</code>，或者空字符串(<code>&quot;&quot;</code>)，该对象具有的初始值为<code>false</code>。</p>
<p>所有的其他值，包括任何对象，空数组(<code>[]</code>)，或者字符串(<code>&quot;false&quot;</code>)，都会创建一个初始值为<code>true</code>的对象。</p>
<p><strong>注意不要将基本类型中的布尔值<code>true</code>和<code>false</code>与值为<code>true</code>和<code>false</code>的<code>Boolean</code>对象弄混了。</strong></p>
<p>其值不是<code>undefined</code>或者<code>null</code>的任何对象（<em>包括其值为<code>false</code>的布尔对象</em>）在传递给条件语句时，都将计算为<code>true</code>。</p>
<p>一个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span>(x) &#123;</span><br><span class="line">  <span class="comment">// 这里的代码将会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是基本类型的布尔值不受其规则影响。</p>
<p>再一个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(x) &#123;</span><br><span class="line">  <span class="comment">// 这里的代码不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要用创建<code>Boolean</code>对象的方式将一个 <strong>非布尔值</strong> 转化为布尔值，直接将<code>Boolean</code>当作转换函数来使用即可。或者使用 <strong>双重非(<code>!!</code>)运算符。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Boolean</span>(expression);     <span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> x = !!(expression);          <span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(expression); <span class="comment">// 不太好</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于任何对象，即使是值为 <code>false</code> 的 <code>Boolean</code> 对象，当将其传给 <code>Boolean</code> 函数时，生成的 <code>Boolean</code> 对象的值都是 <code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFalse = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> <span class="built_in">Boolean</span>(myFalse);       <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Boolean</span>(myString);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>最后，不要在应该使用基本类型布尔值的地方使用 <code>Boolean</code> 对象。</p>
</blockquote>
<h4 id="实现左右布局拖拽功能"><a href="#实现左右布局拖拽功能" class="headerlink" title="实现左右布局拖拽功能"></a>实现左右布局拖拽功能</h4><p>描述：当拖动分割线时，可以重置左右两侧模块宽度实现宽度自定义。</p>
<h5 id="几个基础的概念"><a href="#几个基础的概念" class="headerlink" title="几个基础的概念"></a>几个基础的概念</h5><ul>
<li><p><code>clientX</code> 与 <code>clientWidth</code></p>
<p>clientX：鼠标点击时，位置距离当前 body 可视区域的 x 坐标。</p>
<p>clientWidth</p>
<blockquote>
<p>内联元素以及没有 CSS 样式的元素的 <code>clientWidth</code> 属性值为 0。<code>Element.clientWidth</code> 属性表示元素的内部宽度，以像素计。该属性包括内边距 padding，但不包括边框 border、外边距 margin 和垂直滚动条（如果有的话）。</p>
</blockquote>
</li>
<li><p><code>left</code></p>
<p>相对于具有定位属性( position 定义为 relative) 的父对象的 <strong>左边距</strong></p>
</li>
<li><p><code>offsetLeft</code> 与 <code>offsetWidth</code></p>
<p>offsetLeft：当前元素距父元素 <strong>左侧</strong> 的值</p>
<p>offsetWidth：元素的 width + 元素的 padding + 边框的宽度</p>
</li>
</ul>
<h4 id="将字符串转换为数字的几种方式"><a href="#将字符串转换为数字的几种方式" class="headerlink" title="将字符串转换为数字的几种方式"></a>将字符串转换为数字的几种方式</h4><ol>
<li><p>转换函数 <code>parseInt</code> <code>parseFloat</code></p>
</li>
<li><p>强制类型转换 </p>
<blockquote>
<p>Boolean(value)——把给定的值转换成Boolean型；<br>Number(value)——把给定的值转换成数字（可以是整数或浮点数）；<br>String(value)——把给定的值转换成字符串。</p>
</blockquote>
</li>
<li><p>利用 js 的弱类型转换</p>
<p> 一个栗子：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span>   str= <span class="string">&#x27;012.345 &#x27;</span>;</span><br><span class="line"><span class="keyword">var</span>   x   =   str-<span class="number">0</span>;</span><br><span class="line">x   =   x*<span class="number">1</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="js数组合并的方法（一个数组的元素添加到另一个元素中）"><a href="#js数组合并的方法（一个数组的元素添加到另一个元素中）" class="headerlink" title="js数组合并的方法（一个数组的元素添加到另一个元素中）"></a>js数组合并的方法（一个数组的元素添加到另一个元素中）</h4><p>直接使用 <code>push</code> 方法的话，一个数组会成为另一个数组的子元素。</p>
<p><strong>concat(Array)方法</strong></p>
<blockquote>
<p>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。<br>array1.concat([item1[, item2[, . . . [, itemN]]]])</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>faq</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery-how2j</title>
    <url>/2021/03/13/JQuery-how2j/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>JQuery是一个javascript的框架，是对javascript的一个封装。</p>
<p>通过JQuery可以非常方便的操作HTML的元素。</p>
<p>一些常规的操作：</p>
<ul>
<li>使用JQuery隐藏和显示元素</li>
<li>理解<code>$(function()&#123;&#125;)</code>的意义</li>
<li>通过<code>id</code>获取元素</li>
<li>增加监听器</li>
</ul>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>val</td>
<td>取值</td>
</tr>
<tr>
<td>html</td>
<td>获取元素内容，如果有子元素，保留标签</td>
</tr>
<tr>
<td>text</td>
<td>获取元素内容，如果有子元素，不包含子元素标签</td>
</tr>
</tbody>
</table>
</div>
<h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>addClass</td>
<td>增加class</td>
</tr>
<tr>
<td>removeClass</td>
<td>删除class</td>
</tr>
<tr>
<td>toggleClass</td>
<td>切换class</td>
</tr>
<tr>
<td>css</td>
<td>css函数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="css函数"><a href="#css函数" class="headerlink" title="css函数"></a>css函数</h5><p>格式：<code>css(property, value)</code> 或 <code>css(&#123;p1: v1, p2: v2, ...&#125;)</code></p>
<p>可以分别给元素添加单个样式或者多个样式。</p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介(*选择器)</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(“tagName”)</td>
<td>元素</td>
</tr>
<tr>
<td>$(“#id”)</td>
<td>id</td>
</tr>
<tr>
<td>$(“.className”)</td>
<td>类</td>
</tr>
<tr>
<td>$(“selector1 selector2”)</td>
<td>层级</td>
</tr>
<tr>
<td>:first :last</td>
<td>最先，最后</td>
</tr>
<tr>
<td>:odd :even</td>
<td>奇偶</td>
</tr>
<tr>
<td>:hidden :visible</td>
<td>可见性</td>
</tr>
<tr>
<td>[attribute]</td>
<td>属性</td>
</tr>
<tr>
<td>:input :button …</td>
<td>表单对象</td>
</tr>
<tr>
<td>:disabled :checked :selected</td>
<td>表单对象属性</td>
</tr>
<tr>
<td>this</td>
<td>当前元素</td>
</tr>
</tbody>
</table>
</div>
<h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><p>筛选器指的是在已经通过 <strong>选择器</strong> 选中了元素后，在此基础上进一步选择。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>first()</td>
<td>第一个</td>
</tr>
<tr>
<td>last()</td>
<td>最后一个</td>
</tr>
<tr>
<td>eq(num)</td>
<td>第 num 个</td>
</tr>
<tr>
<td>parent()</td>
<td>父元素</td>
</tr>
<tr>
<td>parents()</td>
<td>祖先元素</td>
</tr>
<tr>
<td>children()</td>
<td>儿子</td>
</tr>
<tr>
<td>find()</td>
<td>后代元素</td>
</tr>
<tr>
<td>siblings()</td>
<td>同级</td>
</tr>
</tbody>
</table>
</div>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>attr</td>
<td>获取</td>
</tr>
<tr>
<td>attr(属性， 值)</td>
<td>修改</td>
</tr>
<tr>
<td>removeAttr</td>
<td>删除</td>
</tr>
</tbody>
</table>
</div>
<h5 id="attr和prop的区别"><a href="#attr和prop的区别" class="headerlink" title="attr和prop的区别"></a>attr和prop的区别</h5><ul>
<li>对于自定义属性，attr可以获取，但是prop不能获取</li>
<li>对于选中属性<ul>
<li>attr只能获取初始值，无论是否改变</li>
<li>prop能够访问变化后的值，并且以<code>true | false</code>的布尔型返回</li>
</ul>
</li>
</ul>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>show hide toggle</td>
<td>显示 隐藏 切换</td>
</tr>
<tr>
<td>slideUp slideDown slideToggle</td>
<td>向上滑动 向下滑动 滑动切换</td>
</tr>
<tr>
<td>fadeIn fadeOut fadeToggle fadeTo</td>
<td>淡入 淡出 淡入淡出切换 指定淡入程度</td>
</tr>
<tr>
<td>animate</td>
<td>自定义动画效果</td>
</tr>
<tr>
<td>callback</td>
<td>回调函数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$(docuemnt).ready()</code>  <code>$()</code> load()</td>
<td>加载</td>
</tr>
<tr>
<td>click() dblclick()</td>
<td>单击 双击</td>
</tr>
<tr>
<td>keydown() keypress() keyup()</td>
<td>键盘事件</td>
</tr>
<tr>
<td>mousedown() mouseup() mousemove() …</td>
<td>鼠标事件</td>
</tr>
<tr>
<td>focus() blur()</td>
<td>焦点移入、移出事件</td>
</tr>
<tr>
<td>change()</td>
<td>改变</td>
</tr>
<tr>
<td>submit()</td>
<td>提交</td>
</tr>
<tr>
<td>on()</td>
<td>绑定</td>
</tr>
<tr>
<td>trigger()</td>
<td>触发事件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>JQuery对Ajax的支持，使得其对Ajax的操作简化了很多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>$.ajax()</td>
<td>提交ajax请求</td>
</tr>
<tr>
<td>$.get()</td>
<td>使用get方式提交ajax</td>
</tr>
<tr>
<td>$.post()</td>
<td>使用post方式提交ajax</td>
</tr>
<tr>
<td>load()</td>
<td>最简单的调用ajax的方式</td>
</tr>
<tr>
<td>sirialize()</td>
<td>格式化form下的输入数据</td>
</tr>
</tbody>
</table>
</div>
<p><strong>有时候form下的输入内容比较多，一个一个的取比较麻烦，就可以用<code>serialize()</code>把输入数据格式化成字符串。</strong></p>
<h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>$.each()</td>
<td>遍历</td>
</tr>
<tr>
<td>$.unique()</td>
<td>去除重复</td>
</tr>
<tr>
<td>$.inArray()</td>
<td>检查数组中是否含有某个元素</td>
</tr>
</tbody>
</table>
</div>
<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>$.trim()</td>
<td>去除首尾空白</td>
</tr>
</tbody>
</table>
</div>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>$.parseJSON()</td>
<td>将json格式的字符串，转换为JSON对象</td>
</tr>
</tbody>
</table>
</div>
<p>一个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://how2j.cn/study/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;盖伦\&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;,\&quot;hp\&quot;:616&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = s1+s2;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;这是一个JSON格式的字符串:&quot;</span> + s3);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> gareen = $.parseJSON(s3);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;这是一个JSON对象: &quot;</span> + gareen);</span><br><span class="line">   </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>get(0)  [0]</td>
<td>JQuery转DOM</td>
</tr>
<tr>
<td>$()</td>
<td>DOM转JQuery</td>
</tr>
</tbody>
</table>
</div>
<p>一个栗子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://how2j.cn/study/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   $(<span class="string">&quot;#b1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> div= $(<span class="string">&quot;#d&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> d = div[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">var</span> s =<span class="string">&quot;JQuery对象是 &quot;</span> + div;</span><br><span class="line">      s +=<span class="string">&quot;\n对应的DOM对象是 &quot;</span> + d</span><br><span class="line">      alert(s);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">     </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;button id=<span class="string">&quot;b1&quot;</span>&gt;JQuery对象div转为DOM对象d&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">    </span><br><span class="line">&lt;style&gt;</span><br><span class="line">.pink&#123;</span><br><span class="line">   background-color:pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">     </span><br><span class="line">&lt;div id=<span class="string">&quot;d&quot;</span>&gt;</span><br><span class="line">Hello JQuery</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>另一个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://how2j.cn/study/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   $(<span class="string">&quot;#b1&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> div= <span class="built_in">document</span>.getElementById(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> d = $(div);</span><br><span class="line">      <span class="keyword">var</span> s =<span class="string">&quot;DOM对象是 &quot;</span> + div;</span><br><span class="line">      s +=<span class="string">&quot;\n对应的JQuery对象是 &quot;</span> + d</span><br><span class="line">      alert(s);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">     </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;button id=<span class="string">&quot;b1&quot;</span>&gt;DOM对象div转为JQuery对象d&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">    </span><br><span class="line">&lt;style&gt;</span><br><span class="line">.pink&#123;</span><br><span class="line">   background-color:pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">     </span><br><span class="line">&lt;div id=<span class="string">&quot;d&quot;</span>&gt;</span><br><span class="line">Hello JQuery</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2020/08/24/JavaScript/</url>
    <content><![CDATA[<h4 id="JavaScript-严格模式"><a href="#JavaScript-严格模式" class="headerlink" title="JavaScript 严格模式"></a>JavaScript 严格模式</h4><p>JavaScript 严格模式（strict mode）即在严格的条件下运行。</p>
<h5 id="使用-“use-strict”-指令"><a href="#使用-“use-strict”-指令" class="headerlink" title="使用 “use strict” 指令"></a>使用 “use strict” 指令</h5><p>“use strict” 指令在 JavaScript 1.8.5 （ECMAScript5）中新增。</p>
<p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p>
<p>“use strict” 的目的是指定代码在严格条件下执行。</p>
<p>严格模式下你不能使用 <strong>未声明的变量 。</strong></p>
<span id="more"></span>
<h5 id="严格模式声明"><a href="#严格模式声明" class="headerlink" title="严格模式声明"></a>严格模式声明</h5><p>严格模式通过在脚本或函数的头部添加 <code>“use strict”；</code> 表达式来声明。</p>
<h4 id="js-清除空格的几种类型"><a href="#js-清除空格的几种类型" class="headerlink" title="js 清除空格的几种类型"></a>js 清除空格的几种类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str为要去除空格的字符串:</span><br><span class="line">去除所有空格:</span><br><span class="line">str = str.replace(<span class="regexp">/\s+/g</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">去除两头空格:</span><br><span class="line">str = str.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">去除左空格：</span><br><span class="line">str=str.replace( <span class="regexp">/^\s/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">去除右空格：</span><br><span class="line">str=str.replace(<span class="regexp">/(\s$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Jhipster</title>
    <url>/2020/09/15/Jhipster/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Jhipster（Java Hipster），旨在生成、开发、部署基于 SpringBoot + Angular/React/Vue 的 Web 应用程序或者 Spring 微服务。</p>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p>目标是为您生成完整的，现代化的 Web 应用程序和微服务架构，即：</p>
<ol>
<li>高可用、健壮的 Java 技术栈服务端 Spring Boot 程序</li>
<li>一个顺滑的、现代的、移动优先的前端 Angular、React 和 Bootstrap 架构</li>
<li>一个健壮的微服务架构包括：JHipster Registry, Netflix OSS, ELK stack 以及 Docker</li>
<li>强大的应用构建流程，如：Yeoman, Webpack/Gulp, 以及 Maven/Gradle</li>
</ol>
<span id="more"></span>
<h5 id="最快构建该框架你需要什么条件"><a href="#最快构建该框架你需要什么条件" class="headerlink" title="最快构建该框架你需要什么条件"></a>最快构建该框架你需要什么条件</h5><ol>
<li>vpn</li>
<li>git</li>
<li>npm</li>
<li>较高版本的 jdk</li>
<li>maven 或者 gradle</li>
<li>Eclipse，IntelliJ IDEA, 或者其他 IDE</li>
<li>Sql 数据库或者 nosql 数据库</li>
</ol>
<h5 id="需要掌握一下技术"><a href="#需要掌握一下技术" class="headerlink" title="需要掌握一下技术"></a>需要掌握一下技术</h5><ol>
<li>Spring Boot 能建成独立 Spring 的应用程式 Spring Security：标准业内的授权和认证</li>
<li>Angular JS/Angular 2.x: JavaScript 的 MVC 框架客户端</li>
<li>BootStrap：来自 Twitter，是比较流行的前端框架</li>
<li>REST APIs：移动开发主导（mobile first）Full Internationalization support</li>
<li>支持完善的国际化文字</li>
<li>Web Socket：允许用户在浏览器中实现双向通信，实现数据的及时通信</li>
<li>嵌入式 tomcat，jetty 及 undertow</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus的lambda表达式</title>
    <url>/2020/07/23/Mybatis-plus%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="java1-8的新特性"><a href="#java1-8的新特性" class="headerlink" title="java1.8的新特性"></a>java1.8的新特性</h4><h5 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h5><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（parameters） -&gt; expression</span><br><span class="line">或</span><br><span class="line">（parameters） -&gt; &#123;statements;&#125;</span><br></pre></td></tr></table></figure>
<p>一些基本的lambda表达式的例子：</p>
<p><img src="http://wrr123.github.io/2020/07/23/Mybatis-plus%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/001.png" alt></p>
<h5 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h5><p>本质上，方法引用就是一个lambda表达式</p>
<p>基本语法</p>
<p><code>类名::方法名</code></p>
<p>四种形式的方法引用</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>引用静态方法</td>
<td>ContainingClass::staticMethodName</td>
</tr>
<tr>
<td>引用某个对象的实例方法</td>
<td>containingObject::instanceMethodName</td>
</tr>
<tr>
<td>引用某个类型的任意对象的实例方法</td>
<td>ContainingType::methodName</td>
</tr>
<tr>
<td>引用构造方法</td>
<td>ClassName::new</td>
</tr>
</tbody>
</table>
</div>
<h4 id="mybatis-plus使用lambda方式的几个demo"><a href="#mybatis-plus使用lambda方式的几个demo" class="headerlink" title="mybatis plus使用lambda方式的几个demo"></a>mybatis plus使用lambda方式的几个demo</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPluralLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TableIntoHelper.initTableInfo(<span class="keyword">null</span>, User.class);</span><br><span class="line">	QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">	queryWrapper.lambda().eq(User::getName, <span class="string">&quot;sss&quot;</span>);</span><br><span class="line">	queryWrapper.lambda().eq(User::getName, <span class="string">&quot;sss2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>通过字段匹配查询，并按照时间排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">baseMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;Entity&gt;()</span><br><span class="line">						.lambda()</span><br><span class="line">						.eq(Entity::getId, <span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">						.orderByDesc(Entity::getCreateTime)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demoService.delete(<span class="keyword">new</span> QueryWrapper&lt;Entity&gt;()</span><br><span class="line">					.lambda()</span><br><span class="line">					.eq(Entity::getShareType, shareType)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Pull Request命令行整理</title>
    <url>/2020/07/08/Pull-Request%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>官方定义</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;Pull Request 是一种通知机制。你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request。&quot;</span><br></pre></td></tr></table></figure>
<p>Pull Request本质上是一种软件的合作方式，是将涉及不同功能的代码，纳入主干代码的流程。在这个过程中，还可以进行讨论、审核和修改代码。</p>
<h2 id="Pull-Request-的流程"><a href="#Pull-Request-的流程" class="headerlink" title="Pull Request 的流程"></a>Pull Request 的流程</h2><p>第一步，你需要把别人的代码，克隆到你自己的仓库，Github 的术语叫做 <a href="https://help.github.com/articles/fork-a-repo/">fork</a>。</p>
<p>第二步，在你仓库的修改后的分支上，按下”New pull request”按钮。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071802.png" alt="img"></p>
<p>这时，会进入一个新页面，有Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071806.png" alt="img"></p>
<p>第三步，填写说明，帮助别人理解你的提交，然后按下”create pull request”按钮即可。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071805.png" alt="img"></p>
<p>PR 创建后，管理者就要决定是否接受该 PR。对于非代码变更（比如文档），单单使用 Web 界面就足够了。但是，对于代码变更，Web 界面可能不够用，需要命令行验证是否可以运行。</p>
<h2 id="git-am"><a href="#git-am" class="headerlink" title="git am"></a>git am</h2><p><code>git am</code>命令用于将一个 patch 文件，合并进入当前代码。</p>
<p>Github 对每个 PR 会自动生成一个 patch 文件。我们下载该文件，合并进本地代码，就可以在本地查看效果了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -L http://github.com/cbeust/testng/pull/17.patch | git am</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>curl</code>的<code>-L</code>参数表示，如果有302跳转，<code>curl</code>会自动跟进。后面网址里面的<code>/cbeust/testng</code>是目标仓库，<code>pull/17</code>表示该仓库收到的第17个 PR。</p>
<p>如果 PR 只包含一个 commit，那么也可以直接下载这个 commit 的 patch 文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://github.com/sclasen/jcommander/commit/bd770141029f49bcfa2e0d6e6e6282b531e69179.patch | git am</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，网址里面的<code>/sclasen/jcommander</code>是代码变更所在的那个仓库。</p>
<h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p>另一种方法是为 PR 创建一个远程分支，追踪提交者的仓库。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建远程仓库，指向 PR 提交者的仓库</span></span><br><span class="line">$ git remote add nullin git://github.com/nullin/testng.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从该远程仓库拉取代码</span></span><br><span class="line">$ git fetch nullin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将该仓库的某个分支合并到当前分支</span></span><br><span class="line">$ git merge kneath/error-page</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到自己的仓库</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>有时，PR 里面包含好几个 commit，但是你只想合并其中的一个或几个。</p>
<p>这时可以使用<code>cherry-pick</code>命令，挑出你感兴趣的 commit。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立远程分支，追踪提交者的仓库</span></span><br><span class="line">$ git remote add nullin git://github.com/nullin/testng.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从该远程仓库拉取代码</span></span><br><span class="line">$ git fetch nullin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只将感兴趣的 commit 加入当前代码</span></span><br><span class="line">$ git cherry-pick commit1</span><br><span class="line">$ git cherry-pick commit2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到自己的仓库</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuffer-StringBuilder区别</title>
    <url>/2020/08/13/StringBuffer-StringBuilder%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>StringBuffer 支持并发操作，是线程安全的，适合多线程使用。</p>
<p>StringBuilder 不支持并发操作，不是线程安全的，但是在单线程中的性能比 StringBuffer 高。 </p>
<span id="more"></span>
<h4 id="延申1：和-String-类型有什么区别"><a href="#延申1：和-String-类型有什么区别" class="headerlink" title="延申1：和 String 类型有什么区别"></a>延申1：和 String 类型有什么区别</h4><p>String 是不可变的对象，因此每次在对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要使用 String，因为每次生成对象都会对系统性能产生影响，特别当内存中 <strong>无引用对象</strong> 多了以后，JVM 的 GC 就会开始工作，性能就会降低。</p>
<h5 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h5><ul>
<li><p>基本原则：如果要操作少量的数据，用 String；单线程操作大量的数据，用 StringBuilder；多线程操作大量的数据，用 StringBuffer。</p>
</li>
<li><p>不要使用 String 类的 “+” 来进行频繁的拼接，因为那样的性能极差，应该使用 StringBuffer 或者 StringBuilder 类，这在 Java 的优化上是一条比较重要的原则。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (String s : hugeArray) &#123;</span><br><span class="line">    result = result + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用StringBuilder</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (String s : hugeArray) &#123;</span><br><span class="line">    sb.append(s);</span><br><span class="line">&#125;</span><br><span class="line">String result = sb.toString();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当出现上面的情况时，显然我们要采用第二种方法，因为第一种方法，每次循环都会<strong>创建一个String result用于保存结果，除此之外二者基本相同（对于jdk1.5及之后版本）</strong>。</p>
</blockquote>
</li>
<li><blockquote>
<p>为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过 16 个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能。</p>
</blockquote>
</li>
<li><blockquote>
<p>StringBuilder 一般使用在方法内部来完成类似 <strong>+</strong> 功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer 主要用在全局变量中。</p>
</blockquote>
</li>
<li><blockquote>
<p>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用 StringBuilder；否则还是用 StringBuffer。</p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>@Transactional注解详解</title>
    <url>/2020/09/08/Transactional%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>明确下面两点：</p>
<ol>
<li>默认配置下，Spring 只会回滚运行时、未检查异常（继承自 RuntimeException 的异常）或者 Error 。</li>
<li><code>@Transactional</code> 注解只能应用到 public 才有效。</li>
</ol>
<h4 id="有些情况下，-Transactional-注解不能回滚事务的问题？"><a href="#有些情况下，-Transactional-注解不能回滚事务的问题？" class="headerlink" title="有些情况下，@Transactional 注解不能回滚事务的问题？"></a>有些情况下，@Transactional 注解不能回滚事务的问题？</h4><p>可能的一些原因：</p>
<ol>
<li>检查你的方法是不是 public 的</li>
<li>你的异常类型是不是 unchecked 异常<br>如果你的 check 异常也想回滚，那么在注解上面写明异常类型即可。<br><code>@Transactional(rollbackFor = Exception.class)</code></li>
<li>数据库引擎要支持事务，如果是 mysql， 注意表要使用支持事务的引擎，比如 innodb， 如果是 myisam，事务是不起作用的。</li>
<li>是否开启了注解的解析<br><code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; proxy-target-class=&quot;true&quot;/&gt;</code></li>
<li>spring 是否扫描到你的这个包，<br>如下是扫描到 <code>org.test</code> 下面的包<br><code>&lt;context:component-scan base-package=&quot;org.test&quot; &gt;&lt;/context:component-scan&gt;</code></li>
<li>检查是不是同一个类中的方法调用 </li>
<li>异常是不是被你 catch 住了</li>
</ol>
<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue父子组件传递数据</title>
    <url>/2020/09/04/Vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h4 id="prop-amp-event"><a href="#prop-amp-event" class="headerlink" title="prop &amp; event"></a>prop &amp; event</h4><p>父组件向子组件传递 props 数据，子组件通过触发事件向父组件回传数据</p>
<p>一个栗子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件 </span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click&#x3D;&quot;changeName(&#39;YYY&#39;)&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    props:[&#39;name&#39;],&#x2F;&#x2F;or props:&#123;name:&#123;type:String,default:&#39;&#39;&#125;&#125;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        &#x2F;&#x2F;不能在子组件修改props数据，应触发事件让父组件处理</span><br><span class="line">        changeName(newName)&#123;</span><br><span class="line">            this.$emit(&#39;changeName&#39;,newName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;child-comp :name&#x3D;&quot;name&quot; @changeName&#x3D;&quot;changeName&quot;&gt;&lt;&#x2F;child-comp&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import childComp from &#39;path&#39;</span><br><span class="line">    export default&#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;name:&#39;XXX&#39;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            childComp</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            changeName(newName)&#123;</span><br><span class="line">                this.name &#x3D; newName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;scritp&gt;</span><br></pre></td></tr></table></figure><br>父组件通过 props 将数据传递给子组件，子组件则触发事件，由父组件监听，并做相应处理。<br><span id="more"></span></p>
<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>ref 属性可定义在子组件或者原生 DOM 上，如果在子组件上，则指向子组件实例，如果在原生 DOM 上，则指向原生 DOM 元素。</p>
<p>传递数据的思路：在父组件内通过 ref 获取子组件实例，然后调用子组件方法，并传递相关数据作为参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件 </span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;parentMsg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            parentMsg:&#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        getMsg(msg)&#123;</span><br><span class="line">            this.parentMsg &#x3D; msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;child-comp ref&#x3D;&quot;child&quot;&gt;&lt;&#x2F;child-comp&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;sendMsg&quot;&gt;SEND MESSAGE&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import childComp from &#39;path&#39;</span><br><span class="line">    export default&#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            childComp</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            sendMsg()&#123;</span><br><span class="line">                this.$refs.child.getMsg(&#39;Parent Message&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;scritp&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket-how2j</title>
    <url>/2021/03/22/WebSocket-how2j/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>以前，当服务器端有个数据的更新，如果浏览器端需要获取更新后的数据，只能不停的刷新页面，或者使用Ajax技术每个一段时间向服务器轮询访问服务器数据。</p>
<p>现在，使用了WebSocket技术之后，当服务器有了新的数据，会主动通知浏览器。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol>
<li><p>节约宽带。</p>
<p>不停的轮询服务端数据这种方式，使用的是http协议，head信息很大，有效数据占比低，而使用WebSocket方式，头信息很小，有效数据占比高。</p>
</li>
<li><p>无浪费。</p>
<p>轮询方式有可能轮询10次，才碰到服务器的数据更新，那么前9次的轮询都白费了，因为没拿到变化的数据；而WebSocket是由服务器主动发送，来的都是新数据。</p>
</li>
<li><p>实时性。</p>
<p>考虑到服务器压力，使用的轮询方式不可能很短的时间间隔，否则服务器压力太大，所有轮询时间间隔都是比较长，设置十几秒。而WebSocket是由服务器主动推送过来，实时性是最高的。</p>
</li>
</ol>
<h4 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h4><h5 id="注解-ServerEndpoint-quot-path-quot-把它标记为一个WebSocket-Server"><a href="#注解-ServerEndpoint-quot-path-quot-把它标记为一个WebSocket-Server" class="headerlink" title="注解@ServerEndpoint(&quot;/path/..&quot;) 把它标记为一个WebSocket Server"></a>注解<code>@ServerEndpoint(&quot;/path/..&quot;)</code> 把它标记为一个WebSocket Server</h5><p><code>/path/..</code> 表示有通过这个地址访问该服务。</p>
<ul>
<li><code>OnOpen</code>表示有浏览器链接过来的时候被调用</li>
<li><code>OnClose</code>表示浏览器发出关闭请求的时候被调用</li>
<li><code>OnMessage</code>表示浏览器发消息的时候被调用</li>
<li><code>OnError</code>表示有错误发生，比如网络断开了等等</li>
<li><code>sendMessage</code>用于向浏览器回发信息</li>
</ul>
<p>其中OnOpen发生的时候，即有链接过来的时候，会把当前WebSocket Serve丢在ServerManager里管理起来，这样tomcat才知道总共有哪些Server，方便以后进行群发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.bitcoin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnError;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServerEndpoint</span> 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,</span></span><br><span class="line"><span class="comment"> * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/bitcoinServer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitCoinServer</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        ServerManager.add(<span class="keyword">this</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServerManager.remove(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自客户端的消息:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="struts注意事项"><a href="#struts注意事项" class="headerlink" title="struts注意事项"></a>struts注意事项</h4><p>因为Struts会把所有的请求都拦截下来，所以需要加一个例外：</p>
<p><code>&lt;constant name=&quot;struts.action.excludePattern&quot; value=&quot;/ws/bitcoinServer&quot; /&gt;</code></p>
<p>以保证WebSocket请求能够被正常捕捉住，不然就被Struts搞跑了。</p>
<h4 id="nginx注意事项"><a href="#nginx注意事项" class="headerlink" title="nginx注意事项"></a>nginx注意事项</h4><p>如果做了nginx和tomcat整合的话，那么nginx需要加上一段话，才能够正常的把WebSocket请求交给tomcat，不然tomcat也不知道怎么处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;ws&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:11180;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax传递数组形式的参数</title>
    <url>/2020/07/07/ajax%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h4 id="两种方案"><a href="#两种方案" class="headerlink" title="两种方案"></a>两种方案</h4><h5 id="加入traditional防止深度序列化"><a href="#加入traditional防止深度序列化" class="headerlink" title="加入traditional防止深度序列化"></a>加入<code>traditional</code>防止深度序列化</h5><p>前端代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&quot;*****&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        <span class="string">&quot;userid&quot;</span>:userid,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>:username,</span><br><span class="line">        <span class="string">&quot;school&quot;</span>:school</span><br><span class="line">    &#125;,</span><br><span class="line">    dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">    type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    traditional:<span class="literal">true</span>,<span class="comment">//防止深度序列化</span></span><br><span class="line">    cache:<span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">async</span>:<span class="literal">false</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>后端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requesMapping(value=&quot;/****&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@responseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForAjax</span><span class="params">(<span class="meta">@RequestParam(value=&quot;userid&quot;)</span> Integer[] userid, <span class="meta">@RequestParam(value=&quot;username&quot;)</span> String[] username, String school)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">      .....</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="指定参数类型"><a href="#指定参数类型" class="headerlink" title="指定参数类型"></a>指定参数类型</h5><p>前端代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&quot;*****&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        <span class="string">&quot;userid&quot;</span>:userid,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>:username,</span><br><span class="line">        <span class="string">&quot;school&quot;</span>:school</span><br><span class="line">    &#125;,</span><br><span class="line">    dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">    type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    cache:<span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">async</span>:<span class="literal">false</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>后端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requesMapping(value=&quot;/****&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@responseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForAjax</span><span class="params">(<span class="meta">@RequestParam(value=&quot;userid[]&quot;)</span> Integer[] userid, <span class="meta">@RequestParam(value=&quot;username[]&quot;)</span> String[] username, String school)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    .....</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>若前端传递的参数类型为数组的话，在后端(如java)进行接收的话， <strong>不能使用Map类型的参数来接受</strong>，否则只能接受到数组的第一个参数值。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ali-arthas</title>
    <url>/2020/08/18/ali-arthas/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>这是阿里的一个开源的 Java 诊断工具。</p>
<p>这个工具可以协助你做哪些事情：</p>
<ol>
<li>这个类是从哪个 jar 包加载进来的？</li>
<li>为什么会报各种类相关的 Exception ?</li>
<li>线上遇到问题无法 debug 好蛋疼，难道只能反复通过增加 System.out 或通过加日志再重新发布吗？</li>
<li>线上的代码为什么没有执行到这里？是由于代码没有提交？还是搞错了分支？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug ，线下无法重现？</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到 JVM 的实时运行状态？</li>
</ol>
<span id="more"></span>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ol>
<li><h5 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">help——查看命令帮助信息</span><br><span class="line">cls——清空当前屏幕区域</span><br><span class="line">session——查看当前会话的信息</span><br><span class="line">reset——重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类</span><br><span class="line">version——输出当前目标 Java 进程所加载的 Arthas 版本号</span><br><span class="line">quit——退出当前 Arthas 客户端，其他 Arthas 客户端不受影响</span><br><span class="line">shutdown——关闭 Arthas 服务端，所有 Arthas 客户端全部退出</span><br><span class="line">keymap——Arthas快捷键列表及自定义快捷键</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="jvm-相关"><a href="#jvm-相关" class="headerlink" title="jvm 相关"></a>jvm 相关</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dashboard——当前系统的实时数据面板</span><br><span class="line">thread——查看当前 JVM 的线程堆栈信息</span><br><span class="line">jvm——查看当前 JVM 的信息</span><br><span class="line">sysprop——查看和修改JVM的系统属性</span><br><span class="line">New! getstatic——查看类的静态属性</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="class-classloader-相关"><a href="#class-classloader-相关" class="headerlink" title="class/classloader 相关"></a>class/classloader 相关</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sc——查看JVM已加载的类信息</span><br><span class="line">sm——查看已加载类的方法信息</span><br><span class="line">dump——dump 已加载类的 byte code 到特定目录</span><br><span class="line">redefine——加载外部的.class文件，redefine到JVM里</span><br><span class="line">jad——反编译指定已加载类的源码</span><br><span class="line">classloader——查看classloader的继承树，urls，类加载信息，使用classloader去getResource</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="monitor-watch-trace-相关"><a href="#monitor-watch-trace-相关" class="headerlink" title="monitor/watch/trace 相关"></a>monitor/watch/trace 相关</h5><blockquote>
<p>请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 shutdown 或将增强过的类执行 reset 命令。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">monitor——方法执行监控</span><br><span class="line">watch——方法执行数据观测</span><br><span class="line">trace——方法内部调用路径，并输出方法路径上的每个节点上耗时</span><br><span class="line">stack——输出当前方法被调用的调用路径</span><br><span class="line">tt——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="options"><a href="#options" class="headerlink" title="options"></a>options</h5><p><code>options——查看或设置Arthas全局开关</code></p>
</li>
<li><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><blockquote>
<p>Arthas支持使用管道对上述命令的结果进行进一步的处理，如sm org.apache.log4j.Logger | grep</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">grep——搜索满足条件的结果</span><br><span class="line">plaintext——将命令的结果去除颜色</span><br><span class="line">wc——按行统计输出结果</span><br></pre></td></tr></table></figure>
</li>
<li><p>Web Console</p>
<p>通过 websocket 来连接 Arthas 。</p>
<blockquote>
<p><strong>Arthas</strong> 目前支持 <code>Web Console</code>，在成功启动连接进程之后就已经自动启动，可以直接访问 <a href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p>
</blockquote>
</li>
</ol>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h5><p>使用 shutdown 退出时，<strong>Arthas</strong> 会同时自动重置所有增加过的类。</p>
<h5 id="在-windows-下操作-as-sh-命令"><a href="#在-windows-下操作-as-sh-命令" class="headerlink" title="在 windows 下操作 as.sh 命令"></a>在 windows 下操作 <code>as.sh</code> 命令</h5><p><em>Please start cmd.exe from Windows start menu, and then run telnet 127.0.0.1 3658 to connect to target process.</em></p>
<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><h5 id="全局监控"><a href="#全局监控" class="headerlink" title="全局监控"></a>全局监控</h5><p>使用 <strong>dashboard</strong> 命令可以概览程序的线程、内存、GC 、运行环境信息。</p>
<h5 id="CPU-为什么起飞了"><a href="#CPU-为什么起飞了" class="headerlink" title="CPU 为什么起飞了"></a>CPU 为什么起飞了</h5><p>使用 <strong>thread</strong> 查看所有线程信息，同时会列出每个线程的 <code>CPU</code> 使用率，如下图：</p>
<p><img src="http://wrr123.github.io/2020/08/18/ali-arthas/001.png" alt></p>
<p><strong>使用命令 thread -n [显示的线程个数]，就可以排列出 CPU 使用率 TOP n 的线程。</strong></p>
<h5 id="线程池线程状态"><a href="#线程池线程状态" class="headerlink" title="线程池线程状态"></a>线程池线程状态</h5><ul>
<li><strong>runnable</strong> 运行中</li>
<li><strong>timed_waiting</strong> 调用了下面的方法，线程会进入 <strong>time_waiting：</strong><ol>
<li>Thread#sleep()</li>
<li>Object#wait() 并加了超时参数</li>
<li>Thread#join() 并加了超时参数</li>
<li>LockSupport#parkNanos()</li>
<li>LockSupport#parkUntil()</li>
</ol>
</li>
<li><strong>waiting</strong> 当线程调用了以下方法，会进入 <strong>waiting：</strong><ul>
<li>Object#wait() 但是不加超时参数</li>
<li>Thread#join() 但是不加超时参数</li>
<li>LockSupport#park()</li>
</ul>
</li>
<li><strong>blocked</strong> 阻塞，等待锁</li>
</ul>
<h5 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h5><p>使用 <code>thread -b</code> 命令查看直接定位到死锁信息。</p>
<h5 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h5><p>使用 <strong>jad</strong> 命令直接反编译 class。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反编译只显示源码</span></span><br><span class="line">jad --source-only com.Arthas</span><br><span class="line"><span class="comment"># 反编译某个类的某个方法</span></span><br><span class="line">jad --source-only com.Arthas mysql</span><br></pre></td></tr></table></figure>
<h5 id="查看字段信息"><a href="#查看字段信息" class="headerlink" title="查看字段信息"></a>查看字段信息</h5><p>使用 <strong>sc -d -f</strong> 命令查看类的字段信息。</p>
<h5 id="查看方法信息"><a href="#查看方法信息" class="headerlink" title="查看方法信息"></a>查看方法信息</h5><p>使用 <strong>sm</strong> 命令查看类的方法信息。</p>
<h5 id="对变量的值很是好奇"><a href="#对变量的值很是好奇" class="headerlink" title="对变量的值很是好奇"></a>对变量的值很是好奇</h5><p>使用 <strong>ognl</strong> 命令，ognl 表达式可以轻松操作想要的信息。</p>
<h5 id="程序有没有问题"><a href="#程序有没有问题" class="headerlink" title="程序有没有问题"></a>程序有没有问题</h5><h6 id="运行较慢、耗时较长"><a href="#运行较慢、耗时较长" class="headerlink" title="运行较慢、耗时较长"></a>运行较慢、耗时较长</h6><p>使用 <strong>trace</strong> 命令可以跟踪、统计方法耗时。</p>
<h6 id="统计方法耗时"><a href="#统计方法耗时" class="headerlink" title="统计方法耗时"></a>统计方法耗时</h6><p>使用 <strong>monitor</strong> 命令监控统计方法的执行情况。</p>
<p>一个栗子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 每 5 秒统计一次 `com.UserServiceImpl` 类的 `get` 方法执行情况</span><br><span class="line">monitor -c 5 com.UserServiceImpl get</span><br></pre></td></tr></table></figure>
<h5 id="想观察方法信息"><a href="#想观察方法信息" class="headerlink" title="想观察方法信息"></a>想观察方法信息</h5><h6 id="观察方法的入参出参信息"><a href="#观察方法的入参出参信息" class="headerlink" title="观察方法的入参出参信息"></a>观察方法的入参出参信息</h6><p>使用 <strong>watch</strong> 命令轻松查看输入输出参数以及异常等信息。</p>
<p>常见操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看入参和出参</span></span><br><span class="line">$ watch com.Arthas addHashSet <span class="string">&#x27;&#123;params[0],returnObj&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 查看入参和出参大小</span></span><br><span class="line">$ watch com.Arthas addHashSet <span class="string">&#x27;&#123;params[0],returnObj.size&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 查看入参和出参中是否包含 &#x27;count10&#x27;</span></span><br><span class="line">$ watch com.Arthas addHashSet <span class="string">&#x27;&#123;params[0],returnObj.contains(&quot;count10&quot;)&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 查看入参和出参，出参 toString</span></span><br><span class="line">$ watch com.Arthas addHashSet <span class="string">&#x27;&#123;params[0],returnObj.toString()&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h6 id="观察方法的调用路径"><a href="#观察方法的调用路径" class="headerlink" title="观察方法的调用路径"></a>观察方法的调用路径</h6><p>使用 <strong>stack</strong> 命令查看方法的调用参数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 观察 类com.UserServiceImpl的 mysql 方法调用路径</span></span><br><span class="line">stack com.UserServiceImpl mysql</span><br></pre></td></tr></table></figure>
<h5 id="方法调用时空隧道"><a href="#方法调用时空隧道" class="headerlink" title="方法调用时空隧道"></a>方法调用时空隧道</h5><p>使用 <strong>tt</strong> 命令记录方法执行的详细情况</p>
<blockquote>
<p><strong>tt</strong> 命令方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测 。</p>
</blockquote>
<p>常用操作：</p>
<p>开始记录方法的调用信息：<code>tt -t com.UserServiceImpl check</code></p>
<p>查看记录的方法调用信息：<code>tt -l</code></p>
<p>查看调用记录的详细信息（-i 指定 INDEX）：<code>tt -i 1001</code></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>ali</tag>
      </tags>
  </entry>
  <entry>
    <title>alibaba-sentinel</title>
    <url>/2021/03/29/alibaba-sentinel/</url>
    <content><![CDATA[<h4 id="前置问题：java运行jar包时，指定启动端口？"><a href="#前置问题：java运行jar包时，指定启动端口？" class="headerlink" title="前置问题：java运行jar包时，指定启动端口？"></a>前置问题：java运行jar包时，指定启动端口？</h4><p>在最后面加上<code>--server.port</code></p>
<p>一个栗子：</p>
<p><code>java -jar xxx.jar --server.port=9090</code></p>
<span id="more"></span>
<h4 id="部署Sentinel-Dashboard"><a href="#部署Sentinel-Dashboard" class="headerlink" title="部署Sentinel Dashboard"></a>部署Sentinel Dashboard</h4><h5 id="通过命令行启动"><a href="#通过命令行启动" class="headerlink" title="通过命令行启动"></a>通过命令行启动</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.6.0.jar</span><br></pre></td></tr></table></figure>
<p>它的默认用户名和密码都是<code>sentinel</code>.</p>
<p>你也可以在启动命令中增加下面的参数进行配置：</p>
<ul>
<li><p><code>-Dsentinel.dashboard.auth.username=sentinel</code> 用于指定控制台的登录名</p>
</li>
<li><p><code>-Dsentinel.dashboard.auth.password=123456</code> 用于指定控制台的登陆密码</p>
<p>如果省略了上面的两个参数，则默认用户名和密码都为<code>sentinel</code>。</p>
</li>
<li><p><code>-Dserver.servlet.session.timeout=7200</code> 用于指定Spring Boot服务端session的过期时间，如7200表示7200秒，60m表示60分钟，默认为30分钟。</p>
</li>
</ul>
<h5 id="整合Sentinel"><a href="#整合Sentinel" class="headerlink" title="整合Sentinel"></a>整合Sentinel</h5><ol>
<li><p>在pom.xml文件中引入Spring Cloud Alibaba的Sentinel模块</p>
</li>
<li><p>在Spring Cloud应用中通过<code>spring.cloud.sentinel.transport.dashboard</code>参数配置sentinel dashboard的访问地址</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-sentinel-rate-limiting</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel dashboard</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.transport.dashboard</span>=<span class="string">localhost:8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建应用主类，并提供一个rest接口</p>
</li>
<li><p>启动应用，可通过postman或curl访问几下rest接口。</p>
</li>
</ol>
<h4 id="配置限流规则"><a href="#配置限流规则" class="headerlink" title="配置限流规则"></a>配置限流规则</h4><p><img src="http://wrr123.github.io/2021/03/29/alibaba-sentinel/001.png" alt></p>
<p>在Sentinel的某个服务下，点击<code>镞点链路</code>菜单，然后在右边界面，点击对应接口的<code>流控</code>按钮，弹出下面的界面：</p>
<p><img src="http://wrr123.github.io/2021/03/29/alibaba-sentinel/002.png" alt></p>
<p>配置完成，点击新增即可。</p>
<h5 id="验证限流规则"><a href="#验证限流规则" class="headerlink" title="验证限流规则"></a>验证限流规则</h5><p>你可以多访问几次，看看会不会被限流。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>axios与ajax比较</title>
    <url>/2020/09/05/axios%E4%B8%8Eajax%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h4 id="什么叫-axios"><a href="#什么叫-axios" class="headerlink" title="什么叫 axios"></a>什么叫 axios</h4><p>Axios 是一个基于 promise 的 HTTP库，可以用在浏览器和 node.js 中。</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>从浏览器中创建 <code>XMLHttpRequests</code></li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<span id="more"></span>
]]></content>
      <tags>
        <tag>vuejs</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap-select基本使用</title>
    <url>/2020/08/10/bootstrap-select%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h4><ul>
<li>Clone the repo: <code>git clone https://github.com/snapappointments/bootstrap-select.git</code></li>
<li>Install with npm: <code>npm install bootstrap-select</code></li>
<li>……</li>
</ul>
<span id="more"></span>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="通过-selectpicker-class"><a href="#通过-selectpicker-class" class="headerlink" title="通过 selectpicker class"></a>通过 <code>selectpicker</code> class</h5><p>添加 <code>selectpicker</code> class 到你的 select 元素中，将会自动初始化 bootstrap-select 。</p>
<p>一个栗子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;selectpicker&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Mustard<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Ketchup<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>Barbecue<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="通过-JavaScript"><a href="#通过-JavaScript" class="headerlink" title="通过 JavaScript"></a>通过 JavaScript</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// To style only selects width the my-select class</span></span><br><span class="line">$(<span class="string">&#x27;.my-select&#x27;</span>).selectpicker()</span><br><span class="line"></span><br><span class="line"><span class="comment">// To style all selects</span></span><br><span class="line">$(<span class="string">&#x27;select&#x27;</span>).selectpicker()</span><br></pre></td></tr></table></figure>
<p><strong>如果通过 JavaScript 来加载 bootstrap ，你的代码需要放在 <code>.ready()</code> 代码块中或者放在 js 文件的最底部。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;select&#x27;</span>).selectpicker()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome控制台的一些警告</title>
    <url>/2020/08/06/chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<h4 id="DevTools-failed-to-load-SourceMap-could-not-load-content-for-bootstrap-min-css-map-404-……"><a href="#DevTools-failed-to-load-SourceMap-could-not-load-content-for-bootstrap-min-css-map-404-……" class="headerlink" title="DevTools failed to load SourceMap: could not load content for bootstrap.min.css.map 404 ……"></a>DevTools failed to load SourceMap: could not load content for bootstrap.min.css.map 404 ……</h4><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li><p>使用官网的css文件</p>
</li>
<li><p>从官网下载<code>bootstrap.min.css.map</code>文件放到本地服务器上</p>
</li>
<li><p>修改chrome浏览器的设置</p>
<p><img src="http://wrr123.github.io/2020/08/06/chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AD%A6%E5%91%8A/001.png" alt></p>
</li>
</ol>
<h4 id="Synchronous-XMLHttpRequest-on-the-main-thread-is-deprecated-because-of-its-detrimental-effects-to-the-end-user’s-experience"><a href="#Synchronous-XMLHttpRequest-on-the-main-thread-is-deprecated-because-of-its-detrimental-effects-to-the-end-user’s-experience" class="headerlink" title="Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user’s experience"></a>Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user’s experience</h4><h5 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h5><p>chrome认为ajax在主线程中应该都是异步的，才没有不利的影响。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>css</title>
    <url>/2020/08/05/css/</url>
    <content><![CDATA[<h4 id="css中的单位"><a href="#css中的单位" class="headerlink" title="css中的单位"></a>css中的单位</h4><h5 id="视口单位-Viewport-units"><a href="#视口单位-Viewport-units" class="headerlink" title="视口单位(Viewport units)"></a>视口单位(Viewport units)</h5><ul>
<li>vw</li>
<li>vh</li>
</ul>
<h5 id="什么是视口"><a href="#什么是视口" class="headerlink" title="什么是视口"></a>什么是视口</h5><blockquote>
<p>Peter-Paul Koch（”PPK大神”）提出视口的解释是：在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。</p>
</blockquote>
<h5 id="vw-vh和-的区别"><a href="#vw-vh和-的区别" class="headerlink" title="vw/vh和%的区别"></a>vw/vh和%的区别</h5><div class="table-container">
<table>
<thead>
<tr>
<th>单位</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>vw</td>
<td>1vw=视口宽度的1%</td>
</tr>
<tr>
<td>vh</td>
<td>1vh=视口高度的1%</td>
</tr>
<tr>
<td>vmin</td>
<td>选取vw和vh中最小的那个</td>
</tr>
<tr>
<td>vmax</td>
<td>选取vw和vh中最大的那个</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>单位</th>
<th>依赖于</th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>祖先元素</td>
</tr>
<tr>
<td>vh/vw</td>
<td>视口的尺寸</td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h4 id="css-渐变"><a href="#css-渐变" class="headerlink" title="css 渐变"></a>css 渐变</h4><h5 id="css-线性渐变"><a href="#css-线性渐变" class="headerlink" title="css 线性渐变"></a>css 线性渐变</h5><p>基本语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure>
<h6 id="从上到下（默认情况下）"><a href="#从上到下（默认情况下）" class="headerlink" title="从上到下（默认情况下）"></a>从上到下（默认情况下）</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">#e66465</span>, <span class="number">#9198e5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="从左到右"><a href="#从左到右" class="headerlink" title="从左到右"></a>从左到右</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, red , yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="对角-从左上角到右下角的线性渐变"><a href="#对角-从左上角到右下角的线性渐变" class="headerlink" title="对角(从左上角到右下角的线性渐变)"></a>对角(从左上角到右下角的线性渐变)</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom right, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用角度"><a href="#使用角度" class="headerlink" title="使用角度"></a>使用角度</h6><p><strong>语法</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(angle, color-stop1, color-stop2);</span><br></pre></td></tr></table></figure>
<p>一个栗子</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(-<span class="number">90deg</span>, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用多个颜色节点"><a href="#使用多个颜色节点" class="headerlink" title="使用多个颜色节点"></a>使用多个颜色节点</h6><p>一个栗子</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(red, yellow, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用透明度-transparent"><a href="#使用透明度-transparent" class="headerlink" title="使用透明度( transparent )"></a>使用透明度( transparent )</h6><p>一个栗子：从左到右的线性渐变，带有透明度</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="重复的线性渐变"><a href="#重复的线性渐变" class="headerlink" title="重复的线性渐变"></a>重复的线性渐变</h6><p>一个栗子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="comment">/* 标准的语法 */</span></span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(red, yellow <span class="number">10%</span>, green <span class="number">20%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="css3-径向渐变"><a href="#css3-径向渐变" class="headerlink" title="css3 径向渐变"></a>css3 径向渐变</h5><blockquote>
<p>径向渐变由它的中心定义。</p>
<p>为了创建一个径向渐变，你也必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p>
</blockquote>
<p>一个图片栗子：</p>
<p><img src="http://wrr123.github.io/2020/08/05/css/001.png" alt></p>
<p><strong>语法</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(shape size at position, start-color, ..., last-color);</span><br></pre></td></tr></table></figure>
<p>一个栗子：颜色节点均匀分布的径向渐变：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(red, yellow, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个栗子：颜色节点不均匀分布的径向渐变：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(red <span class="number">5%</span>, yellow <span class="number">15%</span>, green <span class="number">60%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="设置形状"><a href="#设置形状" class="headerlink" title="设置形状"></a>设置形状</h6><blockquote>
<p>shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。</p>
</blockquote>
<p>一个栗子：形状为圆形的径向渐变</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle, red, yellow, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="不同尺寸大小关键字的使用"><a href="#不同尺寸大小关键字的使用" class="headerlink" title="不同尺寸大小关键字的使用"></a>不同尺寸大小关键字的使用</h6><blockquote>
<p>size 参数定义了渐变的大小。它可以是以下四个值：</p>
<ul>
<li><strong>closest-side</strong></li>
<li><strong>farthest-side</strong></li>
<li><strong>closest-corner</strong></li>
<li><strong>farthest-corner</strong></li>
</ul>
</blockquote>
<p>一个栗子：带有不同尺寸大小关键字的径向渐变</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad1</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(closest-side at <span class="number">60%</span> <span class="number">55%</span>, red, yellow, black);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-id">#grad2</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(farthest-side at <span class="number">60%</span> <span class="number">55%</span>, red, yellow, black);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="重复的径向渐变"><a href="#重复的径向渐变" class="headerlink" title="重复的径向渐变"></a>重复的径向渐变</h6><blockquote>
<p>repeating-radial-gradient() 函数用于重复径向渐变：</p>
</blockquote>
<p>一个栗子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">repeating-radial-gradient</span>(red, yellow <span class="number">10%</span>, green <span class="number">15%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="css强制不换行，文字溢出显示省略号"><a href="#css强制不换行，文字溢出显示省略号" class="headerlink" title="css强制不换行，文字溢出显示省略号"></a>css强制不换行，文字溢出显示省略号</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;	</span><br><span class="line">    <span class="comment">/** 最好加上宽度 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="comment">/** 文本强制不换行 */</span></span><br><span class="line">	<span class="attribute">white-space</span>: nowrap;</span><br><span class="line">	<span class="comment">/** 文本溢出显示省略号 */</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="comment">/** 溢出的部分隐藏 */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="延申："><a href="#延申：" class="headerlink" title="延申："></a>延申：</h5><p>强制不换行：</p>
<p><code>p &#123; white-space: nowrap; &#125;</code></p>
<p>自动换行：</p>
<p><code>p &#123; word-wrap: break-word; &#125;</code></p>
<p>强制英文单词断行：</p>
<p><code>p &#123; word-break: break-all; &#125;</code></p>
<p><strong>设置强制将英文单词断行，需要将行内元素设置为块级元素。</strong></p>
<p>超出显示省略号：</p>
<p><code>p &#123; text-overflow: ellipsis; overflow: hidden; &#125;</code></p>
<h6 id="white-sapce-normal-pre-nowrap-pre-line-inherit"><a href="#white-sapce-normal-pre-nowrap-pre-line-inherit" class="headerlink" title="white-sapce: normal|pre|nowrap|pre-line|inherit;"></a>white-sapce: normal|pre|nowrap|pre-line|inherit;</h6><blockquote>
<ul>
<li><strong>white-space</strong>: 属性设置如何处理元素内的空白</li>
<li><strong>normal</strong>: 默认。空白会被浏览器忽略。</li>
<li><strong>pre</strong>: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。</li>
<li><strong>nowrap</strong>: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。</li>
<li><strong>pre-wrap</strong>: 保留空白符序列，但是正常地进行换行。</li>
<li><strong>pre-line</strong>: 合并空白符序列，但是保留换行符。</li>
<li><strong>inherit</strong>: 规定应该从父元素继承 white-space 属性的值。</li>
</ul>
</blockquote>
<h6 id="word-wrap-normal-break-word"><a href="#word-wrap-normal-break-word" class="headerlink" title="word-wrap: normal|break-word;"></a>word-wrap: normal|break-word;</h6><blockquote>
<ul>
<li><strong>word-wrap</strong>: 属性用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。</li>
<li><strong>normal</strong>: 只在允许的断字点换行(浏览器保持默认处理)</li>
<li><strong>break-word</strong>: 在长单词或URL地址内部进行换行</li>
</ul>
</blockquote>
<h6 id="word-break-normal-break-all-keep-all"><a href="#word-break-normal-break-all-keep-all" class="headerlink" title="word-break: normal|break-all|keep-all;"></a>word-break: normal|break-all|keep-all;</h6><blockquote>
<ul>
<li>word-break 属性用来标明怎么样进行单词内的断句。</li>
<li>normal：使用浏览器默认的换行规则。</li>
<li>break-all:允许再单词内换行</li>
<li>keep-all:只能在半角空格或连字符处换行</li>
</ul>
</blockquote>
<p>一个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.word</span>&#123;<span class="attribute">background</span>:<span class="number">#E4FFE9</span>;<span class="attribute">width</span>:<span class="number">250px</span>;<span class="attribute">margin</span>:<span class="number">50px</span> auto;<span class="attribute">padding</span>:<span class="number">20px</span>;<span class="attribute">font-family</span>:<span class="string">&quot;microsoft yahei&quot;</span>;&#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 强制不换行 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.nowrap</span>&#123;<span class="attribute">white-space</span>:nowrap;&#125;</span></span><br><span class="line">    /* 允许单词内断句，首先会尝试挪到下一行，看看下一行的宽度够不够，</span><br><span class="line">    不够的话就进行单词内的断句 */</span><br><span class="line"><span class="css">    <span class="selector-class">.breakword</span>&#123;<span class="attribute">word-wrap</span>: break-word;&#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 断句时，不会把长单词挪到下一行，而是直接进行单词内的断句 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.breakAll</span>&#123;<span class="attribute">word-break</span>:break-all;&#125;            </span></span><br><span class="line"><span class="css">    <span class="comment">/* 超出部分显示省略号 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.ellipsis</span>&#123;<span class="attribute">text-overflow</span>:ellipsis;<span class="attribute">overflow</span>:hidden;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&quot;word&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span> = <span class="string">&quot;nowrap&quot;</span>&gt;</span>wordwrap:breakword;absavhsafhuafdfbjhfvsalguvfaihuivfs<span class="tag">&lt;/<span class="name">p</span>&gt;</span>          </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span> = <span class="string">&quot;breakword&quot;</span>&gt;</span>wordwrap:break-word;absavhsafhuafdfbjhfvsalguvfaihui<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span> = <span class="string">&quot;breakAll&quot;</span>&gt;</span>wordwrap:break-word;absavhsafhuafdfbjhfvsalguvfaihuivf<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span> = <span class="string">&quot;normal&quot;</span>&gt;</span>wordwrap:breakword;absavhsafhuafdfbjhfvsalguvfaihuivfsa<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span> = <span class="string">&quot;ellipsis&quot;</span>&gt;</span>wordwrap:breakword;absavhsafhuafdfbjhfvsalguvfaihuivfsab<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="SCSS基础"><a href="#SCSS基础" class="headerlink" title="SCSS基础"></a>SCSS基础</h4><p><code>Sass</code> 是成熟、稳定、强大的 <strong>CSS 预处理器</strong>，而 SCSS 是 Sass3 版本中引入的新语法特性，完全兼容 CSS3 的同时继承了 Sass 强大的动态功能。</p>
<h5 id="特性概览"><a href="#特性概览" class="headerlink" title="特性概览"></a>特性概览</h5><p>CSS 书写代码规模较大的 Web 应用时，容易造成选择器、层叠的复杂度多高，因此推荐 SASS 预处理器进行 CSS 的开发，SASS 提供的变量、嵌套、混合、继承等特性，让 CSS 的书写更加有趣与程式化。</p>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>变量用来存储需要在 CSS 中复用的信息，例如颜色和字体等。</p>
<p>SASS 通过 <code>$</code> 符号去声明一个变量。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font--stack</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h5><p>SASS 允许开发人员以嵌套的方式使用 CSS，但是多度的使用嵌套会让产生的 CSS 难以维护，因此是一种不好的实践。</p>
<p>一个栗子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: inline-block; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>SASS 能够将代码分割为多个片段，并以 underscore 风格的下划线作为其命名前缀( _partial.scss)，SASS 会通过这些下划线来辨别哪些文件是 SASS 片段，并且不让片段内容直接生成为 CSS 文件，从而只是在使用 <code>@import</code> 指令的位置被导入。</p>
<blockquote>
<p>CSS原生的@import会通过额外的HTTP请求获取引入的样式片段，而SASS的@import则会直接将这些引入的片段合并至当前CSS文件，并且不会产生新的HTTP请求。下面例子中的代码，将会在base.scss文件当中引入_reset.scss片断。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _reset.scss</span></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>:  <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base.scss</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;reset&#x27;</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h5><blockquote>
<p>混合（Mixin）用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-radius(<span class="variable">$radius</span>) &#123;</span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">      -ms-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">     -moz-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> border-radius(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><blockquote>
<p>继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码，下面例子将会通过SASS提供的继承机制建立一系列样式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。</span></span><br><span class="line">%other-styles &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。</span></span><br><span class="line">%message-common &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.message</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>SASS提供了标准的算术运算符，例如+、-、*、/、%。在接下来的例子里，我们尝试在aside和article选择器当中对宽度进行简单的计算。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[role=<span class="string">&quot;main&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span><span class="selector-attr">[role=<span class="string">&quot;complementary&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CSS-扩展"><a href="#CSS-扩展" class="headerlink" title="CSS 扩展"></a>CSS 扩展</h5><h6 id="引用父级选择器-amp"><a href="#引用父级选择器-amp" class="headerlink" title="引用父级选择器 &amp;"></a>引用父级选择器 <code>&amp;</code></h6><p>SCSS 使用 <code>&amp;</code> 关键字在 CSS 规则中引用父级选择器，</p>
<p>一个栗子：在嵌套使用伪例选择器的场景下</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*===== SCSS =====*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>: underline; &#125;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-class">.firefox</span> &amp; &#123; <span class="attribute">font-weight</span>: normal; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===== CSS =====*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none; &#125;</span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline; &#125;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-class">.firefox</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal; &#125;</span><br></pre></td></tr></table></figure>
<p>无论 CSS 规则嵌套的深度怎样，关键字 <code>&amp;</code> 都会使用父级选择器 <strong>级联替换</strong> 全部其出现的位置：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*===== SCSS =====*/</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===== CSS =====*/</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black; &#125;</span><br><span class="line">  <span class="selector-id">#main</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold; &#125;</span><br><span class="line">    <span class="selector-id">#main</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure>
<p><code>&amp;</code> 必须出现在复合选择器开头的位置，后面再连接自定义的后缀，</p>
<p>一个栗子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*===== SCSS =====*/</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  &amp;-sidebar &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===== CSS =====*/</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black; &#125;</span><br><span class="line">  <span class="selector-id">#main-sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果在父级选择器不存在的场景使用 <code>&amp;</code>，SCSS 预处理器会报出错误信息。</strong></p>
<h5 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h5><p>CSS 许多属性都位于相同的命名空间(例如 font-family、font-size、font-weight 都位于 font 命名空间下)，SCSS 当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间下。</p>
<p>一个栗子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*===== SCSS =====*/</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="comment">// 命令空间后带有冒号:</span></span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: fantasy;</span><br><span class="line">    size: <span class="number">30em</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===== CSS =====*/</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: fantasy;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令空间上可以直接书写CSS简写属性，但是日常开发中不建议直接书写CSS简写属性，尽量保持CSS语法的一致性。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">20px</span>/<span class="number">24px</span> fantasy &#123;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">20px</span>/<span class="number">24px</span> fantasy;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css四个定位之间的区别</title>
    <url>/2020/09/15/css%E5%9B%9B%E4%B8%AA%E5%AE%9A%E4%BD%8D%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="CSS-的四个定位"><a href="#CSS-的四个定位" class="headerlink" title="CSS 的四个定位"></a>CSS 的四个定位</h4><ul>
<li><p>static</p>
<p>  静态定位。没有定位，元素出现在正常的流中。(忽略 top、bottom、left、right 或者 z-index 声明)</p>
</li>
<li><p>relative</p>
<p>  相对定位。</p>
<p>  生成相对定位的元素，通过 top、bottom、left、right 的设置相对其 <strong>正常（原先本身）</strong> 位置进行定位。可通过 z-index 进行层次分级。</p>
</li>
<li><p>absolute</p>
<p>  绝对定位。生成绝对定位的元素，相对于 static 定位以外的第一个 <strong>父元素</strong> 进行定位。</p>
</li>
<li><p>fixed</p>
<p>  固定定位。生成绝对定位的元素，相对于 <strong>浏览器窗口</strong> 进行定位。</p>
</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>relative</p>
<p> 定位为 relative 的元素，脱离正常的文本流中，但其在 <strong>文本流中的位置依然存在。</strong></p>
</li>
</ol>
<span id="more"></span>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>data3c项目-2</title>
    <url>/2020/06/30/data3c%E9%A1%B9%E7%9B%AE-2/</url>
    <content><![CDATA[<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol>
<li><p>在lombok中, 注解@RequiredArgsConstructor的基本使用？</p>
<p><img src="http://wrr123.github.io/2020/06/30/data3c%E9%A1%B9%E7%9B%AE-2/XxxConstructor注解.png" alt="注解"></p>
</li>
<li><p>windows下，plsql的oracle数据库中文注释等显示乱码？</p>
<p>一般只要设置环境变量<code>NLS_LANG = SIMPLIFIED CHINESE_CHINA.ZHS16GBK</code>即可。</p>
</li>
<li></li>
</ol>
<h4 id="data3c的项目分析"><a href="#data3c的项目分析" class="headerlink" title="data3c的项目分析"></a>data3c的项目分析</h4><h5 id="项目分类"><a href="#项目分类" class="headerlink" title="项目分类"></a>项目分类</h5><ul>
<li>供应链<ul>
<li>WEB界面</li>
<li>上传模块</li>
<li>提交计算模块</li>
<li>Imformatic计算</li>
</ul>
</li>
<li>月结<ul>
<li>WEB界面</li>
<li>提交计算模块</li>
<li>Informatic计算</li>
</ul>
</li>
<li>科诺斯<ul>
<li>WEB界面</li>
<li>上传模块</li>
<li>提交计算模块</li>
<li>Imformatic计算</li>
</ul>
</li>
</ul>
<h5 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h5><ul>
<li>java<ul>
<li>Fastjoin</li>
<li>Liquibase</li>
<li>Hutool</li>
</ul>
</li>
<li>工具<ul>
<li>Findbugs</li>
</ul>
</li>
<li>数据存储<ul>
<li>文件存储(file server)</li>
</ul>
</li>
<li>应用服务器<ul>
<li>Nginx</li>
</ul>
</li>
</ul>
<h5 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h5><p>web界面：用户数据上传下载、用户管理模块的界面展示</p>
<p>App Server(data-input)：数据上传下载、用户管理模块的后台服务</p>
<p>App Server(data-imformatica)：在Java中调用命令行，使用<code>imformatica sh</code>脚本，来触发imformatica计算</p>
]]></content>
      <categories>
        <category>compony</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>data3c项目</title>
    <url>/2020/06/28/data3c%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h5 id="npm镜像推荐和使用"><a href="#npm镜像推荐和使用" class="headerlink" title="npm镜像推荐和使用"></a>npm镜像推荐和使用</h5><p>镜像推荐<br>淘宝镜像： </p>
<ul>
<li>搜索地址 <a href="http://npm.taobao.org/">http://npm.taobao.org/</a></li>
<li>registry地址 <a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org/</a></li>
</ul>
<p>使用:</p>
<ul>
<li>临时使用 <code>npm --registry https://registry.npm.taobao.org install express</code></li>
<li>永久使用<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">// 配置后可通过下面方式来验证是否成功</span><br><span class="line">npm config get registry</span><br><span class="line">// 或</span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure></li>
<li>使用<code>cnpm</code>命令<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">// 使用</span><br><span class="line">cnpm install expresstall express</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="vue的计算属性和观察属性"><a href="#vue的计算属性和观察属性" class="headerlink" title="vue的计算属性和观察属性"></a>vue的计算属性和观察属性</h5><p>计算属性是自动监听依赖值的变化，从而动态返回内容；<br>监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。</p>
<p>计算属性由两部分组成：get和set，分别用来获取计算属性和设置计算属性。<br>默认只有get，如果需要set，要自己添加。<br>set设置属性，并不是直接修改计算属性，而是修改它的依赖。</p>
<p>计算属性和普通属性的区别？<br>可以像绑定普通属性一样在模板中绑定计算属性，<br>在定义上存在区别： 计算属性的属性值必须是一个函数。</p>
<p>计算属性VS方法<br>computed是可以缓存的，methods不可以缓存<br><strong>只要相关的依赖没有改变，多次访问计算属性得到的值就是之前缓存的计算结果，不会多次执行</strong></p>
<p>侦听属性（观察属性）<code>watch</code><br>watch中可以执行任何逻辑，如函数节流、Ajax异步获取数据、甚至操作DOM(<strong>不建议</strong>)</p>
<h5 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h5><ul>
<li>注解<code>@Cleanup</code><br>使用在局部变量上面。<br>在需要关闭流对象时，帮助你自动关闭。</li>
</ul>
<h5 id="java-try-with-resources-语法糖"><a href="#java-try-with-resources-语法糖" class="headerlink" title="java try-with-resources 语法糖"></a>java try-with-resources 语法糖</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">try(声明并初始化需要关闭资源的变量，多个的话使用分号`;`分隔) &#123;</span><br><span class="line">&#125;catch(e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java 获取项目中文件的输入流<br>获取到<code>this.getClass().getClassLoader().getResourceStream(&quot;文件的类路径&quot;);</code><br>or<br>使用springboot下的<code>ResourceUtils.getFile(&quot;classpath:类路径&quot;)</code></p>
<p>java 文件下载到浏览器端<br>前端调用： <code>window.open(url)</code>, 使用ajax的话，下载不了。<br>后端下载： HttpServletResponse的输出流</p>
<h5 id="springboot-多数据源实现"><a href="#springboot-多数据源实现" class="headerlink" title="springboot 多数据源实现"></a>springboot 多数据源实现</h5><p>在application.yml中添加其他数据源的配置信息，<br>在config中初始化每个数据源，</p>
<h5 id="oracle-用户对表空间’XXXX’无权限"><a href="#oracle-用户对表空间’XXXX’无权限" class="headerlink" title="oracle,用户对表空间’XXXX’无权限"></a>oracle,用户对表空间’XXXX’无权限</h5><p>为用户授予resource权限，则不对用户的表空间进行限制<br><code>grant resource to username</code><br>授予用户表空间不受限制的权限<br><code>grant unlimited tablespace to username</code></p>
<h5 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h5><ol>
<li>Q1: 在springboot中，注解@RequestMapping的<strong>produces</strong>属性的含义?<br> 作用： 指定返回值的类型，不仅如此，也可以设定返回值的字符编码。<br> 与之相对应的一个属性为<em>consume</em>, 指定处理请求的提交内容的类型，如application/json,text/html.</li>
</ol>
]]></content>
      <tags>
        <tag>vueJs springboot element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>easypoi-excel模板处理</title>
    <url>/2020/07/06/easypoi-excel%E6%A8%A1%E6%9D%BF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="模板指令介绍"><a href="#模板指令介绍" class="headerlink" title="模板指令介绍"></a>模板指令介绍</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt; 下面列举下EasyPoi支持的指令以及作用，**最主要的就是各种fe的用法**</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 空格分割</span><br><span class="line">&gt; - 三目运算 &#123;&#123;test ? obj:obj2&#125;&#125;</span><br><span class="line">&gt; - n: 表示 这个cell是数值类型 &#123;&#123;n:&#125;&#125;</span><br><span class="line">&gt; - le: 代表长度&#123;&#123;le:()&#125;&#125; 在if/else 运用&#123;&#123;le:() &gt; 8 ? obj1 : obj2&#125;&#125;</span><br><span class="line">&gt; - fd: 格式化时间 &#123;&#123;fd:(obj;yyyy-MM-dd)&#125;&#125;</span><br><span class="line">&gt; - fn: 格式化数字 &#123;&#123;fn:(obj;###.00)&#125;&#125;</span><br><span class="line">&gt; - fe: 遍历数据,创建row</span><br><span class="line">&gt; - !fe: 遍历数据不创建row</span><br><span class="line">&gt; - $fe: 下移插入,把当前行,下面的行全部下移.size()行,然后插入</span><br><span class="line">&gt; - \#fe: 横向遍历</span><br><span class="line">&gt; - v_fe: 横向遍历值</span><br><span class="line">&gt; - !if: 删除当前列 &#123;&#123;!if:(test)&#125;&#125;</span><br><span class="line">&gt; - 单引号表示常量值 &#x27;&#x27; 比如&#x27;1&#x27; 那么输出的就是 1</span><br><span class="line">&gt; - &amp;NULL&amp; 空格</span><br><span class="line">&gt; - ]] 换行符 多行遍历导出</span><br><span class="line">&gt; - sum： 统计数据</span><br></pre></td></tr></table></figure>
<h4 id="基本导出"><a href="#基本导出" class="headerlink" title="基本导出"></a>基本导出</h4><p>是插入数据的，不是单纯的导出一个标题和表头。</p>
<p><img src="http://wrr123.github.io/2020/07/06/easypoi-excel%E6%A8%A1%E6%9D%BF%E5%A4%84%E7%90%86/11.png" alt></p>
<h4 id="单纯的导出excel文件的表头信息"><a href="#单纯的导出excel文件的表头信息" class="headerlink" title="单纯的导出excel文件的表头信息"></a>单纯的导出excel文件的表头信息</h4><p>使用注解@Excel,在实体类上使用</p>
<p>设置导出参数类，<code>ExportParams</code></p>
<p>使用导出工具类实现导出，<code>ExcelExportUtil</code></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>easypoi</title>
    <url>/2020/06/30/easypoi/</url>
    <content><![CDATA[<h3 id="EasyPoi-Excel和Word简易工具类"><a href="#EasyPoi-Excel和Word简易工具类" class="headerlink" title="EasyPoi Excel和Word简易工具类"></a>EasyPoi Excel和Word简易工具类</h3><p>主打功能： 让一个没接触过POI的人员，可以方便的写出Excel导出，Excel模板导出，Excel导入，word模板导出，通过简单的注解和模板语言（熟悉的表达式语法），完成以前复杂的写法。</p>
<p><a href="https://opensource.afterturn.cn/">官网</a> <a href="https://github.com/jueyue/easypoi/blob/master/README.md">英文介绍</a></p>
<h5 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h5><p><strong><a href="http://opensource.afterturn.cn/doc/easypoi.html">https://opensource.afterturn.cn/doc/easypoi.html</a></strong></p>
<h5 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h5><p><a href="https://gitee.com/lemur/easypoi/blob/master/history.md">history.md</a></p>
<h5 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h5><p><a href="https://gitee.com/lemur/easypoi/blob/master/basedemo.md">basedemo.md</a></p>
<p><a href="http://git.oschina.net/lemur/easypoi-test">测试项目</a>: <a href="http://git.oschina.net/lemur/easypoi-test">http://git.oschina.net/lemur/easypoi-test</a></p>
<hr>
<h4 id="EasyPoi的主要特点"><a href="#EasyPoi的主要特点" class="headerlink" title="EasyPoi的主要特点"></a>EasyPoi的主要特点</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1.设计精巧,使用简单</span><br><span class="line">2.接口丰富,扩展简单</span><br><span class="line">3.默认值多,write less do more</span><br><span class="line">4.AbstractView 支持,web导出可以简单明了</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="什么场景该用哪个方法"><a href="#什么场景该用哪个方法" class="headerlink" title="什么场景该用哪个方法"></a>什么场景该用哪个方法</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">- 导出</span><br><span class="line">    1.正规excel导出 (格式简单,数据量可以,5W以内吧)</span><br><span class="line">        注解方式:  ExcelExportUtil.exportExcel(ExportParams entity, Class&lt;?&gt; pojoClass,Collection&lt;?&gt; dataSet) </span><br><span class="line">    2.不定多少列,但是格式依然简单数据库不大</span><br><span class="line">        自定义方式: ExcelExportUtil.exportExcel(ExportParams entity, List&lt;ExcelExportEntity&gt; entityList,Collection&lt;?&gt; dataSet)</span><br><span class="line">    3.数据量大超过5W,还在100W以内</span><br><span class="line">        注解方式 ExcelExportUtil.exportBigExcel(ExportParams entity, Class&lt;?&gt; pojoClass,IExcelExportServer server, Object queryParams)</span><br><span class="line">        自定义方式: ExcelExportUtil.exportBigExcel(ExportParams entity, List&lt;ExcelExportEntity&gt; excelParams,IExcelExportServer server, Object queryParams)</span><br><span class="line">    4.样式复杂,数据量尽量别大</span><br><span class="line">        模板导出 ExcelExportUtil.exportExcel(TemplateExportParams params, Map&lt;String, Object&gt; map)</span><br><span class="line">    5.一次导出多个风格不一致的sheet</span><br><span class="line">        模板导出 ExcelExportUtil.exportExcel(Map&lt;Integer, Map&lt;String, Object&gt;&gt; map,TemplateExportParams params) </span><br><span class="line">    6.一个模板但是要导出非常多份</span><br><span class="line">        模板导出 ExcelExportUtil.exportExcelClone(Map&lt;Integer, List&lt;Map&lt;String, Object&gt;&gt;&gt; map,TemplateExportParams params)</span><br><span class="line">    7.模板无法满足你的自定义,试试html</span><br><span class="line">        自己构造html,然后我给你转成excel  ExcelXorHtmlUtil.htmlToExcel(String html, ExcelType type)</span><br><span class="line">    8.数据量过百万级了.放弃excel吧,csv导出</span><br><span class="line">        注解方式: CsvExportUtil.exportCsv(CsvExportParams params, Class&lt;?&gt; pojoClass, OutputStream outputStream)</span><br><span class="line">        自定义方式: CsvExportUtil.exportCsv(CsvExportParams params, List&lt;ExcelExportEntity&gt; entityList, OutputStream outputStream)</span><br><span class="line">    9.word导出</span><br><span class="line">        模板导出: WordExportUtil.exportWord07(String url, Map&lt;String, Object&gt; map)</span><br><span class="line">    10.PDF导出</span><br><span class="line">        模板导出: TODO </span><br><span class="line">- 导入 </span><br><span class="line">    如果想提高性能 ImportParams 的concurrentTask 可以帮助并发导入,仅单行,最小1000</span><br><span class="line">    excel有单个的那种特殊读取,readSingleCell 参数可以支持</span><br><span class="line">    1. 不需要检验,数据量不大(5W以内)</span><br><span class="line">        注解或者MAP: ExcelImportUtil.importExcel(File file, Class&lt;?&gt; pojoClass, ImportParams params)</span><br><span class="line">    2. 需要导入,数据量不大</span><br><span class="line">        注解或者MAP: ExcelImportUtil.importExcelMore(InputStream inputstream, Class&lt;?&gt; pojoClass, ImportParams params)</span><br><span class="line">    3. 数据量大了,或者你有特别多的导入操作,内存比较少,仅支持单行</span><br><span class="line">       SAX方式  ExcelImportUtil.importExcelBySax(InputStream inputstream, Class&lt;?&gt; pojoClass, ImportParams params, IReadHandler handler)</span><br><span class="line">    4. 数据量超过EXCEL限制,CSV读取</span><br><span class="line">        小数据量: CsvImportUtil.importCsv(InputStream inputstream, Class&lt;?&gt; pojoClass,CsvImportParams params)</span><br><span class="line">        大数据量: CsvImportUtil.importCsv(InputStream inputstream, Class&lt;?&gt; pojoClass,CsvImportParams params, IReadHandler readHandler)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="关于Excel导出XLS和XLSX的区别"><a href="#关于Excel导出XLS和XLSX的区别" class="headerlink" title="关于Excel导出XLS和XLSX的区别"></a>关于Excel导出XLS和XLSX的区别</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1. 导出时间xls比xlsx块2-3倍</span><br><span class="line">2. 导出大小xls是xlsx的2-3倍或者更多</span><br><span class="line">3. 导出需要综合网速和本地速度做考虑^~^</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="几个工程的说明"><a href="#几个工程的说明" class="headerlink" title="几个工程的说明"></a>几个工程的说明</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1.easypoi 父包--作用大家都懂得</span><br><span class="line">2.easypoi-annotation 基础注解包,作用与实体对象上,拆分后方便maven多工程的依赖管理</span><br><span class="line">3.easypoi-base 导入导出的工具包,可以完成Excel导出,导入,Word的导出,Excel的导出功能</span><br><span class="line">4.easypoi-web  耦合了spring-mvc 基于AbstractView,极大的简化spring-mvc下的导出功能</span><br><span class="line">5.sax 导入使用xercesImpl这个包(这个包可能造成奇怪的问题哈),word导出使用poi-scratchpad,都作为可选包了</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-annotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h5 id="pom说明"><a href="#pom说明" class="headerlink" title="pom说明"></a>pom说明</h5><p>word和sax读取的时候才使用，就不是必须的了，请手动引用；JSR303的校验也是可选的；pdf的jar也是可选的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sax 读取时候用到的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xerces<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xercesImpl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;xerces.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-scratchpad<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Word 需要使用 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ooxml-schemas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 校验,下面两个实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bval<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.apache.bval.bundle<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- PDF --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itextpdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itext-asian<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>easypoi开发指南</title>
    <url>/2020/07/01/easypoi%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h3 id="Excel注解版"><a href="#Excel注解版" class="headerlink" title="Excel注解版"></a>Excel注解版</h3><h4 id="Excel导入导出"><a href="#Excel导入导出" class="headerlink" title="Excel导入导出"></a>Excel导入导出</h4><p>支持三种方式的处理（其中模板和html目前只支持导出）</p>
<ul>
<li>注解方式，注解变种方式</li>
<li>模板方式</li>
<li>Html方式</li>
</ul>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="注解分成5个类别："><a href="#注解分成5个类别：" class="headerlink" title="注解分成5个类别："></a>注解分成5个类别：</h5><ul>
<li>@Excel 作用到field上面，是对excel一列的描述</li>
<li>@ExcelCollection 表示一个集合，主要针对一对多的导出，比如一个老师对应多个科目，那么科目就可以用集合来表示</li>
<li>@ExcelEntity 表示一个继续深入导出的实体，但他没有太多的意义，只是告诉系统这个对象里面同样有导出的字段</li>
<li>@ExcelIgnore 和名字一样，表示这个字段被忽略，跳过这个导出</li>
<li>@ExcelTarget 这个是作用于最外层的对象，描述这个对象的id，以便一个对象可以针对不同导出做出不同处理</li>
</ul>
<h4 id="注解导出，导入"><a href="#注解导出，导入" class="headerlink" title="注解导出，导入"></a>注解导出，导入</h4><ol>
<li><h5 id="对象定义"><a href="#对象定义" class="headerlink" title="对象定义"></a>对象定义</h5></li>
<li><h5 id="集合定义"><a href="#集合定义" class="headerlink" title="集合定义"></a>集合定义</h5></li>
<li><h5 id="图片的导出"><a href="#图片的导出" class="headerlink" title="图片的导出"></a>图片的导出</h5></li>
<li><h5 id="Excel导入介绍"><a href="#Excel导入介绍" class="headerlink" title="Excel导入介绍"></a>Excel导入介绍</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ImportParams params = <span class="keyword">new</span> ImportParams();</span><br><span class="line">        params.setTitleRows(<span class="number">1</span>);</span><br><span class="line">        params.setHeadRows(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> start = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">        List&lt;MsgClient&gt; list = ExcelImportUtil.importExcel(</span><br><span class="line">           <span class="keyword">new</span> File(PoiPublicUtil.getWebRootPath(<span class="string">&quot;import/ExcelExportMsgClient.xlsx&quot;</span>)),</span><br><span class="line">            MsgClient.class, params);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().getTime() - start);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        System.out.println(ReflectionToStringBuilder.toString(list.get(<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ImportParams参数介绍：</p>
<p><img src="http://wrr123.github.io/2020/07/01/easypoi%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/ImportPrams参数介绍.png" alt></p>
</li>
<li><h5 id="Excel导入小功能"><a href="#Excel导入小功能" class="headerlink" title="Excel导入小功能"></a>Excel导入小功能</h5><ol>
<li><p>读取指定的sheet</p>
<p>比如要读取上传的第二个sheet，那么需要把<code>startSheetIndex = 1</code>就可以了</p>
</li>
<li><p>读取几个sheet</p>
<p>比如读取前2个sheet，那么<code>sheetNum = 2</code>就可以了</p>
</li>
<li><p>读取第2~5个sheet</p>
<p>设置<code>startSheetNum = 1;sheetNum = 4</code>就可以了</p>
</li>
<li><p>读取全部的sheet</p>
<p>sheetNum设置大点就可以了</p>
</li>
<li><p>保存excel</p>
<p>设置<code>needVerify = true</code>,默认保存的路径为 <code>upload/excelUpload/Test/yyyyMMddHHmss_***** 保存名称上传时间_五位随机数</code></p>
<p>如果自定义路径，修改下saveUrl就可以了，同时saveUrl也是图片上传时候保存的路径。</p>
</li>
<li><p>判断一个excel是不是合法的excel</p>
<p>importFields设置下值，就是表示表头必须至少包含的字段，如果缺一个就是不合法的exel，不导入。</p>
</li>
</ol>
</li>
<li><h5 id="图片的导入"><a href="#图片的导入" class="headerlink" title="图片的导入"></a>图片的导入</h5></li>
<li><h5 id="Excel多sheet导出"><a href="#Excel多sheet导出" class="headerlink" title="Excel多sheet导出"></a>Excel多sheet导出</h5></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>el-table作用域插槽</title>
    <url>/2020/09/03/el-table%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h4 id="获取每一行的序列"><a href="#获取每一行的序列" class="headerlink" title="获取每一行的序列"></a>获取每一行的序列</h4><p><code>scope.$index</code></p>
<p>这个序列是从 0 开始的，使用时需要 <code>+1</code> 。</p>
]]></content>
      <tags>
        <tag>vuejs</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>el-upload携带token和额外参数</title>
    <url>/2020/09/01/el-upload%E6%90%BA%E5%B8%A6token%E5%92%8C%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>el-upload详解</title>
    <url>/2020/09/02/el-upload%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h4><p>el-upload 在一次请求中上传多个文件时，上传组件是每个文件发一次上传请求。<br><br>http-request 属性可以覆盖默认的上传行为，自定义上传的实现</p>
<h5 id="FormData-对象使用"><a href="#FormData-对象使用" class="headerlink" title="FormData 对象使用"></a>FormData 对象使用</h5><p>常见的方法函数<br><img src="http://wrr123.github.io/2020/09/02/el-upload%E8%AF%A6%E8%A7%A3/001.png" alt></p>
<ul>
<li><code>append</code> 添加参数</li>
<li><code>get</code> 获取对应 key 的第一个参数</li>
<li><code>getAll</code> 获取对应 key 的所有参数<span id="more"></span>
</li>
</ul>
<h5 id="Axios-传递-FormData-类型的参数"><a href="#Axios-传递-FormData-类型的参数" class="headerlink" title="Axios 传递 FormData 类型的参数"></a>Axios 传递 FormData 类型的参数</h5><p>前端请求方法中，请求头中添加设置<br><code>Content-Type: multipart/form-data</code><br><strong>注意：不要序列化 FormData，post请求需要序列化（通常为 qs.stringify()），但是 poost 请求传 FormData 不需要</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axois <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">axois.post(url, formData, &#123; <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span> &#125;&#125;).then(...)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-css</title>
    <url>/2020/07/20/faq-css/</url>
    <content><![CDATA[<h4 id="css伪类？"><a href="#css伪类？" class="headerlink" title="css伪类？"></a>css伪类？</h4><p>css伪类是用来添加选择器的一些特殊效果。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>伪类的语法：</p>
<p><code>selector:pseudo-class &#123;property: value;&#125;</code></p>
<p>CSS类也可以使用伪类：</p>
<p><code>selector.class:pseudo-class &#123;property: value;&#125;</code></p>
<p><img src="http://wrr123.github.io/2020/07/20/faq-css/001.png" alt></p>
<p>所有的伪类/元素：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">示例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-checked.html">:checked</a></td>
<td style="text-align:left">input:checked</td>
<td style="text-align:left">选择所有选中的表单元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/css/cssref/sel-disabled.html">:disabled</a></td>
<td style="text-align:left">input:disabled</td>
<td style="text-align:left">选择所有禁用的表单元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-empty.html">:empty</a></td>
<td style="text-align:left">p:empty</td>
<td style="text-align:left">选择所有没有子元素的p元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-enable.html">:enabled</a></td>
<td style="text-align:left">input:enabled</td>
<td style="text-align:left">选择所有启用的表单元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-first-of-type.html">:first-of-type</a></td>
<td style="text-align:left">p:first-of-type</td>
<td style="text-align:left">选择的每个 p 元素是其父元素的第一个 p 元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-in-range.html">:in-range</a></td>
<td style="text-align:left">input:in-range</td>
<td style="text-align:left">选择元素指定范围内的值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-invalid.html">:invalid</a></td>
<td style="text-align:left">input:invalid</td>
<td style="text-align:left">选择所有无效的元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-last-child.html">:last-child</a></td>
<td style="text-align:left">p:last-child</td>
<td style="text-align:left">选择所有p元素的最后一个子元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-last-of-type.html">:last-of-type</a></td>
<td style="text-align:left">p:last-of-type</td>
<td style="text-align:left">选择每个p元素是其母元素的最后一个p元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-not.html">:not(selector)</a></td>
<td style="text-align:left">:not(p)</td>
<td style="text-align:left">选择所有p以外的元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-nth-child.html">:nth-child(n)</a></td>
<td style="text-align:left">p:nth-child(2)</td>
<td style="text-align:left">选择所有 p 元素的父元素的第二个子元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-nth-last-child.html">:nth-last-child(n)</a></td>
<td style="text-align:left">p:nth-last-child(2)</td>
<td style="text-align:left">选择所有p元素倒数的第二个子元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-nth-last-of-type.html">:nth-last-of-type(n)</a></td>
<td style="text-align:left">p:nth-last-of-type(2)</td>
<td style="text-align:left">选择所有p元素倒数的第二个为p的子元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-nth-of-type.html">:nth-of-type(n)</a></td>
<td style="text-align:left">p:nth-of-type(2)</td>
<td style="text-align:left">选择所有p元素第二个为p的子元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-only-of-type.html">:only-of-type</a></td>
<td style="text-align:left">p:only-of-type</td>
<td style="text-align:left">选择所有仅有一个子元素为p的元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-only-child.html">:only-child</a></td>
<td style="text-align:left">p:only-child</td>
<td style="text-align:left">选择所有仅有一个子元素的p元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-optional.html">:optional</a></td>
<td style="text-align:left">input:optional</td>
<td style="text-align:left">选择没有”required”的元素属性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-out-of-range.html">:out-of-range</a></td>
<td style="text-align:left">input:out-of-range</td>
<td style="text-align:left">选择指定范围以外的值的元素属性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-read-only.html">:read-only</a></td>
<td style="text-align:left">input:read-only</td>
<td style="text-align:left">选择只读属性的元素属性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-read-write.html">:read-write</a></td>
<td style="text-align:left">input:read-write</td>
<td style="text-align:left">选择没有只读属性的元素属性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-required.html">:required</a></td>
<td style="text-align:left">input:required</td>
<td style="text-align:left">选择有”required”属性指定的元素属性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-root.html">:root</a></td>
<td style="text-align:left">root</td>
<td style="text-align:left">选择文档的根元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-target.html">:targets</a></td>
<td style="text-align:left">#news:target</td>
<td style="text-align:left">选择当前活动#news元素(点击URL包含锚的名字)</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-valid.html">:valid</a></td>
<td style="text-align:left">input:valid</td>
<td style="text-align:left">选择所有有效值的属性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-link.html">:link</a></td>
<td style="text-align:left">a:link</td>
<td style="text-align:left">选择所有未访问链接</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-visited.html">:visited</a></td>
<td style="text-align:left">a:visited</td>
<td style="text-align:left">选择所有访问过的链接</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-active.html">:active</a></td>
<td style="text-align:left">a:active</td>
<td style="text-align:left">选择正在活动链接</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-hover.html">:hover</a></td>
<td style="text-align:left">a:hover</td>
<td style="text-align:left">把鼠标放在链接上的状态</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-focus.html">:focus</a></td>
<td style="text-align:left">input:focus</td>
<td style="text-align:left">选择元素输入后具有焦点</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-firstletter.html">:first-letter</a></td>
<td style="text-align:left">p:first-letter</td>
<td style="text-align:left">选择每个<p> 元素的第一个字母</p></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-firstline.html">:first-line</a></td>
<td style="text-align:left">p:first-line</td>
<td style="text-align:left">选择每个<p> 元素的第一行</p></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-firstchild.html">:first-child</a></td>
<td style="text-align:left">p:first-child</td>
<td style="text-align:left">选择器匹配属于任意元素的第一个子元素的 <p> 元素</p></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-before.html">:before</a></td>
<td style="text-align:left">p:before</td>
<td style="text-align:left">在每个<p>元素之前插入内容</p></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-after.html">:after</a></td>
<td style="text-align:left">p:after</td>
<td style="text-align:left">在每个<p>元素之后插入内容</p></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-lang.html">:lang(<em>language</em>)</a></td>
<td style="text-align:left">p:lang(it)</td>
<td style="text-align:left">为<p>元素的lang属性选择一个开始值</p></td>
</tr>
</tbody>
</table>
</div>
<h4 id="jQuery中的closest-selector-选择器"><a href="#jQuery中的closest-selector-选择器" class="headerlink" title="jQuery中的closest(selector)选择器"></a>jQuery中的<code>closest(selector)</code>选择器</h4><h5 id="描述：从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。"><a href="#描述：从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。" class="headerlink" title="描述：从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。"></a>描述：从元素本身开始，在DOM树上逐级向上级元素匹配，并返回最先匹配的祖先元素。</h5><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;li.item-a&#x27;</span>).closest(<span class="string">&#x27;ul&#x27;</span>).css(<span class="string">&#x27;background-color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="如何让image的图片充满父节点"><a href="#如何让image的图片充满父节点" class="headerlink" title="如何让image的图片充满父节点?"></a>如何让image的图片充满父节点?</h4><h5 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> image &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">object-fit</span>: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图片拉宽或者拉高时，使图片失真？"><a href="#图片拉宽或者拉高时，使图片失真？" class="headerlink" title="图片拉宽或者拉高时，使图片失真？"></a>图片拉宽或者拉高时，使图片失真？</h4><p>有点类似上面的css，</p>
<ul>
<li><p>使用img的话</p>
<p><code>object-fit: cover;</code></p>
</li>
<li><p>使用background-image的话</p>
<p><code>background-size: cover;</code></p>
</li>
</ul>
<h4 id="多个背景图片"><a href="#多个背景图片" class="headerlink" title="多个背景图片"></a>多个背景图片</h4><p>在css3里面，你可以在一个标签元素里应用多个背景图片。在引用图片之间用逗号<code>,</code>隔开。第一个图片是定位在元素最上面的背景，后面的背景图片一次在它的下面，如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">top-image.jpg</span>), <span class="built_in">url</span>(<span class="string">middle-image.jpg</span>), <span class="built_in">url</span>(<span class="string">bottom-image.jpg</span>);</span><br></pre></td></tr></table></figure>
<h4 id="div被遮挡，让一个div层浮在最上层的方法"><a href="#div被遮挡，让一个div层浮在最上层的方法" class="headerlink" title="div被遮挡，让一个div层浮在最上层的方法"></a>div被遮挡，让一个div层浮在最上层的方法</h4><p>首先设置<code>position</code>属性为<code>absolute,relative或fixed</code>，</p>
<p><strong>必须position为以上三个属性时，z-index才能层级体现出来，才能够起作用</strong></p>
<p><code>z-index</code>可以定义一个数值，其值越大代表越置前。</p>
<p>若定义为-1，表示最底层。</p>
<h4 id="隐藏滚动条，但依然可以滚动内容"><a href="#隐藏滚动条，但依然可以滚动内容" class="headerlink" title="隐藏滚动条，但依然可以滚动内容"></a>隐藏滚动条，但依然可以滚动内容</h4><h5 id="方式一：计算滚动条的长度，并隐藏起来"><a href="#方式一：计算滚动条的长度，并隐藏起来" class="headerlink" title="方式一：计算滚动条的长度，并隐藏起来"></a>方式一：计算滚动条的长度，并隐藏起来</h5><p>一个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-container&quot;</span>&gt;</span></span><br><span class="line">    	......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.outer-container</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">360px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner-container</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">right</span>: -<span class="number">17px</span>;</span><br><span class="line">	<span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">	<span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方式二：使用三个容器包围起来，不需要计算滚动条的宽度"><a href="#方式二：使用三个容器包围起来，不需要计算滚动条的宽度" class="headerlink" title="方式二：使用三个容器包围起来，不需要计算滚动条的宽度"></a>方式二：使用三个容器包围起来，不需要计算滚动条的宽度</h5><p>一个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-container&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">           ......</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span>, <span class="selector-class">.outer-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer-container</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid purple;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner-container</span>::-webkit-scrollbar &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="方式三：css-隐藏滚动条"><a href="#方式三：css-隐藏滚动条" class="headerlink" title="方式三：css 隐藏滚动条"></a>方式三：css 隐藏滚动条</h5><p>自定义滚动条的伪对象选择器  <code>::webkit-scrollbar</code></p>
<blockquote>
<p>chrome 和Safari</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span>::-webkit-scrollbar &#123; width: <span class="number">0</span> <span class="meta">!important</span> &#125;</span><br></pre></td></tr></table></figure>
<p>IE 10+</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123; -ms-<span class="attribute">overflow</span>-style: none; &#125;</span><br></pre></td></tr></table></figure>
<p>Firefox</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123; <span class="attribute">overflow</span>: -moz-scrollbars-none; &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="css-的注释"><a href="#css-的注释" class="headerlink" title="css 的注释"></a>css 的注释</h4><h5 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注释内容 --&gt;</span><br><span class="line"><span class="comment">/* 注释内容 */</span></span><br></pre></td></tr></table></figure>
<h5 id="区域注释"><a href="#区域注释" class="headerlink" title="区域注释"></a>区域注释</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=S 注释内容 */</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*=E 注释内容 */</span></span><br></pre></td></tr></table></figure>
<h5 id="协助注释"><a href="#协助注释" class="headerlink" title="协助注释"></a>协助注释</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=S 注释内容[修改人和修改时间] */</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*=E 注释内容[修改人和修改时间] */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-elementUI</title>
    <url>/2020/08/28/faq-elementUI/</url>
    <content><![CDATA[<h4 id="默认样式有时修改不成功的问题"><a href="#默认样式有时修改不成功的问题" class="headerlink" title="默认样式有时修改不成功的问题"></a>默认样式有时修改不成功的问题</h4><blockquote>
<p>有的时候element提供的默认的样式不能满足项目的需要，就需要对标签的样式进行修改，但是发现修改的样式不起作用</p>
</blockquote>
<p>解决方案：<strong>去掉 scoped</strong>，但是此时样式会编程全局样式，需要慎重考虑。</p>
<span id="more"></span>
<p><strong>因为我们无法直接在带有 scoped 的组件中直接修改第三方 UI 库的样式，</strong> 我们除了去掉 scoped 这个方法之外，还可以使用 <strong>深度选择器。</strong></p>
<p>对于 css<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt;&gt;&gt; <span class="selector-class">.hello</span> &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于 sass/less,<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line"><span class="selector-class">.select</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	/deep/ .el-input__inner &#123;</span><br><span class="line">		<span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="el-menu-在折叠状态时，鼠标在菜单上显示子菜单列表时，会出现有些菜单不够显示的问题。"><a href="#el-menu-在折叠状态时，鼠标在菜单上显示子菜单列表时，会出现有些菜单不够显示的问题。" class="headerlink" title="el-menu 在折叠状态时，鼠标在菜单上显示子菜单列表时，会出现有些菜单不够显示的问题。"></a><code>el-menu</code> 在折叠状态时，鼠标在菜单上显示子菜单列表时，会出现有些菜单不够显示的问题。</h4>]]></content>
      <tags>
        <tag>faq</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-git</title>
    <url>/2020/07/07/faq-git/</url>
    <content><![CDATA[<h4 id="解决git中文路径显示unicode代码的问题"><a href="#解决git中文路径显示unicode代码的问题" class="headerlink" title="解决git中文路径显示unicode代码的问题"></a>解决git中文路径显示unicode代码的问题</h4><p><code>git config --global core.quotepath false</code></p>
<p>添加上述配置，git就不会对路径进行转换，会显示完整的中文路径名称。</p>
<h4 id="remote-HTTP-Basic-Access-denied"><a href="#remote-HTTP-Basic-Access-denied" class="headerlink" title="remote: HTTP Basic: Access denied"></a>remote: HTTP Basic: Access denied</h4><p>问题描述：</p>
<p><img src="http://wrr123.github.io/2020/07/07/faq-git/001.png" alt></p>
<p>解决方案：</p>
<p>进入本地仓库目录下，执行如下命令：</p>
<p><code>git config --system --unset credential.helper</code></p>
<p>重新操作 git， 再次输入账号和密码即可。</p>
<p>因上述命令会清空 git config 里面保存的用户名和密码配置，在第一次清空之后，可以执行命令</p>
<p><code>git config --system credential.helper store</code></p>
<p>来保存用户名和密码配置信息。</p>
]]></content>
      <categories>
        <category>版本工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-java</title>
    <url>/2020/07/01/faq-java/</url>
    <content><![CDATA[<h4 id="jdk1-8如何解析和格式化日期"><a href="#jdk1-8如何解析和格式化日期" class="headerlink" title="jdk1.8如何解析和格式化日期"></a>jdk1.8如何解析和格式化日期</h4><h5 id="解析日期和时间"><a href="#解析日期和时间" class="headerlink" title="解析日期和时间"></a>解析日期和时间</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;1986-04-08 12:30&quot;</span>;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line">LocalDateTime dateTime = LocalDateTime.parse(str, formatter);</span><br></pre></td></tr></table></figure>
<h5 id="格式化日期和时间"><a href="#格式化日期和时间" class="headerlink" title="格式化日期和时间"></a>格式化日期和时间</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">1986</span>, Month.APRIL, <span class="number">8</span>, <span class="number">12</span>, <span class="number">30</span>);</span><br><span class="line">String formattedDateTime = dateTime.format(formatter); <span class="comment">// &quot;1986-04-08 12:30&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Java8中Date与LocalDateTime、LocalDate、LocalTime之间的互转"><a href="#Java8中Date与LocalDateTime、LocalDate、LocalTime之间的互转" class="headerlink" title="Java8中Date与LocalDateTime、LocalDate、LocalTime之间的互转"></a>Java8中Date与LocalDateTime、LocalDate、LocalTime之间的互转</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 01. java.util.Date --&gt; java.time.LocalDateTime</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UDateToLocalDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 02. java.util.Date --&gt; java.time.LocalDate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UDateToLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">    LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 03. java.util.Date --&gt; java.time.LocalTime</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UDateToLocalTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">    LocalTime localTime = localDateTime.toLocalTime();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 04. java.time.LocalDateTime --&gt; java.util.Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LocalDateTimeToUdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">    java.util.Date date = Date.from(instant);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 05. java.time.LocalDate --&gt; java.util.Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LocalDateToUdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    Instant instant = localDate.atStartOfDay().atZone(zone).toInstant();</span><br><span class="line">    java.util.Date date = Date.from(instant);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 06. java.time.LocalTime --&gt; java.util.Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LocalTimeToUdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalTime localTime = LocalTime.now();</span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">    java.util.Date date = Date.from(instant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="http错误代码"><a href="#http错误代码" class="headerlink" title="http错误代码"></a>http错误代码</h4><ol>
<li><h5 id="400"><a href="#400" class="headerlink" title="400"></a>400</h5><p>请求无效（bad request），出现这个请求报错说明请求没有进入到后台服务中</p>
<p>原因：</p>
<ul>
<li>前端提交数据的字段名称或者字段类型和后台的实体类不一致，导致无法封装。</li>
<li>前端提交到后台的数据应该是json字符串类型，而前端没有将对象转化为字符串类型。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>对照字段名称、类型，保证一致性</li>
<li>使用<code>JSON.stringify(param)</code>将前端传递的对象转化为字符串。</li>
</ul>
</li>
</ol>
<h4 id="EasyPOI导出excel文件时，若不想导出表头，怎么设置？"><a href="#EasyPOI导出excel文件时，若不想导出表头，怎么设置？" class="headerlink" title="EasyPOI导出excel文件时，若不想导出表头，怎么设置？"></a>EasyPOI导出excel文件时，若不想导出表头，怎么设置？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExportParams exportParams = <span class="keyword">new</span> ExportParams(<span class="string">&quot;支付宝账单&quot;</span>, <span class="string">&quot;支付宝账单&quot;</span>);</span><br><span class="line">List&lt;KnsAliBillVo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">workbook = ExcelExportUtil.exportExcel(exportParams, KnsAliBillVo.class, list);</span><br><span class="line"><span class="comment">// 如果不想导出表头那一行，可以设置表头字符串参数为null即可。</span></span><br><span class="line">ExportParams exportParams = <span class="keyword">new</span> ExportParams(<span class="keyword">null</span> , <span class="string">&quot;支付宝账单&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="java在同一行代码定义多个变量"><a href="#java在同一行代码定义多个变量" class="headerlink" title="java在同一行代码定义多个变量"></a>java在同一行代码定义多个变量</h4><p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同一行定义多个同类型的变量</span></span><br><span class="line">String a = <span class="string">&quot;Hello&quot;</span>, c = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h4 id="i-和-i-的区别"><a href="#i-和-i-的区别" class="headerlink" title="++i 和 i++ 的区别"></a>++i 和 i++ 的区别</h4><p>i++ 和 ++i 都是自增运算符，<code>i++</code> 有时被称作 <strong>后加运算符</strong> ，<code>++i</code> 被称作 <strong>前加运算符 。</strong></p>
<ul>
<li><code>i++</code> 是先赋值，再运算(自增长 1)</li>
<li><code>++i</code> 是先运算(自增长 1)，再赋值</li>
</ul>
<h5 id="讨论-i-与-i-的效率"><a href="#讨论-i-与-i-的效率" class="headerlink" title="讨论 i++ 与 ++i 的效率"></a>讨论 i++ 与 ++i 的效率</h5><blockquote>
<p>理论上，经过编译器优化后 i++ 与 ++i 的效率几乎一样，实际测试，++i 效率高于 i++。</p>
</blockquote>
<h4 id="spring中的注解-Component-Repository-Service-Controller-等标注的默认-Bean-名称"><a href="#spring中的注解-Component-Repository-Service-Controller-等标注的默认-Bean-名称" class="headerlink" title="spring中的注解 @Component, @Repository, @Service, @Controller 等标注的默认 Bean 名称"></a>spring中的注解 <code>@Component, @Repository, @Service, @Controller</code> 等标注的默认 Bean 名称</h4><p><strong>都是小写开头的类名</strong></p>
<h4 id="报错信息java-lang-NoSuchMethodError-org-json-JSONObject-put-String-Collection"><a href="#报错信息java-lang-NoSuchMethodError-org-json-JSONObject-put-String-Collection" class="headerlink" title="报错信息java.lang.NoSuchMethodError:org.json.JSONObject.put(String, Collection)"></a>报错信息<code>java.lang.NoSuchMethodError:org.json.JSONObject.put(String, Collection)</code></h4><p>经检查，引入的包中是存在这个方法的，但是依然报错，</p>
<p>可能原因：包依赖冲突的问题，需要检查<code>org.json</code>包是否引入了多次。</p>
<h4 id="springboot项目-Value取不到值的一些情况"><a href="#springboot项目-Value取不到值的一些情况" class="headerlink" title="springboot项目@Value取不到值的一些情况"></a>springboot项目<code>@Value</code>取不到值的一些情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;tag&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String tagValue;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用 <code>static</code> 或者 <code>final</code> 修改了 <code>tagValue</code></p>
</li>
<li><p>类上没有加上<code>@Component</code> 或者 <code>@Service</code>注解等</p>
</li>
<li><p>类被 <code>new</code> 新建了实例，而没有使用 <code>@Autowired</code>注解</p>
<p>  若不想使用 <code>@Autowired</code>自动装配，可以使用 <code>ApplicationContext</code>类来获取”bean”</p>
</li>
</ul>
<h4 id="stream中方法peek和map方法之间的区别"><a href="#stream中方法peek和map方法之间的区别" class="headerlink" title="stream中方法peek和map方法之间的区别"></a>stream中方法<code>peek</code>和<code>map</code>方法之间的区别</h4><ul>
<li>peek 可对元素的内部数据进行处理，返回的是原来的数据类型，不生成新的数据类型。</li>
<li>map 重新返回一个新的数据类型。</li>
</ul>
<h4 id="Math-floor-Math-ceil-Math-rint-Math-round用法详解"><a href="#Math-floor-Math-ceil-Math-rint-Math-round用法详解" class="headerlink" title="Math.floor, Math.ceil, Math.rint, Math.round用法详解"></a>Math.floor, Math.ceil, Math.rint, Math.round用法详解</h4><h5 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor"></a>Math.floor</h5><p>求一个最接近它的整数，它的值小于或等于这个浮点数。</p>
<h5 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil"></a>Math.ceil</h5><p>它是向上取整计算，它返回的是大于或等于函数参数的值，并且与之最接近的整数。</p>
<h5 id="Math-rint"><a href="#Math-rint" class="headerlink" title="Math.rint"></a>Math.rint</h5><p>它返回最接近参数的整数，如果有两个数同样相近，则返回偶数的那个。</p>
<h5 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round"></a>Math.round</h5><p>它表示“四舍五入”，算法为<code>Math.floor(x + 0.5)</code>，即将原来的数字加上<code>0.5</code>再向下取整。</p>
]]></content>
      <categories>
        <category>FAQ</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-jqGrid</title>
    <url>/2020/07/22/faq-jqGrid/</url>
    <content><![CDATA[<h4 id="colmodal中的属性shrinkToFit"><a href="#colmodal中的属性shrinkToFit" class="headerlink" title="colmodal中的属性shrinkToFit"></a>colmodal中的属性<code>shrinkToFit</code></h4><p>默认值为true。</p>
<p>如果<code>shrinkToFit</code>设置为了true，且设置了width值，那么每列的宽度会根据width成比例缩放；</p>
<p>如果<code>shrinkToFit</code>设置为了false，且也设置了width值，那么每列的宽度不会成比例缩放，而是保持原有的设置，并且grid将会有水平的滚动条。</p>
<p><img src="http://wrr123.github.io/2020/07/22/faq-jqGrid/001.png" alt></p>
]]></content>
      <categories>
        <category>faq</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-linux</title>
    <url>/2020/08/26/faq-linux/</url>
    <content><![CDATA[<h4 id="export-在-shell-脚本中设置环境变量失效"><a href="#export-在-shell-脚本中设置环境变量失效" class="headerlink" title="export 在 shell 脚本中设置环境变量失效"></a>export 在 shell 脚本中设置环境变量失效</h4><p>shell 脚本中设定的路径和环境变量只对该 shell 和其子 shell 有效，对其 <strong>父 shell 和其他 shell 无效。</strong></p>
<p>解决方法：</p>
<p>执行下面的脚本</p>
<p><code>source fileName.sh</code></p>
<p><strong>source 使 shell 脚本里的设置对其它 shell 也有效。</strong></p>
<span id="more"></span>]]></content>
      <tags>
        <tag>faq</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-maven</title>
    <url>/2020/07/27/faq-maven/</url>
    <content><![CDATA[<h4 id="maven打包-package-时，跳过单元测试？"><a href="#maven打包-package-时，跳过单元测试？" class="headerlink" title="maven打包(package)时，跳过单元测试？"></a>maven打包(package)时，跳过单元测试？</h4><ul>
<li><p>使用<code>mvn package -Dmaven.test.skip=true</code></p>
<p>不但跳过单元测试的运行，也跳过单元测试的编译。</p>
</li>
<li><p>使用<code>mvn package -DskipTests</code></p>
<p>跳过单元测试的运行，但是会继续编译。</p>
</li>
</ul>
<h4 id="dependencies和dependencyManagement的区别"><a href="#dependencies和dependencyManagement的区别" class="headerlink" title="dependencies和dependencyManagement的区别"></a>dependencies和dependencyManagement的区别</h4><blockquote>
<p>为了项目的正确运行，必须让所有的子模块使用依赖项的统一版本，必须确保应用的各个项目的依赖项和版本一致，才能保证测试的和发布的是相同的结果。在我们项目顶层的pom文件中，我们会看到dependencyManagement元素。通过它元素来管理jar包的版本，让子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。</p>
</blockquote>
<h5 id="dependencies应用场景"><a href="#dependencies应用场景" class="headerlink" title="dependencies应用场景"></a>dependencies应用场景</h5><blockquote>
<p>相对于dependencyManagement，如果在<code>module1</code>的pom文件中中通过dependencies引入jar，将默认被所有的子模块继承。</p>
</blockquote>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><blockquote>
<p>dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显式的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p>
<p>dependencies即使在子模块中不写该依赖项，那么子模块仍然会从父项目中继承该依赖项（全部继承）。</p>
<p>在实际的项目开发中，推荐在父pom中使用dependencyManagement对项目中使用到的依赖包进行统一的管理。</p>
</blockquote>
]]></content>
      <categories>
        <category>faq</category>
      </categories>
  </entry>
  <entry>
    <title>faq-mybatis</title>
    <url>/2020/10/23/faq-mybatis/</url>
    <content><![CDATA[<h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      <categories>
        <category>faq</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-mysql</title>
    <url>/2020/10/23/faq-mysql/</url>
    <content><![CDATA[<h4 id="discard-long-time-none-received-connection-错误信息"><a href="#discard-long-time-none-received-connection-错误信息" class="headerlink" title="discard long time none received connection 错误信息"></a><code>discard long time none received connection</code> 错误信息</h4><p>可能原因：</p>
<blockquote>
<p>druid的版本问题，从最新的1.1.23 回退到 1.1.22可解决。</p>
</blockquote>
<h4 id="慢-sql-的问题"><a href="#慢-sql-的问题" class="headerlink" title="慢 sql 的问题"></a>慢 sql 的问题</h4><p>使用 <code>druid-spring-boot-starter</code> 时，某些 sql 执行的速度很慢。</p>
<h5 id="慢-sql-监控"><a href="#慢-sql-监控" class="headerlink" title="慢 sql 监控"></a>慢 sql 监控</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#是否开启慢sql查询监控  </span></span><br><span class="line"><span class="meta">spring.datasource.druid.filter.stat.log-slow-sql</span>=<span class="string">true  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#慢SQL执行时间  </span></span><br><span class="line"><span class="meta">spring.datasource.druid.filter.stat.slow-sql-millis</span>=<span class="string">1  </span></span><br></pre></td></tr></table></figure>
<span id="more"></span>]]></content>
      <categories>
        <category>faq</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-oracle</title>
    <url>/2020/07/01/faq-oracle/</url>
    <content><![CDATA[<h4 id="ORA-01861-文字与格式字符串不匹配"><a href="#ORA-01861-文字与格式字符串不匹配" class="headerlink" title="ORA-01861: 文字与格式字符串不匹配"></a>ORA-01861: 文字与格式字符串不匹配</h4><p>原因：数据库中字段定义的为date类型，而在java中定义的为string字符串类型</p>
<p>解决：将java中的字段类型改为<code>java.util.Date</code>类型</p>
<h4 id="将多行数据的同一个字段合并到一列"><a href="#将多行数据的同一个字段合并到一列" class="headerlink" title="将多行数据的同一个字段合并到一列"></a>将多行数据的同一个字段合并到一列</h4><h5 id="listagg"><a href="#listagg" class="headerlink" title="listagg()"></a>listagg()</h5><p>例子：</p>
<p><img src="http://wrr123.github.io/2020/07/01/faq-oracle/22.png" alt></p>
<p><img src="http://wrr123.github.io/2020/07/01/faq-oracle/33.png" alt></p>
<p>注意点：</p>
<p><img src="http://wrr123.github.io/2020/07/01/faq-oracle/11.png" alt></p>
<h5 id="wm-concat"><a href="#wm-concat" class="headerlink" title="wm_concat()"></a>wm_concat()</h5><p>wm_concat()默认以逗号<code>,</code>来分割字段；</p>
<h4 id="oracle-判断除数不为-0-的方法"><a href="#oracle-判断除数不为-0-的方法" class="headerlink" title="oracle 判断除数不为 0 的方法"></a>oracle 判断除数不为 0 的方法</h4><p><code>decode(column_name, 0, 0, column_name_1 / column_name)</code></p>
]]></content>
      <categories>
        <category>FAQ</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-python</title>
    <url>/2020/10/30/faq-python/</url>
    <content><![CDATA[<h4 id="在某些函数定义的入参中，使用-表示什么？"><a href="#在某些函数定义的入参中，使用-表示什么？" class="headerlink" title="在某些函数定义的入参中，使用 / 表示什么？"></a>在某些函数定义的入参中，使用 <code>/</code> 表示什么？</h4><p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len(obj, &#x2F;)</span><br><span class="line">    # Return the number of items in a container.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="警告：给一个参数添加默认值为字典时，argument-会提示警告-Default-argument-value-is-mutable"><a href="#警告：给一个参数添加默认值为字典时，argument-会提示警告-Default-argument-value-is-mutable" class="headerlink" title="警告：给一个参数添加默认值为字典时，argument = {}, 会提示警告 Default argument value is mutable"></a>警告：给一个参数添加默认值为字典时，<code>argument = &#123;&#125;</code>, 会提示警告 <code>Default argument value is mutable</code></h4><ol>
<li><p>可以在赋值时，赋值为 <code>None</code>, 再在方法内部判断，给其赋默认值。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">value, dic = <span class="literal">None</span></span>):</span></span><br><span class="line">    dic = dic <span class="keyword">if</span> <span class="built_in">dict</span> <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    <span class="comment"># 或者</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">dict</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">dict</span> = &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>faq</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>faq-vuejs</title>
    <url>/2020/07/06/faq-vuejs/</url>
    <content><![CDATA[<h4 id="vue-Element-UI-日期选择器获取日期格式问题-t-getTime-is-not-a-function"><a href="#vue-Element-UI-日期选择器获取日期格式问题-t-getTime-is-not-a-function" class="headerlink" title="vue Element UI 日期选择器获取日期格式问题 t.getTime is not a function"></a>vue Element UI 日期选择器获取日期格式问题 t.getTime is not a function</h4><p><a href="https://my.oschina.net/u/4298485/blog/3937219">oschina参考文档</a></p>
<h4 id="vuejs-不支持-ie-浏览器的问题"><a href="#vuejs-不支持-ie-浏览器的问题" class="headerlink" title="vuejs 不支持 ie 浏览器的问题"></a>vuejs 不支持 ie 浏览器的问题</h4><h5 id="可能原因-一"><a href="#可能原因-一" class="headerlink" title="可能原因(一)"></a>可能原因(一)</h5><p>因为 Vue 使用了 ES6 Promise，而 IE 浏览器不支持。</p>
<p><strong>解决方法：</strong></p>
<p>使用 babel-polyfill 转换</p>
<p><code>npm install [--save-dev] babel-polyfill</code></p>
<p>如果使用 vue-cli 项目，在 webpack.config.js 中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;babel-polyfill&#x27;</span>)</span><br><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">    app: [<span class="string">&#x27;babel-polyfill&#x27;</span>, <span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="有作用域的-css"><a href="#有作用域的-css" class="headerlink" title="有作用域的 css"></a>有作用域的 css</h4><p>当 <code>&lt;style&gt;</code> 标签有 <code>scoped</code> 属性时，它的 css 只作用于当前组件中的元素。这类似于 Shadow DOM 中的样式封装。</p>
<p><strong>注意</strong></p>
<h5 id="混用本地和全局样式"><a href="#混用本地和全局样式" class="headerlink" title="混用本地和全局样式"></a>混用本地和全局样式</h5><p>你可以在一个组件中同时使用有作用域和无作用域的样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 全局样式 */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 本地样式 */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="子组件的根元素"><a href="#子组件的根元素" class="headerlink" title="子组件的根元素"></a>子组件的根元素</h5><blockquote>
<p>使用 <code>scoped</code> 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件有作用域的 CSS 和子组件有作用域的 CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。</p>
</blockquote>
<h5 id="深度作用选择器"><a href="#深度作用选择器" class="headerlink" title="深度作用选择器"></a>深度作用选择器</h5><blockquote>
<p>如果你希望 <code>scoped</code> 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 <code>&gt;&gt;&gt;</code> 操作符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.a</span> &gt;&gt;&gt; <span class="selector-class">.b</span> &#123; <span class="comment">/* ... */</span> &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码将会编译成：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span><span class="selector-attr">[data-v-f3f3eg9]</span> <span class="selector-class">.b</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>有些像 Sass 之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code>。这种情况下你可以使用 <code>/deep/</code> 操作符取而代之——这是一个 <code>&gt;&gt;&gt;</code> 的别名，同样可以正常工作。</p>
</blockquote>
<h5 id="动态生成的内容"><a href="#动态生成的内容" class="headerlink" title="动态生成的内容"></a>动态生成的内容</h5><blockquote>
<p>通过 <code>v-html</code> 创建的 DOM 内容不受作用域内的样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式。</p>
</blockquote>
<h5 id="还有一些要留意"><a href="#还有一些要留意" class="headerlink" title="还有一些要留意"></a>还有一些要留意</h5><blockquote>
<ul>
<li><strong>CSS 作用域不能代替 class</strong>。考虑到浏览器渲染各种 CSS 选择器的方式，当 <code>p &#123; color: red &#125;</code> 设置了作用域时 (即与特性选择器组合使用时) 会慢很多倍。如果你使用 class 或者 id 取而代之，比如 <code>.example &#123; color: red &#125;</code>，性能影响就会消除。你可以在<a href="https://stevesouders.com/efws/css-selectors/csscreate.php">这块试验田</a>中测试它们的不同。</li>
<li><strong>在递归组件中小心使用后代选择器!</strong> 对选择器 <code>.a .b</code> 中的 CSS 规则来说，如果匹配 <code>.a</code> 的元素包含一个递归子组件，则所有的子组件中的 <code>.b</code> 都将被这个规则匹配。</li>
</ul>
</blockquote>
<h4 id="Module-build-failed-Error-ENOENT-no-such-file-or-directory-scandir-‘D-www-第三方Demo-vue2-0-demos-node-modules-node-sass-vendor’"><a href="#Module-build-failed-Error-ENOENT-no-such-file-or-directory-scandir-‘D-www-第三方Demo-vue2-0-demos-node-modules-node-sass-vendor’" class="headerlink" title="Module build failed: Error: ENOENT: no such file or directory, scandir ‘D:\www\第三方Demo\vue2.0-demos\node_modules\node-sass\vendor’"></a>Module build failed: Error: ENOENT: no such file or directory, scandir ‘D:\www\第三方Demo\vue2.0-demos\node_modules\node-sass\vendor’</h4><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><code>npm rebuild node-sass</code></p>
<h4 id="Vue-js-中的图片引用路径"><a href="#Vue-js-中的图片引用路径" class="headerlink" title="Vue.js 中的图片引用路径"></a>Vue.js 中的图片引用路径</h4><h5 id="使用-import-的方式导入"><a href="#使用-import-的方式导入" class="headerlink" title="使用 import 的方式导入"></a>使用 import 的方式导入</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import avatar from &#39;@&#x2F;assets&#x2F;logo.png&#39;</span><br><span class="line">&#x2F;&#x2F; 在 data 中定义</span><br><span class="line">avatar: avatar</span><br></pre></td></tr></table></figure>
<h5 id="使用-require-的方式导入"><a href="#使用-require-的方式导入" class="headerlink" title="使用 require 的方式导入"></a>使用 require 的方式导入</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 data 中定义</span><br><span class="line">avatar: require(&#39;@&#x2F;assets&#x2F;logo.png&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="http://wrr123.github.io/2020/07/06/faq-vuejs/001.png" alt></p>
<h5 id="资源路径处理"><a href="#资源路径处理" class="headerlink" title="资源路径处理"></a>资源路径处理</h5><p>默认情况下，<code>vue-loader</code> 使用 css-loader 和 Vue 模板编译器自动处理样式和模板文件。在编译过程中，所有的资源路径例如 <code>&lt;img src=&quot;...&quot;&gt;</code> 、<code>background: url(...) 和 @import</code> <strong>会作为模块依赖 。</strong></p>
<p>一个栗子：url(./image.png) 会被转换为 require(‘./image.png’)，而</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../image.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将会编译为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createElement(<span class="string">&#x27;img&#x27;</span>, &#123;<span class="attr">attrs</span>: &#123;<span class="attr">src</span>: <span class="built_in">require</span>(<span class="string">&#x27;../image.png&#x27;</span>)&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="编译规则"><a href="#编译规则" class="headerlink" title="编译规则"></a>编译规则</h5><blockquote>
<ul>
<li><p>如果路径是绝对路径，会原样保留。</p>
</li>
<li><p>如果路径以 <code>.</code> 开头，将会被看作相对的模块依赖，并按照你的本地文件系统上的目录结构进行解析。</p>
</li>
<li><p>如果路径以 <code>~</code> 开头，其后的部分将会被看作模块依赖。这意味着你可以用该特性来引用一个 node 依赖中的资源：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;~some-npm-package/foo.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>(13.7.0+) 如果路径以 <code>@</code> 开头，也会被看作模块依赖。如果你的 webpack 配置中给 <code>@</code> 配置了 alias，这就很有用了。所有 <code>vue-cli</code> 创建的项目都默认配置了将 <code>@</code> 指向 <code>/src</code>。</p>
</li>
</ul>
</blockquote>
<h4 id="vue-路由出现多级时，页面访问出现-404-的问题"><a href="#vue-路由出现多级时，页面访问出现-404-的问题" class="headerlink" title="vue 路由出现多级时，页面访问出现 404 的问题"></a>vue 路由出现多级时，页面访问出现 404 的问题</h4><p>产生问题的原因：<br>路由导航是通过 path 参数来进行跳转的<br><code>router.push(&#123; path: &#39;user&#39;&#125;)</code><br>如果换成 name 参数来进行导航的话，就正常了</p>
<p>暂未发现为什么这个原因会产生此问题。</p>
<h4 id="vue-同一路由不跳转的问题（path-相同，query-不同"><a href="#vue-同一路由不跳转的问题（path-相同，query-不同" class="headerlink" title="vue 同一路由不跳转的问题（path 相同，query 不同)"></a>vue 同一路由不跳转的问题（path 相同，query 不同)</h4><p>解决方法：</p>
<ol>
<li>给 router-view 设置 key 属性为路由的完整路径</li>
<li>官方给出的方法是通过 watch 监听路由变化，做判断路由路径然后调用响应的方法</li>
<li>通过组件导航守卫来设置对应的 meta 属性</li>
</ol>
<h4 id="出现-Uncaught-in-Promise-错误"><a href="#出现-Uncaught-in-Promise-错误" class="headerlink" title="出现 Uncaught (in Promise) 错误"></a>出现 <code>Uncaught (in Promise)</code> 错误</h4><p>错误原因：<code>你的某个 promise 没有加上 catch 语句。</code></p>
<h4 id="vue强制刷新组件的方法"><a href="#vue强制刷新组件的方法" class="headerlink" title="vue强制刷新组件的方法"></a>vue强制刷新组件的方法</h4><h5 id="不妥的方式：使用-v-if"><a href="#不妥的方式：使用-v-if" class="headerlink" title="不妥的方式：使用 v-if"></a>不妥的方式：使用 <code>v-if</code></h5><p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;my-component v-if&#x3D;&quot;renderComponent&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        renderComponent: true,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      forceRerender() &#123;</span><br><span class="line">        &#x2F;&#x2F; 从 DOM 中删除 my-component 组件</span><br><span class="line">        this.renderComponent &#x3D; false;</span><br><span class="line">        </span><br><span class="line">        this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 在 DOM 中添加 my-component 组件</span><br><span class="line">          this.renderComponent &#x3D; true;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="较好的方法：forceUpdate方法"><a href="#较好的方法：forceUpdate方法" class="headerlink" title="较好的方法：forceUpdate方法"></a>较好的方法：<code>forceUpdate</code>方法</h5><p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">Vue.forceUpdate();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用组件实例</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    methodThatForcesUpdate() &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">      this.$forceUpdate();</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最好的方法：在组件上进行-key-更改"><a href="#最好的方法：在组件上进行-key-更改" class="headerlink" title="最好的方法：在组件上进行 key 更改"></a>最好的方法：在组件上进行 <code>key</code> 更改</h5><blockquote>
<p>要正确地做到这一点，我们将提供一个<code>key</code>属性，以便 Vue 知道特定的组件与特定的数据片段相关联。如果<code>key</code>保持不变，则不会更改组件，但是如果<code>key</code>发生更改，Vue 就会知道应该删除旧组件并创建新组件。</p>
</blockquote>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-to-re-render :key&#x3D;&quot;componentKey&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      componentKey: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    forceRerender() &#123;</span><br><span class="line">      this.componentKey +&#x3D; 1;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>freemarker之html页面传参</title>
    <url>/2020/07/02/freemarker%E4%B9%8Bhtml%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<h5 id="使用freemarker的基本语法"><a href="#使用freemarker的基本语法" class="headerlink" title="使用freemarker的基本语法"></a>使用freemarker的基本语法</h5><p><code>$&#123;变量名称&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileId = <span class="string">&#x27;$&#123;fileId&#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> fileId = <span class="string">&#x27;$&#123;fileId?js_string&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>和在html标签中使用是一样的</strong></p>
<p><strong>在html界面中引入的javascript文件中是不行的，必须在html本页面上内联的javascript语句中执行</strong></p>
<p><img src="http://wrr123.github.io/2020/07/02/freemarker%E4%B9%8Bhtml%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82/22.png" alt></p>
<p><img src="http://wrr123.github.io/2020/07/02/freemarker%E4%B9%8Bhtml%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82/11.png" alt></p>
<p>若在上面的<code>initStockDetails.js</code>文件中，使用freemarker的语法是不生效的。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title>freemarker快速入门</title>
    <url>/2020/08/12/freemarker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="什么是-FreeMarker"><a href="#什么是-FreeMarker" class="headerlink" title="什么是 FreeMarker"></a>什么是 FreeMarker</h4><p>FreeMarker 是一种模板引擎：一种基于模板的、用来生成输出文件(任何来自于 HTML 格式的文本用来自动生成源代码)的通用工具。</p>
<p>它是为 Java 程序员提供的一个开发包或者说是类库。</p>
<p>它不是面向最终用户，而是为程序员提供的可以嵌入他们的开发产品的一款应用程序。</p>
<span id="more"></span>
<h4 id="搭建-SpringMVC-FreeMarker-环境"><a href="#搭建-SpringMVC-FreeMarker-环境" class="headerlink" title="搭建 SpringMVC + FreeMarker 环境"></a>搭建 SpringMVC + FreeMarker 环境</h4><h5 id="一个-springmvc-xml-的配置栗子："><a href="#一个-springmvc-xml-的配置栗子：" class="headerlink" title="一个 springmvc.xml 的配置栗子："></a>一个 springmvc.xml 的配置栗子：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--对模型视图名称的解析，即在模型视图名称添加前后缀 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerView&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;contentType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exposeRequestAttributes&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exposeSessionAttributes&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exposeSpringMacroHelpers&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 定义freemarker参数文件并载入 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;freemarkerConfiguration&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:freemarker.properties&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 定义freemarker配置，包括模板根路径、参数 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;freemarkerConfig&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注意： templateLoaderPath必须设置，否则freemarker找不到模板位置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateLoaderPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;freemarkerSettings&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;freemarkerConfiguration&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="一个-freemarker-properties-的栗子："><a href="#一个-freemarker-properties-的栗子：" class="headerlink" title="一个 freemarker.properties 的栗子："></a>一个 freemarker.properties 的栗子：</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">template_update_delay</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">defaultEncoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="attr">url_escaping_charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="attr">locale</span>=<span class="string">zh_CN</span></span><br><span class="line"><span class="attr">boolean_format</span>=<span class="string">true,false</span></span><br><span class="line"><span class="attr">datetime_format</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="attr">date_format</span>=<span class="string">yyyy-MM-dd</span></span><br><span class="line"><span class="attr">time_format</span>=<span class="string">HH:mm:ss</span></span><br><span class="line"><span class="attr">number_format</span>=<span class="string">0.######</span></span><br><span class="line"><span class="attr">whitespace_stripping</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h4 id="打印值"><a href="#打印值" class="headerlink" title="打印值"></a>打印值</h4><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#assign name=&quot;hello&quot;&gt;</span><br><span class="line">$&#123;name&#125; <span class="comment">&lt;!-- 输出 hello --&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#assign number=10&gt;</span><br><span class="line">	$&#123;number&#125;</span><br><span class="line">    <span class="comment">&lt;!--输出10 --&gt;</span></span><br><span class="line">&lt;#assign number2=2.5&gt;</span><br><span class="line">   		$&#123;number2&#125;</span><br><span class="line">    <span class="comment">&lt;!--输出2.5 --&gt;</span></span><br><span class="line">&lt;#assign avg = number/number2&gt;</span><br><span class="line">    	$&#123;avg&#125;</span><br><span class="line"><span class="comment">&lt;!--输出4 --&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#assign flag = true&gt;</span><br><span class="line">	$&#123;flag&#125;</span><br><span class="line"><span class="comment">&lt;!-- 	输出true --&gt;</span></span><br><span class="line">	&lt;#assign flag2 = false&gt;</span><br><span class="line">	$&#123;flag2&#125;</span><br><span class="line"><span class="comment">&lt;!-- 	什么也没有输出 为空字符串--&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#assign flag3 = &quot;true&quot;&gt;</span><br><span class="line">	$&#123;flag3&#125;</span><br><span class="line"><span class="comment">&lt;!-- 	输出为true --&gt;</span></span><br><span class="line">	&lt;#assign flag4 = &quot;false&quot;&gt;</span><br><span class="line">	$&#123;flag4&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#if flag3&gt; 为真 &lt;/#if&gt; <span class="comment">&lt;!-- 打印为真，freemarker将字符串&quot;true&quot;转换为boolean --&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#assign x=2&gt;</span><br><span class="line">    $&#123;100-2&#125;</span><br><span class="line">   <span class="comment">&lt;!--  减   打印98 --&gt;</span></span><br><span class="line">    $&#123;10/2&#125;</span><br><span class="line">   <span class="comment">&lt;!--  除  打印5 --&gt;</span></span><br><span class="line">    $&#123;10*2&#125;</span><br><span class="line">   <span class="comment">&lt;!--   乘  打印20 --&gt;</span></span><br><span class="line">    $&#123;9%2&#125;</span><br><span class="line">   <span class="comment">&lt;!--   取余  打印1 --&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#assign x2 = 1&gt;</span><br><span class="line">	&lt;#assign x3 = 5&gt;</span><br><span class="line">	&lt;#assign x4 =6&gt;</span><br><span class="line">	&lt;#if (x2&lt;x3) &gt;</span><br><span class="line">		A</span><br><span class="line">	&lt;/#if&gt;</span><br><span class="line"><span class="comment">&lt;!-- 	打印A，注意此处一定要加括号 --&gt;</span></span><br><span class="line">	&lt;#if (x2&gt;x3)&gt;</span><br><span class="line">		B</span><br><span class="line">	&lt;#else&gt;</span><br><span class="line">	    C</span><br><span class="line">	&lt;/#if&gt;</span><br><span class="line"><span class="comment">&lt;!-- 	打印C --&gt;</span></span><br><span class="line">	&lt;#if (x2&gt;x3)&gt;</span><br><span class="line">		A</span><br><span class="line">	&lt;#elseif (x2&gt;x4)&gt;</span><br><span class="line">		B</span><br><span class="line">	&lt;#elseif (x2&lt;x4)&gt;</span><br><span class="line">		C</span><br><span class="line">	&lt;/#if&gt;</span><br><span class="line"><span class="comment">&lt;!-- 	打印C --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#assign x5 =5&gt;</span><br><span class="line">	&lt;#switch x5&gt;</span><br><span class="line">		&lt;#case 10&gt;</span><br><span class="line">		 A</span><br><span class="line">		&lt;#break&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;#case 5&gt;</span><br><span class="line">		 B</span><br><span class="line">		&lt;#break&gt;</span><br><span class="line">		&lt;#default&gt;</span><br><span class="line">		 C</span><br><span class="line">	&lt;/#switch&gt;</span><br><span class="line">  <span class="comment">&lt;!-- 	打印5 --&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><h6 id="List，-Set"><a href="#List，-Set" class="headerlink" title="List， Set"></a>List， Set</h6><p>后台传入一个 userList 的 list 或者 set</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#list userList as user&gt;</span><br><span class="line">  $&#123;user.name&#125;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"><span class="comment">&lt;!--打印出用户名列表--&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><p>map 为后台传入的 Map 集合</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#list map?keys as k&gt;</span><br><span class="line">		$&#123;k&#125;</span><br><span class="line"><span class="comment">&lt;!-- 		键 --&gt;</span></span><br><span class="line">		$&#123;map[k]&#125;</span><br><span class="line"><span class="comment">&lt;!-- 		值 --&gt;</span></span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure>
<h5 id="处理空值"><a href="#处理空值" class="headerlink" title="处理空值"></a>处理空值</h5><blockquote>
<p><strong>可在freemarker.properties中加一句</strong>classic_compatible=true如果对象为空将不会报错</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#if user??&gt;</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 判断user对象是否为空,如果不为空执行if语句中的代码--&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在变量后面加！处理变量值为空的情况--&gt;</span></span><br><span class="line">$&#123;user.name!&#125;</span><br><span class="line"><span class="comment">&lt;!-- 判断name是否为空 如果为空将什么也不显示--&gt;</span></span><br><span class="line">$&#123;(user.name)!&#125;</span><br><span class="line"><span class="comment">&lt;!-- 判断user和name是否都为空，如果有任意一个为空什么都不显示   如果你有多个对象连环调用属性请一定要加()不然freemarker只会判断最后一个变量，否则报错--&gt;</span></span><br><span class="line">$&#123;(user.name)!&quot;您还没有登录&quot;&#125;</span><br><span class="line"><span class="comment">&lt;!-- 如果变量为空的情况下，将显示默认值--&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><h6 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h6><p>userList 为后台传入的对象集合</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#list userList?reverse  as li&gt;</span><br><span class="line">	$&#123;li.name&#125;</span><br><span class="line">	&lt;/#list&gt;</span><br><span class="line">   <span class="comment">&lt;!-- 	 ?reverse      将对象集合顺序反转 --&gt;</span></span><br><span class="line">	</span><br><span class="line">	$&#123;(userList?first).name&#125;</span><br><span class="line">   <span class="comment">&lt;!-- 	 ?first  打印集合中第一个user对象的name --&gt;</span></span><br><span class="line">	 </span><br><span class="line">	$&#123;(userList?last).name&#125;</span><br><span class="line">   <span class="comment">&lt;!-- 	?last      打印集合中最后一个user对象的name --&gt;</span></span><br><span class="line">	</span><br><span class="line">	$&#123;userList?size&#125;</span><br><span class="line">   <span class="comment">&lt;!-- 	?size    打印集合的长度 --&gt;</span></span><br><span class="line">	</span><br><span class="line">	&lt;#list userList?sort  as li&gt;</span><br><span class="line">	$&#123;li.name&#125;</span><br><span class="line">	&lt;/#list&gt;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 	将对象转换为字符串  顺序排序 --&gt;</span></span><br><span class="line">	&lt;#list userList?sort_by(&quot;id&quot;)  as li&gt;</span><br><span class="line">	$&#123;li.name&#125;</span><br><span class="line">	&lt;/#list&gt;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 	将对象中的属性值进行排序, 当前为user中的id排序 --&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$&#123;&quot;string&quot;?substring(0)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 从索引0开始截取字符串  为string --&gt;</span></span><br><span class="line">$&#123;&quot;string&quot;?substring(1)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 从索引1开始截取字符串 为tring --&gt;</span></span><br><span class="line"></span><br><span class="line">$&#123;&quot;string&quot;?substring(0,1)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 从索引0到1截取字符串  为 s --&gt;</span></span><br><span class="line">$&#123;&quot;string&quot;?substring(1,2)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 从索引1到2截取字符串为 t --&gt;</span></span><br><span class="line"></span><br><span class="line">$&#123;&quot;string&quot;?cap_first&#125;</span><br><span class="line"><span class="comment">&lt;!-- 将字符串首字母变为大写  String--&gt;</span></span><br><span class="line">$&#123;&quot;String&quot;?uncap_first&#125;</span><br><span class="line"><span class="comment">&lt;!-- 将字符串首字母变为小写 string--&gt;</span></span><br><span class="line">$&#123;&quot;string&quot;?upper_case&#125;</span><br><span class="line"><span class="comment">&lt;!-- 将字符串全部转换为大写 --&gt;</span></span><br><span class="line">$&#123;&quot;STRINg&quot;?lower_case&#125;</span><br><span class="line"><span class="comment">&lt;!-- 将字符串全部转换为小写 --&gt;</span></span><br><span class="line">$&#123;&quot;2014-11-11 9:0:0&quot;?date(&quot;yyyy-MM-dd&quot;)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 输出为2014-11-11 --&gt;</span></span><br><span class="line">$&#123;&quot;string&quot;?ends_with(&quot;ing&quot;)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 判断字符串 是否已某段字符串结尾               打印true --&gt;</span></span><br><span class="line"></span><br><span class="line">$&#123;&quot;string&quot;?index_of(&quot;tr&quot;)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 	判断某段字符串在一段字符串中出现的索引位置，如果没有返回-1           打印1 --&gt;</span></span><br><span class="line">$&#123;&quot;string&quot;?contains(&#x27;ing&#x27;)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 判断一个字符串中是否包含某段字符串  返回true或false --&gt;</span></span><br><span class="line"></span><br><span class="line">$&#123;&quot;strabgab&quot;?replace(&quot;ab&quot;,&quot;in&quot;)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 将字符串总包含的某段字符串全部替换掉  结果为stringin--&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;#list &quot;this,is,freemaker&quot;?split(&quot;,&quot;) as s&gt;</span><br><span class="line">    $&#123;s&#125;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"><span class="comment">&lt;!-- 使用指定的符号将字符串分割为数组 --&gt;</span></span><br><span class="line">$&#123;&quot;  String       &quot;?trim&#125;</span><br><span class="line"><span class="comment">&lt;!-- 去掉首位空格 --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;#assign num = 1&gt;</span><br><span class="line">$&#123;num?string.number&#125;</span><br><span class="line"><span class="comment">&lt;!-- 转换为数字格式  1 --&gt;</span></span><br><span class="line">$&#123;num?string.currency&#125;</span><br><span class="line"><span class="comment">&lt;!-- 转换为货币格式  ￥1.00 --&gt;</span></span><br><span class="line">$&#123;num?string. percent&#125;</span><br><span class="line"><span class="comment">&lt;!-- 转换为百分比格式 100% --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;#assign flag = true&gt;</span><br><span class="line">$&#123;flag?string(&quot;yes&quot;,&quot;no&quot;)&#125;</span><br><span class="line"><span class="comment">&lt;!-- 根据boolean类型的真假值来输出相应的字符串 --&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title>git-add正则表达式</title>
    <url>/2020/09/15/git-add%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="几个栗子"><a href="#几个栗子" class="headerlink" title="几个栗子"></a>几个栗子</h4><h5 id="从-Docuemnt-目录下或者其子目录下添加所有的-txt-文件"><a href="#从-Docuemnt-目录下或者其子目录下添加所有的-txt-文件" class="headerlink" title="从 Docuemnt 目录下或者其子目录下添加所有的 *.txt 文件"></a>从 <code>Docuemnt</code> 目录下或者其子目录下添加所有的 <code>*.txt</code> 文件</h5><p><code>git add Document/\*.txt</code></p>
<p><strong>在这个栗子中，<code>*</code> 号是被引用的，这可以让命令包含 Document 的子文件夹下的内容</strong></p>
<h5 id="添加所有的-git-sh-文件"><a href="#添加所有的-git-sh-文件" class="headerlink" title="添加所有的 git-*.sh 文件"></a>添加所有的 <code>git-*.sh</code> 文件</h5><p><code>git add git-*.sh</code></p>
<p><strong>上面的栗子不考虑子文件夹下的内容，如 <code>subdir/git-foo.sh</code></strong></p>
<span id="more"></span>
<h5 id><a href="#" class="headerlink" title=" "></a> </h5>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-bisect使用</title>
    <url>/2021/03/25/git-bisect%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><code>git bisect</code>可以通过二分查找的方式来定位引入BUG的提交。</p>
<p>有分为两种定位方法：</p>
<ul>
<li>人工单步定位</li>
<li>自动二分定位</li>
</ul>
<span id="more"></span>
<h4 id="人工单步定位"><a href="#人工单步定位" class="headerlink" title="人工单步定位"></a>人工单步定位</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git bisect start [终点](存在错误的提交) [起点]（好的提交）</span></span><br><span class="line">git bisect start HEAD 4d83cf</span><br><span class="line"><span class="comment"># 上述命令执行之后，代码库会进入中间点的提交，如果正常，执行</span></span><br><span class="line">git bisect good</span><br><span class="line"><span class="comment"># 如果异常，执行</span></span><br><span class="line">git bisect bad</span><br><span class="line"><span class="comment"># 重复指定上述两步的操作，直到只剩最后一次提交</span></span><br><span class="line"><span class="comment"># 退出bisect</span></span><br><span class="line">git bisect reset</span><br></pre></td></tr></table></figure>
<h4 id="自动二分定位"><a href="#自动二分定位" class="headerlink" title="自动二分定位"></a>自动二分定位</h4><p>可以使用<code>git bisect run 脚本</code>来自动判断是正常还是异常。</p>
<p>一个栗子：</p>
<blockquote>
<p>假设判断当前待定位BUG存在的方式是<code>make</code>命令是否执行成功，那么就可以用以下命令来进行自动二分定位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># git bisect start HEAD v1.2 --    &#x2F;&#x2F; 当前HEAD为bad标记，v1.2为good标记  </span><br><span class="line"># git bisect run make              &#x2F;&#x2F; 指定自动二分定位，判断方式：make是否指定成功  </span><br><span class="line"># git bisect reset                 &#x2F;&#x2F; 结果bisect过程</span><br></pre></td></tr></table></figure>
<p><code>git bisect run [cmd]</code>依靠cmd的返回值来判断当前commit对应的是bad commit还是good commit。简单来讲就是返回0表示good，非零表示bad。当然非零具体值也有不同的含义，具体还是仔细看看<code>git bisect --help</code>比较靠谱。</p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-cherry-pick的使用</title>
    <url>/2020/11/10/git-cherry-pick%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>git cherry-pick</code>可以理解为”挑拣”提交，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你的当前分支上。</p>
<p>当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用<code>git cherry-pick</code>了。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git cherry-pick [&lt;options&gt;] &lt;commit-ish&gt;...</span><br><span class="line"></span><br><span class="line">常用options:</span><br><span class="line">    --quit                退出当前的chery-pick序列</span><br><span class="line">    --continue            继续当前的chery-pick序列</span><br><span class="line">    --abort               取消当前的chery-pick序列，恢复当前分支</span><br><span class="line">    -n, --no-commit       不自动提交</span><br><span class="line">    -e, --edit            编辑提交信息</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="转移多个提交"><a href="#转移多个提交" class="headerlink" title="转移多个提交"></a>转移多个提交</h4><p><code>Cherry pick</code> 支持一次转移多个提交</p>
<p><code>$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</code></p>
<p>如果想要转移一系列的连续提交，可以使用以下的简便语法：</p>
<p><code>$ git cherry-pick A..B</code></p>
<p><strong>注意使用上面的命令，提交A将不会包含在 Cherry pick 中。</strong>如果要包含提交A，可以使用下面的语法。</p>
<p><code>$ git cherry-pick A^..B</code></p>
<h4 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h4><p><img src="http://wrr123.github.io/2020/11/10/git-cherry-pick%E7%9A%84%E4%BD%BF%E7%94%A8/001.png" alt></p>
<h4 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h4><p><img src="http://wrr123.github.io/2020/11/10/git-cherry-pick%E7%9A%84%E4%BD%BF%E7%94%A8/002.png" alt></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-log的进阶使用</title>
    <url>/2020/08/07/git-log%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h5 id="查询某次提交是谁提交的"><a href="#查询某次提交是谁提交的" class="headerlink" title="查询某次提交是谁提交的"></a>查询某次提交是谁提交的</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --author=作者名称</span><br></pre></td></tr></table></figure>
<h5 id="搜索提交注释的内容"><a href="#搜索提交注释的内容" class="headerlink" title="搜索提交注释的内容"></a>搜索提交注释的内容</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 支持正则表达式</span></span><br><span class="line">git log --grep &#x27;^exp$&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="在提交的内容当中搜索"><a href="#在提交的内容当中搜索" class="headerlink" title="在提交的内容当中搜索"></a>在提交的内容当中搜索</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log -S &#x27;&#x27;</span><br><span class="line">git log -G &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="指定2天前，作者为“BeginMan”的提交含有关键字’init’的前2条记录："><a href="#指定2天前，作者为“BeginMan”的提交含有关键字’init’的前2条记录：" class="headerlink" title="指定2天前，作者为“BeginMan”的提交含有关键字’init’的前2条记录："></a>指定2天前，作者为“BeginMan”的提交含有关键字’init’的前2条记录：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --since&#x3D;2.days --author&#x3D;BeginMan --grep&#x3D;init -2</span><br></pre></td></tr></table></figure>
<p><strong>注意：上面选项后面的参数可以带单双引号，如<code>--author=&quot;BeginMan&quot;</code></strong></p>
<blockquote>
<ul>
<li>仅显示指定时间之后的提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=2.days</span><br></pre></td></tr></table></figure>
<ul>
<li>仅显示指定时间之前的提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --until=10.days</span><br></pre></td></tr></table></figure>
<ul>
<li>仅显示指定作者相关的提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=BeginMan</span><br></pre></td></tr></table></figure>
<ul>
<li>仅显示指定提交者相关的提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --committer=Jack</span><br></pre></td></tr></table></figure>
<ul>
<li>仅显示指定关键字的提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep=init</span><br></pre></td></tr></table></figure>
<ul>
<li>查找某个字符串在何时添加</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -S<span class="string">&quot;string wanted to search&quot;</span> --oneline</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="一些常用选项及其注释"><a href="#一些常用选项及其注释" class="headerlink" title="一些常用选项及其注释"></a>一些常用选项及其注释</h5><div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr>
<td>—word-diff</td>
<td>按 word diff 格式显示差异。</td>
</tr>
<tr>
<td>—stat</td>
<td>显示每次更新的文件修改统计信息。</td>
</tr>
<tr>
<td>—shortstat</td>
<td>只显示 —stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td>—name-only</td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td>—name-status</td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td>—abbrev-commit</td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr>
<td>—relative-date</td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td>—graph</td>
<td>显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr>
<td>—pretty</td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>版本管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git reset和revert的区别</title>
    <url>/2020/07/03/git-reset%E5%92%8Crevert%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--soft 回退后a分支修改的代码被保留并标记为add的状态（git status 是绿色的状态）</span><br><span class="line">--mixed 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作。</span><br><span class="line">--hard 重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。</span><br><span class="line">--merge 和--hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】</span><br><span class="line">--keep 和--hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git status还是可以看到保持了这些修改。</span><br></pre></td></tr></table></figure>
<h5 id="分析-hard和-soft的区别"><a href="#分析-hard和-soft的区别" class="headerlink" title="分析--hard和--soft的区别"></a>分析<code>--hard</code>和<code>--soft</code>的区别</h5><ul>
<li><blockquote>
<p>soft参数告诉Git重置HEAD到另外一个commit，但也到此为止。如果你指定—soft参数，Git将停止在那里而什么也不会根本变化。这意味着index,working copy都不会做任何变化，所有的在original HEAD和你重置到的那个commit之间的所有变更集都放在stage(index)区域中。</p>
</blockquote>
</li>
<li><blockquote>
<p>hard参数将会blow out everything.它将重置HEAD返回到另外一个commit(取决于~12的参数），重置index以便反映HEAD的变化，并且重置working copy也使得其完全匹配起来。这是一个比较危险的动作，具有破坏性，数据因此可能会丢失！如果真是发生了数据丢失又希望找回来，那么只有使用：[git reflog]命令了。你的所有本地修改将丢失。如果我们希望彻底丢掉本地修改但是又不希望更改branch所指向的commit，则执行git reset —hard = git reset —hard HEAD. i.e. don’t change the branch but get rid of all local changes.另外一个场景是简单地移动branch从一个到另一个commit而保持index/work区域同步。不过它将修改你的work tree。<br> 这是说hard操作就是以commit合集中的某一元素作为head 的落脚点，并且以它为蓝本，毁掉暂存区记录，本地库和远程库记录，包括源文件，只是为了这一蓝本服务，就好像议会制国家里，轮流执政，突然其中一个议员搞成了中央集权，所有的都向他同化了。</p>
</blockquote>
</li>
<li><blockquote>
<p>mixed是reset的默认参数，也就是当你不指定任何参数时的参数。它将重置HEAD到另外一个commit,并且重置index以便和HEAD相匹配，但是也到此为止。working copy不会被更改。所有该branch上从original HEAD（commit）到你重置到的那个commit之间的所有变更将作为local modifications保存在working area中，（被标示为local modification or untracked via git status)，但是并未staged的状态，你可以重新检视然后再做修改和commit。</p>
</blockquote>
</li>
</ul>
<h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>git revert是用一次新的commit来回滚之前的commit；</p>
<p>git reset是直接删除指定的commit。</p>
</li>
<li><p>git reset是把<code>head</code>向后移动了一下，而git revert是<code>head</code>继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</p>
</li>
<li><blockquote>
<p>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>版本管理工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitee配置ssh公匙</title>
    <url>/2021/03/29/gitee%E9%85%8D%E7%BD%AEssh%E5%85%AC%E5%8C%99/</url>
    <content><![CDATA[<p>从github仓库或者gitee仓库拉取代码时，我们既可以通过HTTP的方式，也可以通过SSH的方式。</p>
<p>HTTP可能比较方便，但是SSH的方式安全性比较高。</p>
<p>使用Jenkins自动部署时，需要用到SSH的方式拉取部署代码。</p>
<span id="more"></span>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>创建公匙</p>
<p>进入用户目录下的<code>.ssh</code>目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment"># 如果.ssh目录不存在，则自行创建</span></span><br><span class="line">mkdir ~/.ssh</span><br></pre></td></tr></table></figure>
<p>输入以下命令生成<strong>密匙对</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;邮箱地址&#39;</span><br></pre></td></tr></table></figure>
<p>在命令行提示下，你可以修改公匙存储文件的名称。</p>
</li>
<li><p>添加公匙</p>
<p>进入你的Gitee网站，在 <strong>设置</strong> - <strong>安全设置</strong> 下，找到 <strong>SSH密匙</strong>，添加密匙。</p>
<p>密匙内容为上面生成的文件<code>id_rsa_*.pub</code>的内容。一般以 <strong>ssh-rsa</strong> 开头。</p>
</li>
<li><p>测试连接</p>
<p>打开命令窗口，输入以下的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>其它说明</p>
</li>
</ol>
<h4 id="查看某个ip地址的端口是否连接着"><a href="#查看某个ip地址的端口是否连接着" class="headerlink" title="查看某个ip地址的端口是否连接着"></a>查看某个ip地址的端口是否连接着</h4><p>使用 <strong>telnet</strong> 命令。</p>
<p><code>telnet ip port</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>git常见命令的基本使用</title>
    <url>/2020/08/05/git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="git-restore命令的使用"><a href="#git-restore命令的使用" class="headerlink" title="git-restore命令的使用"></a>git-restore命令的使用</h4><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. take a file out of another commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. restore hello.c from the index</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git restore --<span class="built_in">source</span> master~2 Makefile  (1)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -f hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git restore hello.c                     (2)</span></span><br></pre></td></tr></table></figure>
<h5 id="git-restore-lt-file-gt-和git-restore-staged的区别"><a href="#git-restore-lt-file-gt-和git-restore-staged的区别" class="headerlink" title="git restore &lt;file&gt;和git restore --staged的区别"></a><code>git restore &lt;file&gt;</code>和<code>git restore --staged</code>的区别</h5><ul>
<li><code>git store</code> 将不再暂存区的文件撤销更改</li>
<li><code>git restore --staged</code> 将文件从暂存区撤出，<strong>但不会撤销文件的更改</strong></li>
</ul>
<h5 id="使用-source参数将文件恢复到和某一次的提交一样"><a href="#使用-source参数将文件恢复到和某一次的提交一样" class="headerlink" title="使用--source参数将文件恢复到和某一次的提交一样"></a>使用<code>--source</code>参数将文件恢复到和某一次的提交一样</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在工作副本和索引中的内容都与三次提交之前相同</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git restore --<span class="built_in">source</span> HEAD~3 --staged --worktree main.c</span></span><br></pre></td></tr></table></figure>
<h4 id="将文件还原到某个版本"><a href="#将文件还原到某个版本" class="headerlink" title="将文件还原到某个版本"></a>将文件还原到某个版本</h4><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"> 找到文件需要回滚到的版本号(如 cf7a7a38)</span><br><span class="line">git log package-lock.json</span><br><span class="line"><span class="meta">$</span><span class="bash"> git update-index --assume-unchanged fileName</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 利用 checkout 命令即可</span></span><br><span class="line">git checkout cf7a7a38 package-lock.json</span><br></pre></td></tr></table></figure>
<h4 id="git-忽略已经提交过的文件"><a href="#git-忽略已经提交过的文件" class="headerlink" title="git 忽略已经提交过的文件"></a>git 忽略已经提交过的文件</h4><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git update-index --assume-unchanged fileName</span></span><br></pre></td></tr></table></figure>
<h4 id="git-tag-打标签"><a href="#git-tag-打标签" class="headerlink" title="git tag 打标签"></a>git tag 打标签</h4><h5 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h5><p><code>git tag &lt;-l&gt; &lt;--list&gt;</code></p>
<blockquote>
<p> <strong>注意：</strong>按照通配符列出标签需要 <code>-l</code> 或 <code>--list</code> 选项</p>
<p>如果你只想要完整的标签列表，那么运行 <code>git tag</code> 就会默认假定你想要一个列表，它会直接给你列出来， 此时的 <code>-l</code> 或 <code>--list</code> 是可选的。</p>
<p>然而，如果你提供了一个匹配标签名的通配模式，那么 <code>-l</code> 或 <code>--list</code> 就是强制使用的。</p>
</blockquote>
<h5 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h5><ol>
<li><p>轻量标签</p>
<p> 一个栗子：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure>
</li>
<li><p>附注标签</p>
<p> 一个栗子：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.4 -m <span class="string">&quot;my version 1.4&quot;</span></span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h5><p><code>$ git tag -a v1.2 9fceb02</code></p>
<h5 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">Counting objects: 14, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure>
<p>若想要一次性推送多个标签，可以使用<code>--tags</code>选项</p>
<p>一个栗子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure>
<h5 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h5><p>删除本地仓库上的标签 git tag -d <tagname></tagname></p>
<p>一个删除轻量标签的栗子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag -d v1.4-lw</span><br><span class="line">Deleted tag <span class="string">&#x27;v1.4-lw&#x27;</span> (was e7d5add)</span><br></pre></td></tr></table></figure>
<p>删除远程仓库的标签</p>
<p>第一种方法</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v1.4-lw</span><br><span class="line">To /git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         v1.4-lw</span><br></pre></td></tr></table></figure>
<p>第二种方法</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure>
<h5 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h5><p>一个栗子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout -b version2 v2.0.0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>版本工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git远程分支创建</title>
    <url>/2020/07/07/git%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="新建远程分支"><a href="#新建远程分支" class="headerlink" title="新建远程分支"></a>新建远程分支</h4><ul>
<li><p>新建一个本地分支dev,并切换到dev分支</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 假设在master分支</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地分支dev推送到远程服务器，远程分支和本地分支同名（也是可以不同名的）</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin dev:dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个dev是本地分支名，第二个dev是远程分支名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地分支dev和远程分支origin/dev之间建立追踪关系</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git branch -u origin/dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地分支和远程分支的映射关系取消</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout dev <span class="comment"># 先切换到需要取消映射的本地分支</span></span><br><span class="line">git branch --unset-upstream</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git push origin :dev #origin后面不添加分支名，即可删除远程分支</span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line">git push origin --delete dev</span><br></pre></td></tr></table></figure>
<h5 id="查看本地分支和远程分支的映射关系"><a href="#查看本地分支和远程分支的映射关系" class="headerlink" title="查看本地分支和远程分支的映射关系"></a>查看本地分支和远程分支的映射关系</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -vv	</span><br></pre></td></tr></table></figure>
<h4 id="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"><a href="#将远程git仓库里的指定分支拉取到本地（本地不存在的分支）" class="headerlink" title="将远程git仓库里的指定分支拉取到本地（本地不存在的分支）"></a>将远程git仓库里的指定分支拉取到本地（本地不存在的分支）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch origin 远程分支名x:本地分支名x</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>采用此种方法建立的本地分支不会和远程分支建立映射关系。</p>
</blockquote>
<h4 id="分支origin-HEAD的作用"><a href="#分支origin-HEAD的作用" class="headerlink" title="分支origin/HEAD的作用"></a>分支origin/HEAD的作用</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">remotes/origin/dev</span><br></pre></td></tr></table></figure>
<p>origin/HEAD就像一个指针，表示默认分支，如上面的例子就是指向<code>origin/master</code>,即<code>origin/master</code>是默认分支。</p>
<blockquote>
<p>删掉也是可以的：$ git remote set-head origin -d 这样就移除了 origin/HEAD -&gt; origin/master 这一行。</p>
</blockquote>
]]></content>
      <categories>
        <category>版本管理工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git项目打包</title>
    <url>/2020/07/24/git%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h4 id="git-archive"><a href="#git-archive" class="headerlink" title="git archive"></a>git archive</h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>git archive -o 打包文件路径 HEAD $(git diff --name-only commitId)</code></p>
<h5 id="打包master分支下的所有文件"><a href="#打包master分支下的所有文件" class="headerlink" title="打包master分支下的所有文件"></a>打包master分支下的所有文件</h5><p><code>git archive --format=zip --output master.zip master</code></p>
<h5 id="打包当前分支当前HEAD的所有文件"><a href="#打包当前分支当前HEAD的所有文件" class="headerlink" title="打包当前分支当前HEAD的所有文件"></a>打包当前分支当前HEAD的所有文件</h5><p><code>git archive --format=zip --output head.zip HEAD</code></p>
<h5 id="打包v1-3标签下的所有文件"><a href="#打包v1-3标签下的所有文件" class="headerlink" title="打包v1.3标签下的所有文件"></a>打包v1.3标签下的所有文件</h5><p><code>git archive --format=zip --output v1.3.zip v1.3</code></p>
<h5 id="打包更改的文件"><a href="#打包更改的文件" class="headerlink" title="打包更改的文件"></a>打包更改的文件</h5><p>打包更改的基本原理：</p>
<ol>
<li>用<code>git diff</code>找出文件列表；</li>
<li>用<code>git archive</code>打包命令打包</li>
</ol>
<h6 id="打包最后修改的文件"><a href="#打包最后修改的文件" class="headerlink" title="打包最后修改的文件"></a>打包最后修改的文件</h6><p><code>git archive --format=zip -o update.zip HEAD $(git diff --name-only HEAD^)</code></p>
<h6 id="打包最后两个版本修改的文件"><a href="#打包最后两个版本修改的文件" class="headerlink" title="打包最后两个版本修改的文件"></a>打包最后两个版本修改的文件</h6><p><code>git archive --format=zip -o update.zip HEAD $(git diff --name-only HEAD~2)</code></p>
<h6 id="打包两个分支（master，-fix-error）之间差别的文件"><a href="#打包两个分支（master，-fix-error）之间差别的文件" class="headerlink" title="打包两个分支（master， fix-error）之间差别的文件"></a>打包两个分支（master， fix-error）之间差别的文件</h6><p><code>git archive [--format=zip] -o update.zip HEAD $(git diff --name-only master fix-error)</code></p>
<p>​    </p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle</title>
    <url>/2020/08/18/gradle/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Gradle，这是一个基于 JVM 的富有突破性的构建工具。</p>
<p>Gradle 正迅速成为许多开源项目和前沿企业构建系统的选择，同时也在挑战遗留的自动化构建工具。</p>
<h4 id="特性说明"><a href="#特性说明" class="headerlink" title="特性说明"></a>特性说明</h4><h5 id="基于声明的构建和基于约定的构建"><a href="#基于声明的构建和基于约定的构建" class="headerlink" title="基于声明的构建和基于约定的构建"></a>基于声明的构建和基于约定的构建</h5><p>gradle 的核心在于基于 Groovy 的丰富而可扩展的域描述语言(DSL)。Groovy 通过声明性的语言元素将基于声明的构建推向下层，你可以按你想要的方式进行组合。这些元素同样也为支持 Java，Groovy，OSGI，Web 和 Scala 项目提供了基于约定的构建；并且，这种声明性的语言是可以扩展的。你可以添加新的或者增强现有的语言元素。因此，它提供了简明、可维护和易理解的构建。</p>
<h5 id="为以依赖为基础的编程方式提供语言支持"><a href="#为以依赖为基础的编程方式提供语言支持" class="headerlink" title="为以依赖为基础的编程方式提供语言支持"></a>为以依赖为基础的编程方式提供语言支持</h5><p>声明性语言优点在于通用任务图，你可以将其充分利用在构建中，它提供了最大限度的灵活性，以让 Gradle 适应你的特殊需求。</p>
<span id="more"></span>
<h5 id="构建结构化"><a href="#构建结构化" class="headerlink" title="构建结构化"></a>构建结构化</h5><p>Gradle 的灵活和丰富性最终能够支持在你的构建中应用通用的设计模式。</p>
<p>例如，它可以很容易地将你的构建拆分为多个可重用的模块，最后再进行组装，但不要强制地进行模块的拆分。不要把原本在一起的东西强行分开(比如在你的项目结构里)，从而避免让你的构建变成一场噩梦。最后，你可以创建一个结构良好，易于维护，易于理解的构建。</p>
<h4 id="groovy-语言的快速入门"><a href="#groovy-语言的快速入门" class="headerlink" title="groovy 语言的快速入门"></a>groovy 语言的快速入门</h4><h5 id="与-java-的一些区别"><a href="#与-java-的一些区别" class="headerlink" title="与 java 的一些区别"></a>与 java 的一些区别</h5><ul>
<li><p>默认导入</p>
<p>  Groovy 会默认导入下面这些包、类，不需要使用 <code>import</code> 语句显示导入。</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">java.io.*</span><br><span class="line">java.lang.*</span><br><span class="line">java.math.BigDecimal</span><br><span class="line">java.math.BigInteger</span><br><span class="line">java.net.*</span><br><span class="line">java.util.*</span><br><span class="line">groovy.lang.*</span><br><span class="line">groovy.util.*</span><br></pre></td></tr></table></figure>
</li>
<li><p>多重方法</p>
<p>  在 Groovy 中，调用的方法将在运行时被选择。这种机制被称为运行时分派或多重方法（multi-methods），是根据运行时实参（argument）的类型来选择方法。Java 采用的是相反的策略：<strong>编译时根据声明的类型来选择方法。</strong></p>
<p>  一个栗子：</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> method(String arg) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> method(Object arg) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object o = <span class="string">&quot;Object&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> result = method(o);</span><br><span class="line"><span class="comment">// In Java</span></span><br><span class="line">assertEquals(<span class="number">2</span>, result);</span><br><span class="line"><span class="comment">// In Groovy</span></span><br><span class="line">assertEquals(<span class="number">1</span>, result);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组初始化语法</p>
<p>  在 groovy 中，<code>&#123;...&#125;</code> 语句块是留给 <strong>闭包（closure）</strong> 使用的，所以不能像 Java 一样使用下面的方式来初始化数组。</p>
<p>  <code>int[] array = &#123;1, 2, 3, 4&#125;</code></p>
<p>  而应该是这样</p>
<p>  <code>int[] array = [1, 2, 3, 4]</code></p>
</li>
<li><p>POJO</p>
<p>  Groovy 默认会隐式的创建 getter、setter 方法，并且会提供带参的构造器，下面的两者是同价的：</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setName(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In Groovy</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> person = <span class="keyword">new</span> Person(<span class="attr">name:</span> <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">&#x27;张三&#x27;</span> == person.name</span><br><span class="line">person.name = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="comment">//person.setName(&#x27;李四&#x27;)</span></span><br><span class="line"><span class="keyword">assert</span> <span class="string">&#x27;李四&#x27;</span> == person.getName()</span><br></pre></td></tr></table></figure>
</li>
<li><p>包访问权限</p>
<p>  在 java 中如果没有显式的指定访问修饰符(public, protected, private), 那么默认是包访问权限，但在 Groovy 中默认是 <code>public</code> 的，所以需要使用 <code>@PackageScope</code> 注解</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="meta">@PackageScope</span> String name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ARM 语句块</p>
<p>  ARM（ Automatic Resource Management, 自动资源管理）语句块（或者叫 TWR 语法）从 Java7 开始引入，用于降低 IO 操作代码的复杂度，但 Groovy 并不支持。相反，Groovy 提供多种基于闭包的方法，不但可以达到同样的效果并且更加简洁优美。</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Groovy</span></span><br><span class="line">Path file = Paths.get(<span class="string">&quot;/User/lihengming/test.txt&quot;</span>);</span><br><span class="line">Charset charset = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (BufferedReader reader = Files.newBufferedReader(file, charset)) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Groovy</span></span><br><span class="line"><span class="keyword">new</span> File(<span class="string">&#x27;/User/lihengming/test.txt&#x27;</span>).eachLine(<span class="string">&#x27;UTF-8&#x27;</span>) &#123;</span><br><span class="line">   println it</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者这样，更接近于Java的方式</span></span><br><span class="line"><span class="keyword">new</span> File(<span class="string">&#x27;/User/lihengming/test.txt&#x27;</span>).withReader(<span class="string">&#x27;UTF-8&#x27;</span>) &#123; reader -&gt;</span><br><span class="line">   reader.eachLine &#123;</span><br><span class="line">       println it</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果只是为了读取并打印出文本的内容的话，下面是最简洁的方式</span></span><br><span class="line">print <span class="keyword">new</span> File(<span class="string">&#x27;/User/lihengming/test.txt&#x27;</span>).text</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类</p>
<p>  Groovy 同样支持内部类并且实现跟 Java 一样，</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A.B()</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">CountDownLatch called = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer()</span><br><span class="line">timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="keyword">void</span> run() &#123;</span><br><span class="line">        called.countDown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> called.await(<span class="number">10</span>, TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda 表达式</p>
<p>  Java8 支持 Lambda 表达式和方法引用</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable run = () -&gt; System.out.println(<span class="string">&quot;Run&quot;</span>);</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>  Java8 的 Lambda 表达式几乎都可以匿名内部类。Groovy 并没有采用这种语法，而采用闭包来实现。</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Runnable run = &#123; println <span class="string">&#x27;run&#x27;</span> &#125;</span><br><span class="line">list.each &#123; println it &#125; <span class="comment">// or list.each(this.&amp;println)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>GString</p>
<p>  由于双引号所包括起来的字符串字面量会被解释为 GString 值（即 “Groovy 字符串”的简称），所以如果当某个类中的 String 字面量含有美元字符（$）时，那么利用 Groovy 和 Java 编译器进行编译时，Groovy 很可能会编译失败，或者产生和 Java 编译所不同的结果。</p>
<p>  通常，如果某个 API 声明了形参的类型，Groovy 会自动转换 GString 和 String。要小心那些形参为 Object 的 Java API，需要检查它们的实际类型。</p>
</li>
<li><p>字符串和字符字面量</p>
<p>  在 Groovy 中，由单引号所创建的字面量属于 string 类型对象，而双引号创建的字面量则可能是 string 或 GString 对象，具体分类由字面量中是否有插值来决定。</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="string">&#x27;c&#x27;</span>.getClass()==String</span><br><span class="line"><span class="keyword">assert</span> <span class="string">&quot;c&quot;</span>.getClass()==String</span><br><span class="line"><span class="keyword">assert</span> <span class="string">&quot;c$&#123;1&#125;&quot;</span>.getClass() <span class="keyword">in</span> GString  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h5><ul>
<li>Groovy 语句无需使用分号（<code>;</code>）结尾，当然加上也不会报错，毕竟完美兼容 java 的语法。</li>
<li>groovy 中 <code>==</code> 等价于 Java 中的 <code>equals</code> 方法</li>
</ul>
<h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><p>注释和 Java 一样，支持单行(<code>//</code>) 、多行（<code>/* */</code>）和文档注释（<code>/** */</code>）。</p>
<blockquote>
<p>除此之外还支持 Shebang line（UNIX系统支持一种特殊的单行注释叫作 Shebang line，用于指明脚本的运行环境，便于在终端中可以直接运行）#号必须是文件的第一个字符。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line">println <span class="string">&quot;Hello from the shebang line&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h6><blockquote>
<p>Groovy 中定义变量默认访问修饰符是<code>public</code>，变量定义时遵循 Java 变量命名规范，变量名以字母、下划线或美元符号$开始，可以包含字母、数字、下划线和美元符号$，但关键字除外。除了这些规则之外，Groovy 定义变量时如果是一行定义一个类型，末尾的分号可以省略，但是如果多个变量占一行，变量之间必须以分号分割。</p>
<p>Groovy 定义变量的方式和 Java 是类似的，区别在于 Groovy 提供了<code>def</code>关键字供使用，它可以省略变量类型的定义，根据变量的值进行类型推导。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">def</span> b = <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">def</span> c = <span class="literal">true</span> </span><br><span class="line"><span class="keyword">boolean</span> d = <span class="literal">false</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>如果定义变量的字面量值为数字时，类型会根据数字的大小自动调整</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> a <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">def</span> b = <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">assert</span> b <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MAX_VALUE + 1</span></span><br><span class="line"><span class="keyword">def</span> c = <span class="number">2147483648</span></span><br><span class="line"><span class="keyword">assert</span> c <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MAX_VALUE</span></span><br><span class="line"><span class="keyword">def</span> d = <span class="number">9223372036854775807</span></span><br><span class="line"><span class="keyword">assert</span> d <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MAX_VALUE + 1</span></span><br><span class="line"><span class="keyword">def</span> e = <span class="number">9223372036854775808</span></span><br><span class="line"><span class="keyword">assert</span> e <span class="keyword">instanceof</span> BigInteger</span><br></pre></td></tr></table></figure>
<p>对于浮点型字面量为了精度 Groovy 默认使用的类型为 BigDecimal</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> decimal = <span class="number">123.456</span></span><br><span class="line">println decimal.getClass() <span class="comment">// class java.math.BigDecimal</span></span><br></pre></td></tr></table></figure>
<p>Groovy为 数字类型提供一种更简单的声明类型的方式：类型后缀</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- Integer 使用I或i</span><br><span class="line">- Long 使用L或l</span><br><span class="line">- BigInteger 使用G或g</span><br><span class="line">- BigDecimal 使用G或g</span><br><span class="line">- Double 使用D或d</span><br><span class="line">- Float 使用F或f</span><br></pre></td></tr></table></figure>
<p>一个栗子：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="number">123</span>I</span><br><span class="line"><span class="keyword">assert</span> a <span class="keyword">instanceof</span> Integer</span><br><span class="line"><span class="keyword">def</span> b= <span class="number">123</span>L</span><br><span class="line"><span class="keyword">assert</span> b <span class="keyword">instanceof</span> Long</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><blockquote>
<p>在Groovy种有两种字符串类型，普通字符串（<code>java.lang.String</code>）和插值字符串（<code>groovy.lang.GString</code>）。<br>普通字符串使用单引号</p>
<p><code>println &#39;hello&#39;</code></p>
<p>插值字符串使用双引号</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">println <span class="string">&quot;hello $name&quot;</span></span><br></pre></td></tr></table></figure>
<p>除此之外，还支持三单引号的写法，可以保留文本的换行及缩进格式</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> strippedFirstNewline = <span class="string">&#x27;&#x27;&#x27;line one</span></span><br><span class="line"><span class="string">        line two</span></span><br><span class="line"><span class="string">            line three</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">println strippedFirstNewline</span><br><span class="line"><span class="comment">// 可以写成下面这种形式，可读性更好</span></span><br><span class="line"><span class="keyword">def</span> strippedFirstNewline2 = <span class="string">&#x27;&#x27;&#x27;\</span></span><br><span class="line"><span class="string">line one</span></span><br><span class="line"><span class="string">    line two</span></span><br><span class="line"><span class="string">line three</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">println strippedFirstNewline2</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h6><blockquote>
<p>在 Groovy 中并没有明确的字符字面量表示形式，需要显示的指定，有三种方式</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span> <span class="comment">// 声明类型</span></span><br><span class="line"><span class="keyword">assert</span> c1 <span class="keyword">instanceof</span> Character</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> c2 = <span class="string">&#x27;B&#x27;</span> <span class="keyword">as</span> <span class="keyword">char</span> <span class="comment">// 用as关键字</span></span><br><span class="line"><span class="keyword">assert</span> c2 <span class="keyword">instanceof</span> Character</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> c3 = (<span class="keyword">char</span>) <span class="string">&#x27;C&#x27;</span> <span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="keyword">assert</span> c3 <span class="keyword">instanceof</span> Character</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h6><blockquote>
<p>Groovy 方法的默认访问修饰符是<code>public</code>，方法的返回类型可以不需要声明，但需添加<code>def</code>关键字。有返回值的方法<code>return</code>可以被省略，默认返回最后一行代码的运行结果，如果使用了<code>return</code>关键字则返回指定的返回值。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">String method1() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> method1() == <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> method2() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> method2() == <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> method3() &#123;</span><br><span class="line">    <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> method3() == <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>Groovy 方法的参数类型可以被省略，默认为Object类型。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与上面的等价</span></span><br><span class="line"><span class="keyword">def</span> add(a, b) &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Groovy 方法的其他特性与Java一样，比如支持重载、不定长参数（…）等。</p>
</blockquote>
<h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><blockquote>
<p>Groovy 提供了闭包的支持，语法和 Lambda 表达式有些类似，简单来说就是一段可执行的代码块或函数指针。闭包在 Groovy 中是<code>groovy.lang.Closure</code>类的实例，这使得闭包可以赋值给变量，或者作为参数传递。Groovy 定义闭包的语法很简单，就像下面这样。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//闭包的参数为可选项</span></span><br><span class="line"><span class="keyword">def</span> closure = &#123; [closureParameters -&gt; ] statements &#125;</span><br></pre></td></tr></table></figure>
<p>闭包可以访问外部变量，而方法（函数）则不能。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">def</span> closure=&#123;</span><br><span class="line">    println str</span><br><span class="line">&#125;</span><br><span class="line">closure()<span class="comment">//hello </span></span><br></pre></td></tr></table></figure>
<p>闭包调用的方式有两种，闭包.call(参数)或者闭包(参数)，在调用的时候可以省略圆括号。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> closure = &#123;</span><br><span class="line">    param -&gt; println param</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">closure(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">closure.call(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">closure <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p>闭包的参数是可选的，如果没有参数的话可以省略<code>-&gt;</code>操作符。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> closure = &#123;println <span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line">closure()</span><br></pre></td></tr></table></figure>
<p>多个参数以逗号分隔，参数类型和方法一样可以显式声明也可省略。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> closure = &#123; String x, <span class="keyword">int</span> y -&gt;                                </span><br><span class="line">    println <span class="string">&quot;hey $&#123;x&#125; the value is $&#123;y&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个参数的话，也可省略参数的定义，Groovy提供了一个隐式的参数<code>it</code>来替代它</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> closure = &#123; it -&gt; println it &#125; </span><br><span class="line"><span class="comment">//和上面是等价的</span></span><br><span class="line"><span class="keyword">def</span> closure = &#123; println it &#125;   </span><br><span class="line">closure(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>闭包可以作为参数传入，闭包作为方法的唯一参数或最后一个参数时可省略括号。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> eachLine(lines, closure) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String <span class="attr">line :</span> lines) &#123;</span><br><span class="line">        closure(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eachLine(<span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>,&#123; println it &#125;) </span><br><span class="line"><span class="comment">//可省略括号，与上面等价</span></span><br><span class="line">eachLine(<span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>) &#123; println it &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h6><blockquote>
<p>Groovy 定义 List 的方式非常简洁，使用中括号(<code>[]</code>)，以逗号(<code>,</code>)分隔元素即可。Groovy中的 List 其实就是<code>java.util.List</code>，实现类默认使用的是<code>java.util.ArrayList</code>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]         </span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> numbers <span class="keyword">instanceof</span> List  </span><br><span class="line"><span class="keyword">assert</span> numbers.<span class="keyword">class</span> == java.util.ArrayList  </span><br><span class="line"><span class="keyword">assert</span> numbers.size() == <span class="number">3</span> </span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h6><blockquote>
<p>Groovy 定义数组的语法和 List 非常类似，区别在于数组的定义必须指定类型为数组类型，可以直接定义类型或者使用def定义然后通过as关键字来指定其类型</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">String[] arrStr = [<span class="string">&#x27;Ananas&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Kiwi&#x27;</span>] <span class="comment">//直接声明类型为数组类型  String[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> arrStr <span class="keyword">instanceof</span> String[]    </span><br><span class="line"><span class="keyword">assert</span> !(arrStr <span class="keyword">instanceof</span> List)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> numArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">int</span>[]     <span class="comment">//痛过as关键字指定类型为数组类型 int[] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> numArr <span class="keyword">instanceof</span> <span class="keyword">int</span>[]       </span><br><span class="line"><span class="keyword">assert</span> numArr.size() == <span class="number">3</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h6><blockquote>
<p>Groovy 定义 Map 的方式非常简洁，通过中括号包含key、val的形式，key和value以冒号分隔(<code>[key:value]</code>)。Groovy中的Map其实就是<code>java.util.Map</code>，实现类默认使用的是<code>java.util.LinkedHashMap</code>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key虽然没有加引号，不过Groovy会默认将其转换为字符串</span></span><br><span class="line"><span class="keyword">def</span> colors = [<span class="attr">red:</span> <span class="string">&#x27;#FF0000&#x27;</span>, <span class="attr">green:</span> <span class="string">&#x27;#00FF00&#x27;</span>, <span class="attr">blue:</span> <span class="string">&#x27;#0000FF&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> colors[<span class="string">&#x27;red&#x27;</span>] == <span class="string">&#x27;#FF0000&#x27;</span> <span class="comment">// 使用中括号访问</span></span><br><span class="line"><span class="keyword">assert</span> colors.green == <span class="string">&#x27;#00FF00&#x27;</span> <span class="comment">// 使用点表达式访问</span></span><br><span class="line"></span><br><span class="line">colors[<span class="string">&#x27;pink&#x27;</span>] = <span class="string">&#x27;#FF00FF&#x27;</span> <span class="comment">// 使用中括号添加元素，相当于Java Map 的 put(key,value)方法</span></span><br><span class="line">colors.yellow = <span class="string">&#x27;#FFFF00&#x27;</span><span class="comment">// 使用点表达式添加元素</span></span><br><span class="line"><span class="keyword">assert</span> colors.pink == <span class="string">&#x27;#FF00FF&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> colors[<span class="string">&#x27;yellow&#x27;</span>] == <span class="string">&#x27;#FFFF00&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> colors <span class="keyword">instanceof</span> java.util.LinkedHashMap <span class="comment">// 默认使用LinkedHashMap类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Groovy Map的key默认语法不支持变量，这里的key时间上是字符串&#x27;keyVal&#x27;而不是keyVal变量的值&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">def</span> keyVal = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">def</span> persons = [<span class="attr">keyVal:</span> <span class="string">&#x27;Guillaume&#x27;</span>] </span><br><span class="line"><span class="keyword">assert</span> !persons.containsKey(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> persons.containsKey(<span class="string">&#x27;keyVal&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//要使用变量作为key，需要使用括号</span></span><br><span class="line"><span class="keyword">def</span> keyVal = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">def</span> persons = [(keyVal): <span class="string">&#x27;Guillaume&#x27;</span>] </span><br><span class="line"><span class="keyword">assert</span> persons.containsKey(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> !persons.containsKey(<span class="string">&#x27;keyVal&#x27;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h6><blockquote>
<p>在 Groovy 中可以使用<code>..</code>操作符来定义一个区间对象，简化范围操作的代码。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> range = <span class="number">0.</span><span class="number">.5</span></span><br><span class="line"><span class="keyword">assert</span> (<span class="number">0.</span><span class="number">.5</span>).collect() == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">assert</span> (<span class="number">0.</span>.&lt;<span class="number">5</span>).collect() == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="comment">// 相当于左闭右开区间</span></span><br><span class="line"><span class="keyword">assert</span> (<span class="number">0.</span><span class="number">.5</span>) <span class="keyword">instanceof</span> List <span class="comment">// Range实际上是List接口的实现</span></span><br><span class="line"><span class="keyword">assert</span> (<span class="number">0.</span><span class="number">.5</span>).size() == <span class="number">6</span></span><br><span class="line"><span class="keyword">assert</span> (<span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;d&#x27;</span>).collect() == [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]<span class="comment">//也可以是字符类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常见使用场景</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">    println x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;z&#x27;</span>).each &#123;</span><br><span class="line">    println it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (age) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0.</span><span class="number">.17</span>:</span><br><span class="line">        println <span class="string">&#x27;未成年&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">18.</span><span class="number">.30</span>:</span><br><span class="line">        println <span class="string">&#x27;青年&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">31.</span><span class="number">.50</span>:</span><br><span class="line">        println <span class="string">&#x27;中年&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="symbol">default:</span></span><br><span class="line">        println <span class="string">&#x27;老年&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="将-maven-项目转换为-gradle-项目"><a href="#将-maven-项目转换为-gradle-项目" class="headerlink" title="将 maven 项目转换为 gradle 项目"></a>将 maven 项目转换为 gradle 项目</h4><p>在项目根目录下执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gradle init --<span class="built_in">type</span> pom</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp</title>
    <url>/2020/08/25/gulp/</url>
    <content><![CDATA[<h4 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h4><p><strong>Builds can be the most awful sinkhole for terms to waste their time with - gulp is a serious win for any project.</strong></p>
<p><strong>gulp</strong> 将开发流程中让人痛苦或耗时的任务自动化，从而减少你所浪费的时间、创造更大的价值。</p>
<p>特点：</p>
<ol>
<li><p><strong>简单</strong></p>
<p>代码优于配置、node 最佳实践、精简的 API 集，gulp 让工具前所未有的简单。</p>
</li>
<li><p><strong>高效</strong></p>
<p>基于 node 强大的流（stream）能力，gulp 在构建过程中并不把文件立即写入磁盘，从而提高了构建速度。</p>
</li>
<li><p><strong>生态</strong></p>
<p>遵循严格的准则，确保我们的插件结构简单、运行结果可控。</p>
</li>
</ol>
<span id="more"></span>
<h5 id="官网的一个-gulpfile-js-文件"><a href="#官网的一个-gulpfile-js-文件" class="headerlink" title="官网的一个 gulpfile.js 文件"></a>官网的一个 gulpfile.js 文件</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest, parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pug = <span class="built_in">require</span>(<span class="string">&#x27;gulp-pug&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> minifyCSS = <span class="built_in">require</span>(<span class="string">&#x27;gulp-csso&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> concat = <span class="built_in">require</span>(<span class="string">&#x27;gulp-concat&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">html</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">&#x27;client/templates/*.pug&#x27;</span>)</span><br><span class="line">    .pipe(pug())</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;build/html&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">&#x27;client/templates/*.less&#x27;</span>)</span><br><span class="line">    .pipe(less())</span><br><span class="line">    .pipe(minifyCSS())</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;build/css&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">js</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">&#x27;client/javascript/*.js&#x27;</span>, &#123; <span class="attr">sourcemaps</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .pipe(concat(<span class="string">&#x27;app.min.js&#x27;</span>))</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;build/js&#x27;</span>, &#123; <span class="attr">sourcemaps</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.js = js;</span><br><span class="line"><span class="built_in">exports</span>.css = css;</span><br><span class="line"><span class="built_in">exports</span>.html = html;</span><br><span class="line"><span class="built_in">exports</span>.default = parallel(html, css, js);</span><br></pre></td></tr></table></figure>
<h4 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h4><h5 id="JavaScript-和-Gulpfile"><a href="#JavaScript-和-Gulpfile" class="headerlink" title="JavaScript 和 Gulpfile"></a>JavaScript 和 Gulpfile</h5><p>Gulp 允许你使用现有 JavaScript 知识来书写 gulpfile 文件，或者利用你所掌握的 gulpfile 经验来书写普通的 JavaScript 代码。虽然 gulp 提供了一些使用工具来简化文件系统和命令行的操作，但是你所编写的其他代码都是纯 JavaScript 代码。</p>
<h6 id="Gulpfile-详解"><a href="#Gulpfile-详解" class="headerlink" title="Gulpfile 详解"></a>Gulpfile 详解</h6><p>gulpfile 是项目目录下名为 <code>gulpfile.js</code> （或者首字母大写 <code>Gulpfile.js</code>, 就像 Makefile 一样命名）的文件，在运行 <code>gulp</code> 命令时会被自动加载。在这个文件中，你经常会看到类似<code>src()</code>、<code>dest()</code>、<code>series()</code> 或 <code>parallel()</code> 函数之类的 gulp API，除此之外，纯 JavaScript 代码 或 Node 模块也会被使用。任何导出（export）的函数都将注册到 gulp 的任务（task）系统中。</p>
<h6 id="Gulpfile-转译"><a href="#Gulpfile-转译" class="headerlink" title="Gulpfile 转译"></a>Gulpfile 转译</h6><p>你可以使用需要转译的编程语言来书写 gulpfile 文件，例如 TypeScript 或者 Babel，通过修改 <code>gulpfile.js</code> 文件的扩展名来表名所用的编程语言并安装对应的转译模块。</p>
<ul>
<li>对于 TypeScript，重命名为 <code>gulpfile.ts</code> 并安装 <code>ts-mode</code> 模块。</li>
<li>对于 Babel，重命名为 <code>gulpfile.babel.js</code> 并安装 <code>@babel/register</code> 模块。</li>
</ul>
<h6 id="Gulpfile-分割"><a href="#Gulpfile-分割" class="headerlink" title="Gulpfile 分割"></a>Gulpfile 分割</h6><p>大部分用户起初是将所有业务逻辑都写到一个 gulpfile 文件中。随着文件的变大，可以将此文件重构成数个独立的文件。</p>
<p>每个任务（task）可以被分割成独立的文件，然后导入（import）到 gulpfile 文件中并组合。这不仅使事情变得井然有序，而且可以对每个任务（task）进行单独测试，或者根据条件改变组合。</p>
<p>Node 的模块解析功能允许你将 <code>gulpfile.js</code> 文件替换为同样命名为 <code>gulpfile.js</code> 的目录，该目录中包含了一个名为 <code>index.js</code> 的文件，该文件被当作  <code>gulpfile.js</code> 使用。并且，该目录中还可以包含各个独立的任务（task）模块。</p>
<h5 id="创建任务（task）"><a href="#创建任务（task）" class="headerlink" title="创建任务（task）"></a>创建任务（task）</h5><p>每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个接受 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable 类型值的函数。</p>
<h6 id="导出任务"><a href="#导出任务" class="headerlink" title="导出任务"></a>导出任务</h6><p>任务（tasks）可以是 public （<strong>公共</strong>）或 private （<strong>私有</strong>）类型的。</p>
<ul>
<li><strong>公开任务（Public tasks）</strong> 从 gulpfile 中被导出（export），可以通过 <code>gulp</code> 命令直接调用</li>
<li><strong>私有任务（Private tasks）</strong> 被设计为在内部使用，通常作为 <code>series()</code> 或 <code>parallel()</code> 组合的组成部分。</li>
</ul>
<h6 id="组合任务"><a href="#组合任务" class="headerlink" title="组合任务"></a>组合任务</h6>]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>helloWorld</title>
    <url>/2021/03/10/helloWorld/</url>
    <content><![CDATA[<h4 id="jdk配置成功后的效果"><a href="#jdk配置成功后的效果" class="headerlink" title="jdk配置成功后的效果"></a>jdk配置成功后的效果</h4><p>打开命令行窗口，在其中执行命令 <code>java -version</code>, <strong>注意：<code>-version</code>是小写，不能使用大写，java后面有一个空格。</strong></p>
<p>配置成功后，会出现版本信息 <span style="color:#F1B054;">java version “1.8.0_65”</span>。</p>
<h4 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h4><p>新建一个环境变量 <code>JAVA_HOME</code>,为<code>JDK</code>的目录路径。</p>
<p>修改变量<code>Path</code>，在最前面加上<code>%JAVA_HOME%\bin;</code></p>
<h5 id="问题：明明存在Hello这个类，并且也有主方法，可是运行就出现找不到或者无法加载类Hello，或者Class-Not-Found异常？"><a href="#问题：明明存在Hello这个类，并且也有主方法，可是运行就出现找不到或者无法加载类Hello，或者Class-Not-Found异常？" class="headerlink" title="问题：明明存在Hello这个类，并且也有主方法，可是运行就出现找不到或者无法加载类Hello，或者Class Not Found异常？"></a>问题：明明存在Hello这个类，并且也有主方法，可是运行就出现找不到或者无法加载类Hello，或者Class Not Found异常？</h5><ul>
<li>重新构建项目</li>
<li>可能项目导入的包不存在</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="java基本类型"><a href="#java基本类型" class="headerlink" title="java基本类型"></a>java基本类型</h5><ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>char</li>
<li>float</li>
<li>double</li>
</ul>
<h5 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h5><h5 id="浮点数字面值"><a href="#浮点数字面值" class="headerlink" title="浮点数字面值"></a>浮点数字面值</h5><p>当以<code>f</code>或<code>F</code>结尾的时候，就表示一个<code>float</code>类型的浮点数，否则就是<code>double</code>类型（以<code>d</code>或<code>D</code>结尾，写不写都可以）。</p>
<p>浮点数还可以用<code>E</code>或<code>e</code>表示(科学计数法)。</p>
<p><code>e2</code>表示<code>10</code>的二次方，即<code>100</code>。</p>
<p>如<code>1.234e2 = 1.234 * 100</code>。</p>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>小类型向大类型自动转换，大类型向小类型需 <strong>强制转换</strong>.</p>
<p>强制转换可能产生精度缺失。</p>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo配置next主题的博客</title>
    <url>/2020/07/31/hexo%E9%85%8D%E7%BD%AEnext%E4%B8%BB%E9%A2%98%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h4 id="文章目录的描点不能进行跳转"><a href="#文章目录的描点不能进行跳转" class="headerlink" title="文章目录的描点不能进行跳转"></a>文章目录的描点不能进行跳转</h4><p><img src="http://wrr123.github.io/2020/07/31/hexo%E9%85%8D%E7%BD%AEnext%E4%B8%BB%E9%A2%98%E7%9A%84%E5%8D%9A%E5%AE%A2/001.png" alt="问题描述"></p>
<h5 id="可能的原因-一-："><a href="#可能的原因-一-：" class="headerlink" title="可能的原因(一)："></a>可能的原因(一)：</h5><p>hexo博客的锚点处的<code>href</code>属性，其中文是ASCII码格式的，不是纯粹的中文显示，可能引起锚点定位失败。::smile_cat:</p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议-how2j</title>
    <url>/2021/03/14/http%E5%8D%8F%E8%AE%AE-how2j/</url>
    <content><![CDATA[<h4 id="协议概念"><a href="#协议概念" class="headerlink" title="协议概念"></a>协议概念</h4><p>HTTP 超文本传输协议 Hyper Text Transfer Protocol</p>
<p>当我们在浏览器的地址栏输入一个地址的时候，就能够访问服务器的某个页面。</p>
<p>这个过程本身就是两个应用程序之间的交互，一个应用程序是浏览器，另一个应用程序是服务器。</p>
<p>协议是什么？</p>
<ul>
<li>它就是不同的应用程序之间按照事先做好的约定进行的通信。这样能互相读懂对象的意思。</li>
</ul>
<p>浏览器和WEB服务器之间，使用的就是一种叫HTTP的协议。</p>
<p>这是BS(browser server)架构模型的基础。</p>
<span id="more"></span>
<p><strong>HTTP协议由请求和响应两种类型组成。</strong></p>
<h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><h4 id="请求协议"><a href="#请求协议" class="headerlink" title="请求协议"></a>请求协议</h4><p>请求消息由请求行、请求头部、空行和请求数据4部分组成。</p>
<blockquote>
<p>请求头部信息提供了如下信息:<br>Host: 主机名<br>User-Agent: 浏览器基本资料<br>Accept: 浏览器能够识别的响应类型<br>Accept-Language: 浏览器默认语言<br>Accept-Encoding: 浏览器能够识别的压缩方式<br>Referer: 来路页面， /addHero 这个路径是通过addHero.html这个页面跳转过来的。<br>Connecton：是否保持连接</p>
</blockquote>
<h4 id="响应协议"><a href="#响应协议" class="headerlink" title="响应协议"></a>响应协议</h4><p>响应消息由状态行、消息报头和响应正文组成。</p>
<blockquote>
<p>消息报头中提供如下信息：<br>Content-Length: 表示长度<br>Content-Type: 内容格式<br>Date: 日期<br>Server: 服务器类型</p>
</blockquote>
<h4 id="响应代码"><a href="#响应代码" class="headerlink" title="响应代码"></a>响应代码</h4><p>http协议中的响应代码从<code>1xx~5xx</code>,一共有41种，不过很多状态码很少会接触到。</p>
<p>一些常见的状态码：</p>
<ul>
<li>200 响应成功了</li>
<li>301 客户端跳转，永久性的跳转</li>
<li>302 客户端跳转，临时性的跳转</li>
<li>304 资源未被修改</li>
<li>404 访问的页面不存在</li>
<li>500 服务端的错误</li>
</ul>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>idea-how2j</title>
    <url>/2021/03/19/idea-how2j/</url>
    <content><![CDATA[<h4 id="IDEA基础"><a href="#IDEA基础" class="headerlink" title="IDEA基础"></a>IDEA基础</h4><h5 id="idea配置文件位置"><a href="#idea配置文件位置" class="headerlink" title="idea配置文件位置"></a>idea配置文件位置</h5><ul>
<li><p>打开<code>idea.properties</code></p>
</li>
<li><p>修改配置位置</p>
<p><img src="http://wrr123.github.io/2021/03/19/idea-how2j/001.png" alt="p"></p>
</li>
<li><p>重新启动idea</p>
</li>
</ul>
<span id="more"></span>
<h5 id="java-project"><a href="#java-project" class="headerlink" title="java project"></a>java project</h5><h5 id="增加jar（如果需要用到第三方的jar包）"><a href="#增加jar（如果需要用到第三方的jar包）" class="headerlink" title="增加jar（如果需要用到第三方的jar包）"></a>增加jar（如果需要用到第三方的jar包）</h5><ul>
<li><p>下载好jar包，并放到文件的<code>lib</code>目录下</p>
</li>
<li><p>添加jar到路径</p>
<p>右键<code>lib</code>目录-&gt;<code>Add as Library...</code>,弹出个对话框，点击ok即可。</p>
<p><img src="http://wrr123.github.io/2021/03/19/idea-how2j/002.png" alt></p>
</li>
<li><p>再次运行项目就可以了</p>
</li>
</ul>
<h5 id="Web-Project"><a href="#Web-Project" class="headerlink" title="Web Project"></a>Web Project</h5><ul>
<li><p>新建项目</p>
<p>菜单-&gt;File-&gt;New-&gt;Project-&gt;Web Application-&gt;OK</p>
</li>
<li><p>新建目录，直到项目建立完成</p>
</li>
<li><p>新建<code>HelloServlet</code></p>
<p>下载servlet所需的jar包，并放在项目的lib目录下</p>
</li>
<li><p>指定输出目录</p>
<ol>
<li><p>打开project structure</p>
</li>
<li><p>设置project complier output</p>
<p><img src="http://wrr123.github.io/2021/03/19/idea-how2j/003.png" alt></p>
</li>
</ol>
</li>
<li><p>修改web.xml文件，配置servlet的映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h5><h5 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h5><h5 id="Eclipse-Web项目"><a href="#Eclipse-Web项目" class="headerlink" title="Eclipse Web项目"></a>Eclipse Web项目</h5><h5 id="maven项目没有resources目录怎么办？"><a href="#maven项目没有resources目录怎么办？" class="headerlink" title="maven项目没有resources目录怎么办？"></a>maven项目没有resources目录怎么办？</h5><ul>
<li>打开project structure</li>
<li>点击左边的Modules<ul>
<li>点击Sources</li>
<li>点击Main</li>
<li>点击New Folder，然后输入 resoureces</li>
</ul>
</li>
<li>右键resources，将其标记为<code>resources</code></li>
</ul>
<h4 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h4><h5 id="maven在idea下的配置"><a href="#maven在idea下的配置" class="headerlink" title="maven在idea下的配置"></a>maven在idea下的配置</h5><h5 id="一个简单的maven-project"><a href="#一个简单的maven-project" class="headerlink" title="一个简单的maven project"></a>一个简单的maven project</h5><h5 id="maven增加jar包"><a href="#maven增加jar包" class="headerlink" title="maven增加jar包"></a>maven增加jar包</h5><h5 id="新建maven-web项目"><a href="#新建maven-web项目" class="headerlink" title="新建maven web项目"></a>新建maven web项目</h5><h6 id="注解-WebServlet"><a href="#注解-WebServlet" class="headerlink" title="注解@WebServlet"></a>注解<code>@WebServlet</code></h6><p>在Servlet3.0之后，我们可以不在web.xml文件中配置servlet，只需要加上<code>@WebServlet</code>注解就可以修改servlet的属性了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(description = &quot;a enter for wechat&quot;, urlPatterns = &#123; &quot;/aaa&quot;&#125;,loadOnStartup=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatIndexServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="父子项目"><a href="#父子项目" class="headerlink" title="父子项目"></a>父子项目</h5><ul>
<li><p>创建一个项目，将pom.xml文件的<code>&lt;packaging/&gt;</code>标签设置为<code>pom</code>。</p>
</li>
<li><p>创建子项目，<code>New -&gt; Module</code></p>
<p>此时，在父项目中会生成一个标签<code>&lt;modules /&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>childMavneProject<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="git"><a href="#git" class="headerlink" title="git"></a>git</h4><h4 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h4>]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery基本函数使用</title>
    <url>/2020/08/10/jQuery%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><ul>
<li><code>remove()</code> 删除被选元素</li>
<li><code>empty()</code> 从被选元素中删除子元素</li>
</ul>
<h4 id="next"><a href="#next" class="headerlink" title=".next()"></a><code>.next()</code></h4><p>描述：取得匹配的元素集合中每一个元素 <strong>紧邻的后面同辈元素</strong> 的元素集合。</p>
<p>如果提供一个选择器，那么只有紧跟着的兄弟元素满足选择器时，才会返回此元素。</p>
<span id="more"></span>
<h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.next([selector])</span><br><span class="line"><span class="comment">// selector 类型，一个字符串，其中包含一个选择器表达式针对匹配元素。</span></span><br></pre></td></tr></table></figure>
<h5 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;third-item&quot;</span>&gt;</span>list item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从第三个项目开始，查找紧随其后的元素</span></span><br><span class="line">$(<span class="string">&#x27;li.third-item&#x27;</span>).next().css(<span class="string">&#x27;background-color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>java-import的使用</title>
    <url>/2020/10/13/java-import%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h4><p><code>import static xxx.类名</code></p>
<p><strong><code>import</code> 可以省略写包名，而使用 <code>import static</code> 则可以连类名也可以省略。</strong></p>
<span id="more"></span>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-switch的新特性</title>
    <url>/2020/10/12/java-switch%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h4 id="简化-fall-through-规则"><a href="#简化-fall-through-规则" class="headerlink" title="简化 fall-through 规则"></a>简化 fall-through 规则</h4><p>一个以前的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (today) &#123;</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m happy!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m sad...&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m confused.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>从 java 12 开始，可以使用下面更加简洁清晰的语法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (today) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUNDAY, SATURDAY -&gt; System.out.println(<span class="string">&quot;I&#x27;m happy!&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; System.out.println(<span class="string">&quot;I&#x27;m happy, too!!&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;I&#x27;m confused.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一点总结：</p>
<blockquote>
<ol>
<li>程序内容积极向上，体现了新时代的奋斗精神（敲黑板！重要！！）</li>
<li>对应相同动作的多个<code>case</code>合并为一行，代码更简洁</li>
<li>条件和动作之间用<code>-&gt;</code>连接，这时fall-through规则失效。匹配到的分支代码执行完后直接跳出，不会继续执行下面的<code>case</code>对应的代码。也就是不需要再为每一个分支写<code>break</code>了。程序更简洁清晰，也更符合人类的直觉。<br>   需要注意，为了保持向后兼容性，<code>case</code>条件后依然可以使用<code>:</code>，这时fall-through还是有效的，即不能省略原有的<code>break</code>。而一个<code>switch</code>结构里不能混用<code>-&gt;</code>和<code>:</code>，否则会有编译错误。</li>
<li>每一个<code>-&gt;</code>后面只允许接一个表达式、一个代码块、或者一个<code>throw</code>语句。这样在代码块中定义的局部变量，其作用域就限制在代码块中，而不是蔓延到整个<code>switch</code>结构。逻辑更加清楚了。</li>
</ol>
</blockquote>
<h4 id="switch-作为一个表达式"><a href="#switch-作为一个表达式" class="headerlink" title="switch 作为一个表达式"></a>switch 作为一个表达式</h4><blockquote>
<p><code>switch</code>结构一直是一个statement，而从Java 12开始，它也可以用作expression。从学院派的定义理解statement和expression的区别叫人头疼，如果说人话的话，就是<code>switch</code>可以有返回值了。</p>
</blockquote>
<p>一个以前的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String word = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        word = <span class="string">&quot;One&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        word = <span class="string">&quot;Two&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        String result = String.format(<span class="string">&quot;Other (%d)&quot;</span>, num);</span><br><span class="line">        word = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 java 12 之后的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String word = <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;One&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;Two&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        String result = String.format(<span class="string">&quot;Other (%d)&quot;</span>, num);</span><br><span class="line">        <span class="keyword">break</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>返回值的另外两种情况：</p>
<blockquote>
<ol>
<li><p>如果分支只有一个表达式，那么表达式本身就是<code>switch</code>的值，比如上面例子里的<code>&quot;One&quot;</code>和<code>&quot;Two&quot;</code>；</p>
</li>
<li><p>如果分支是一个代码块，比如例子中的<code>default</code>，可以看到Java 12改造了<code>break</code>关键字，可以通过<code>break result</code>的形式返回值。<code>switch</code>并没有抛弃<code>break</code>，而是赋予它更重要的职能。</p>
</li>
</ol>
</blockquote>
<p>注意点：<strong>当<code>switch</code>用作expression时，每一个分支都必须有返回值（或者有<code>throw</code>异常）</strong></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-token</title>
    <url>/2020/08/31/java-token/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java</title>
    <url>/2020/11/30/java/</url>
    <content><![CDATA[<h4 id="获取26个英文字母"><a href="#获取26个英文字母" class="headerlink" title="获取26个英文字母"></a>获取26个英文字母</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出26个英文字母</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">char</span> c = (<span class="keyword">char</span>) (<span class="number">96</span> + i);</span><br><span class="line">  System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-PriorityQueue"><a href="#使用-PriorityQueue" class="headerlink" title="使用 PriorityQueue"></a>使用 PriorityQueue</h4><p>我们知道，<code>Queue</code> 是一个先进先出（FIFO）的队列。</p>
<p><code>Queue</code> 会严格按照FIFO的原则取出队首元素。如果需要进行插队的话，那么使用 <code>Queue</code>的话就不合适了，需要使用优先队列 <code>PriorityQueue</code>。</p>
<p><code>PriorityQueue</code> 和 <code>Queue</code> 的区别在与，它的出队顺序与元素的优先级有关，对 <code>PriorityQueue</code> 调用 <code>remove()</code> 或 <code>poll()</code> 方法，返回的总是优先级最高的元素。</p>
<p>要使用 <code>PriorityQueue</code> ,我们就必须给每个元素定义”优先级”。</p>
<p>放入到 <code>PriorityQueue</code> 的元素，必须实现 <code>Comparable</code> 接口，<code>PriorityQueue</code> 会根据元素的排序顺序决定出队的优先级。</p>
<h4 id="Java使用flatMap和map方法"><a href="#Java使用flatMap和map方法" class="headerlink" title="Java使用flatMap和map方法"></a>Java使用flatMap和map方法</h4><p>如果需要将每个元素转换为一个值，则使用<code>Stream.map</code>方法；如果需要将每个元素转换为多个值，且需要将生成的流<code>展平</code>，则使用 <code style="color:red;">Stream.flatMap</code>方法 。</p>
<h5 id="Java使用flatMap与map方法的具体实例"><a href="#Java使用flatMap与map方法的具体实例" class="headerlink" title="Java使用flatMap与map方法的具体实例"></a>Java使用flatMap与map方法的具体实例</h5><p><code style="color:red;">map</code> 和 <code style="color:red;">flatMap</code> 方法均传入 <code>Function</code> 作为参数。</p>
<p><span style="color:red;">map</span> 方法的签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>
<p><code style="color:red;">Function</code> 传入一个输入，并将其转换为一个输出。<code style="color:red;">map</code> 方法则将一个 <code>T</code> 类型的输入转换为一个 <code>R</code> 类型的输出。</p>
<p>一个栗子：</p>
<blockquote>
<p>将顾客映射到他们的姓名</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customers.stream()</span><br><span class="line">         .map(Customer::getName)</span><br><span class="line">         .forEach(System.out::println)</span><br></pre></td></tr></table></figure>
<p><span style="color:red;">flatMap</span> 方法的签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>
<p>对于每个泛型参数 <code>T</code>， 函数生成的是 <code style="color:red;">Stream&lt;R&gt;</code> 而不仅仅是 <code>R</code>。之后，<code style="color:red;">flatMap</code> 方法从各个流中删除每个元素并将它们添加到输出，从而 <span style="color:red;">“展平”</span> 生成的流。</p>
<blockquote>
<p><code>flatMap</code> 方法的 <code>Function</code> 参数传入一个泛型输入参数，但生成的输出类型为 <code>Stream</code>。</p>
</blockquote>
<p>一个栗子：</p>
<blockquote>
<p>对顾客订单应用 <span style="color:red;">flatMap</span> 方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customers.stream()</span><br><span class="line">         .flatMap(customer -&gt; customer.getOrders().stream())</span><br><span class="line">         .forEach(System.out::println)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java8新特性之流式数据处理</title>
    <url>/2020/07/10/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%B5%81%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="流式处理简介"><a href="#流式处理简介" class="headerlink" title="流式处理简介"></a>流式处理简介</h4><p>所谓流，就是数据的渠道。</p>
<p>流代表的是一个对象的序列，它和<code>java I/O类</code>里面使用的流是 <strong>不一样的</strong>。</p>
<p>流API中的流操作的数据源，是数组或者集合。它本身是不存储数据的，只是移动数据，在移动过程中可能会对数据进行过滤、排序或者其他操作。但是，一般情况下(<strong>绝大多数情况</strong>)，流操作本身不会修改数据源，比如，对流排序不会修改数据源的顺序。相反，它会创建一个新的流，其中包含排序后的结果。</p>
<span id="more"></span>
<h4 id="Stream-流的中间操作"><a href="#Stream-流的中间操作" class="headerlink" title="Stream 流的中间操作"></a>Stream 流的中间操作</h4><h4 id="将List转换为数组"><a href="#将List转换为数组" class="headerlink" title="将List转换为数组"></a>将List转换为数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 使用stream</span></span><br><span class="line">list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 使用list的toArray</span></span><br><span class="line">list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java8特性详解</title>
    <url>/2021/03/16/java8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h4><p><img src="http://wrr123.github.io/2021/03/16/java8%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/Java8.png" alt></p>
<span id="more"></span>
<h4 id="函数编程（Lambda表达式）"><a href="#函数编程（Lambda表达式）" class="headerlink" title="函数编程（Lambda表达式）"></a>函数编程（Lambda表达式）</h4><p>面向对象编程是对数据进行抽象；<strong>函数式编程是对行为进行抽象。</strong></p>
<p>核心思想：</p>
<ul>
<li>使用不可变值和函数，函数对一个值进行处理，映射成另一个值。</li>
</ul>
<h5 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h5><p>lambda表达式仅能放入 <strong>预定义使用了@Functional注解的函数式接口，自带一个抽象函数的方法，或者SAM（Single Abstract Method 单个抽象方法）类型。</strong></p>
<ul>
<li>Lambda内部可以使用静态、非静态和局部变量，这成为lambda内的变量捕获。</li>
<li>Lambda表达式在java中又可成为 <strong>闭包或匿名函数。</strong></li>
<li>Lambda表达式有个限制，那就是只能引用final或final局部变量，这就是说不能在lambda表达式内部修改定义在域外的变量。</li>
</ul>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>惰性求值方法</li>
<li>及早求值方法</li>
</ul>
<h5 id="stream-和-parallelStream"><a href="#stream-和-parallelStream" class="headerlink" title="stream 和 parallelStream"></a>stream 和 parallelStream</h5><p>每个stream都有两种模式：顺序执行和并行执行。</p>
<h5 id="Stream中常用的方法"><a href="#Stream中常用的方法" class="headerlink" title="Stream中常用的方法"></a>Stream中常用的方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream(), parallelStream()</span><br><span class="line">filter()</span><br><span class="line">findAny() findFirst()</span><br><span class="line">sort</span><br></pre></td></tr></table></figure>
<p><code>forEach</code> void</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map(), reduce()</span><br></pre></td></tr></table></figure>
<p><code>flatMap()</code> - 将多个Stream连接成一个Stream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">collect(Collectors.toList())</span><br><span class="line">distinct, limit</span><br><span class="line">count</span><br><span class="line">min, max, summaryStatistics</span><br></pre></td></tr></table></figure>
<h4 id="Optional类深度解析"><a href="#Optional类深度解析" class="headerlink" title="Optional类深度解析"></a>Optional类深度解析</h4><p>这是一个可以为null的容器对象。如果值存在则<code>isPresent()</code>方法会返回true，调用<code>get()</code>方法会返回该对象。</p>
<h5 id="Optional类包含的方法"><a href="#Optional类包含的方法" class="headerlink" title="Optional类包含的方法"></a>Optional类包含的方法</h5><ul>
<li><p><code>of</code> 为非null的值创建一个Optional。如果你传了一个null，则会报错<code>NullPointerException</code>。</p>
</li>
<li><p><code>ofNullable</code> 为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。</p>
</li>
<li><p><code>isPresent</code> 如果值存在，则返回true，否则返回false。</p>
</li>
<li><p><code>get</code> 如果Optional有值则将其返回，否则抛出<code>NoSuchElementException</code>。</p>
</li>
<li><p><code>ifPresent</code> 如果Optional实例有值，则为其调用<code>consumer</code>，否则不做处理。</p>
</li>
<li><p><code>orElse</code> 如果有值则将其返回，否则返回指定的其他值。</p>
</li>
<li><p><code>orElseGet</code> <code>orElseGet</code> 和 <code>orElse</code> 类似，区别在于得到的默认值。<code>orElse</code>将和optional中元素类型相同的值作为默认值，<code>orElseGet</code>方法可以接受<code>Supplier</code>接口的实现用来生成默认值。</p>
</li>
<li><p><code>orElseThrow</code> 如果有值将其返回，否则抛出<code>Supplier</code>接口创建的异常。</p>
</li>
<li><p><code>map</code> 如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。</p>
</li>
<li><p><code>flatMap</code> </p>
<blockquote>
<p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map(Funtion)方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。</p>
</blockquote>
</li>
<li><p><code>filter</code>  通过传入限定条件对Optional实例的值进行过滤。</p>
</li>
</ul>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Optional实例，也可以通过方法返回值得到。</span></span><br><span class="line">    Optional&lt;String&gt; name = Optional.of(<span class="string">&quot;Sanaulla&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建没有值的Optional实例，例如值为&#x27;null&#x27;</span></span><br><span class="line">    Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//isPresent方法用来检查Optional实例是否有值。</span></span><br><span class="line">    <span class="keyword">if</span> (name.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//调用get()返回Optional值。</span></span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//在Optional实例上调用get()抛出NoSuchElementException。</span></span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ifPresent方法接受lambda表达式参数。</span></span><br><span class="line">    <span class="comment">//如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span></span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;The length of the value is: &quot;</span> + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span></span><br><span class="line">    System.out.println(empty.orElse(<span class="string">&quot;There is no value present!&quot;</span>));</span><br><span class="line">    System.out.println(name.orElse(<span class="string">&quot;There is some value!&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//orElseGet与orElse类似，区别在于传入的默认值。</span></span><br><span class="line">    <span class="comment">//orElseGet接受lambda表达式生成默认值。</span></span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; <span class="string">&quot;Default Value&quot;</span>));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; <span class="string">&quot;Default Value&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//orElseThrow与orElse方法类似，区别在于返回值。</span></span><br><span class="line">      <span class="comment">//orElseThrow抛出由传入的lambda表达式/方法生成异常。</span></span><br><span class="line">      empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map方法通过传入的lambda表达式修改Optonal实例默认值。 </span></span><br><span class="line">    <span class="comment">//lambda表达式返回值会包装为Optional实例。</span></span><br><span class="line">    Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">&quot;No value found&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//flatMap与map(Funtion)非常相似，区别在于lambda表达式的返回值。</span></span><br><span class="line">    <span class="comment">//map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span></span><br><span class="line">    <span class="comment">//但是flatMap方法的lambda返回值总是Optional类型。</span></span><br><span class="line">    upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">&quot;No value found&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter方法检查Optiona值是否满足给定条件。</span></span><br><span class="line">    <span class="comment">//如果满足返回Optional实例值，否则返回空Optional。</span></span><br><span class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(longName.orElse(<span class="string">&quot;The name is less than 6 characters&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一个示例，Optional值不满足给定条件。</span></span><br><span class="line">    Optional&lt;String&gt; anotherName = Optional.of(<span class="string">&quot;Sana&quot;</span>);</span><br><span class="line">    Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(shortName.orElse(<span class="string">&quot;The name is less than 6 characters&quot;</span>));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><h5 id="什么叫默认方法？"><a href="#什么叫默认方法？" class="headerlink" title="什么叫默认方法？"></a>什么叫默认方法？</h5><p>简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个<code>default</code>关键字即可。</p>
<h6 id="为什么会出现默认方法？"><a href="#为什么会出现默认方法？" class="headerlink" title="为什么会出现默认方法？"></a>为什么会出现默认方法？</h6><blockquote>
<p>为什么要有这个特性? 首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
</blockquote>
<h6 id="java8抽象类和接口的对比"><a href="#java8抽象类和接口的对比" class="headerlink" title="java8抽象类和接口的对比"></a>java8抽象类和接口的对比</h6><div class="table-container">
<table>
<thead>
<tr>
<th>相同点</th>
<th>不同点</th>
</tr>
</thead>
<tbody>
<tr>
<td>都是抽象类型</td>
<td>抽象类不可以多重继承，而接口可以（无论是多重类型继承还是多重行为继承）</td>
</tr>
<tr>
<td>都可以有实现方法（java8以前不行）</td>
<td>抽象类和接口所反映出的设计理念不同。抽象类表示的是<code>is-a</code>的关系，而接口表示的是<code>like-a</code>的关系</td>
</tr>
<tr>
<td>都可以不需要实现类或继承类去实现所有的方法</td>
<td>抽象类的变量默认是friendly型，其值可以在子类中重新定义，也可以重新赋值；接口中定义的变量默认是<code>public static final</code>型，且必须给其初值，所以实现类中不能改变其值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><ul>
<li>在java8之前，注解只能是在声明的地方所使用，比如类、方法、属性；</li>
<li>java8里面，注解可以应用在任何地方。</li>
</ul>
<h5 id="类型注解的作用"><a href="#类型注解的作用" class="headerlink" title="类型注解的作用"></a>类型注解的作用</h5><p>类型注解被用来支持在Java的程序中做强制类型检查。配合插件式的<code>check framework</code>，可以在编译的时候检测出<code>runtime error</code>，以提高代码质量。这就是类型注解的作用了。</p>
<h4 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>允许在同一申明类型（类、属性、方法）上，多次使用同一个注解。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Authorities.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     <span class="function">String <span class="title">role</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatAnnotationUseNewVersion</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Authority(role=&quot;Admin&quot;)</span></span><br><span class="line">    <span class="meta">@Authority(role=&quot;Manager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型推断优化"><a href="#类型推断优化" class="headerlink" title="类型推断优化"></a>类型推断优化</h4><h5 id="什么叫泛型？"><a href="#什么叫泛型？" class="headerlink" title="什么叫泛型？"></a>什么叫泛型？</h5><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。通俗点讲，就是“类型的变量”。这种类型变量可以用在类、接口和方法的创建中。</p>
<h5 id="java8的泛型类型推断改进"><a href="#java8的泛型类型推断改进" class="headerlink" title="java8的泛型类型推断改进"></a>java8的泛型类型推断改进</h5><ol>
<li>支持通过方法上下文推断泛型目标类型</li>
<li>支持在方法调用链路中，泛型类型推断传递到最后一个方法。</li>
</ol>
<h4 id="JRE精简"><a href="#JRE精简" class="headerlink" title="JRE精简"></a>JRE精简</h4><h5 id="JRE精简的好处"><a href="#JRE精简的好处" class="headerlink" title="JRE精简的好处"></a>JRE精简的好处</h5><ul>
<li>更小的Java环境需要更少的计算资源</li>
<li>一个较小的运行时环境可以更好的优化性能和启动时间</li>
<li>消除未使用的代码从安全的角度总是好的</li>
<li>这些打包的应用程序可以下载速度更快</li>
</ul>
<h5 id="jdeps工具使用"><a href="#jdeps工具使用" class="headerlink" title="jdeps工具使用"></a>jdeps工具使用</h5><h4 id="移除Permgen"><a href="#移除Permgen" class="headerlink" title="移除Permgen"></a>移除Permgen</h4><h5 id="Permgen-Space简单介绍"><a href="#Permgen-Space简单介绍" class="headerlink" title="Permgen Space简单介绍"></a>Permgen Space简单介绍</h5><p>PermGen Space的全称为<code>Permanent Generation Space</code>，是指内存的永久保存区域。</p>
<blockquote>
<p>说说为什么会内存益出: 这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。</p>
</blockquote>
<h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>它是java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<p>四种不同的同步块：</p>
<ol>
<li>实例方法</li>
<li>静态方法</li>
<li>实例方法的同步块</li>
<li>静态方法的同步块</li>
</ol>
<h5 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h5><h5 id="StampedLock-1"><a href="#StampedLock-1" class="headerlink" title="StampedLock"></a>StampedLock</h5><h4 id="LocalDate-LocalDateTime"><a href="#LocalDate-LocalDateTime" class="headerlink" title="LocalDate/LocalDateTime"></a>LocalDate/LocalDateTime</h4><h4 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h4><h4 id="其他更新"><a href="#其他更新" class="headerlink" title="其他更新"></a>其他更新</h4><h5 id="处理数值"><a href="#处理数值" class="headerlink" title="处理数值"></a>处理数值</h5><p>java8添加了严格的数学运算。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Math.addExact(Integer.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">    <span class="comment">// =&gt; integer overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h5><p>java8可以将文件用于函数式数据流。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;Path&gt; stream = Files.list(Paths.get(<span class="string">&quot;&quot;</span>))) &#123;</span><br><span class="line">    String joined = stream</span><br><span class="line">        .map(String::valueOf)</span><br><span class="line">        .filter(path -&gt; !path.startsWith(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">        .sorted()</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;List: &quot;</span> + joined);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path start = Paths.get(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> maxDepth = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;Path&gt; stream = Files.find(start, maxDepth, (path, attr) -&gt;</span><br><span class="line">        String.valueOf(path).endsWith(<span class="string">&quot;.js&quot;</span>))) &#123;</span><br><span class="line">    String joined = stream</span><br><span class="line">        .sorted()</span><br><span class="line">        .map(String::valueOf)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;Found: &quot;</span> + joined);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h5 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; stream = Files.lines(Paths.get(<span class="string">&quot;res/nashorn1.js&quot;</span>))) &#123;</span><br><span class="line">    stream</span><br><span class="line">        .filter(line -&gt; line.contains(<span class="string">&quot;print&quot;</span>))</span><br><span class="line">        .map(String::trim)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaMap遍历</title>
    <url>/2020/09/22/javaMap%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry: params) &#123;</span><br><span class="line">  <span class="keyword">for</span>(Object obj: entry.getValue()) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="stream流的方式处理"><a href="#stream流的方式处理" class="headerlink" title="stream流的方式处理"></a>stream流的方式处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.entrySet().stream().map(entry -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 collection 的forEach 方法遍历 Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.forEach((key, value) -&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中级-how2j</title>
    <url>/2021/03/11/java%E4%B8%AD%E7%BA%A7-how2j/</url>
    <content><![CDATA[<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="什么叫异常"><a href="#什么叫异常" class="headerlink" title="什么叫异常"></a>什么叫异常</h5><p>定义：导致程序的正常流程被中断的事件，叫做异常。</p>
<h6 id="如文件不存在异常"><a href="#如文件不存在异常" class="headerlink" title="如文件不存在异常"></a>如文件不存在异常</h6><p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//试图打开文件LOL.exe，会抛出FileNotFoundException，如果不处理该异常，就会有编译错误</span></span><br><span class="line">        <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h5><p><code>try catch finally throws</code></p>
<h6 id="thorw和throws的区别"><a href="#thorw和throws的区别" class="headerlink" title="thorw和throws的区别"></a><code>thorw</code>和<code>throws</code>的区别</h6><ul>
<li>throws出现在方法声明上，而throws通常出现在方法体内</li>
<li>throws表示出现异常的一种可能性，并不一定会发生这些异常；而throw则是抛出了异常，执行throw则一定抛出了某个异常对象。</li>
</ul>
<h5 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h5><ul>
<li>可查异常</li>
<li>运行时异常</li>
<li>错误</li>
</ul>
<p>其中运行时异常和错误也称为非可查异常。</p>
<h5 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h5><p>Throwable是类，Exception和Error都继承了该类。</p>
<h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><h5 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h5><p>使用绝对路径或相对路径创建File对象。</p>
<h5 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h5><p>流就是一系列的数据。</p>
<h5 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h5><h6 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h6><p>所有的数据在计算机中都是以数字的形式存放的。</p>
<h5 id="关闭流的方式"><a href="#关闭流的方式" class="headerlink" title="关闭流的方式"></a>关闭流的方式</h5><p>所有的流，无论是输入流还是输出流，使用完毕之后，都应该关闭。如果不关闭，会产生对资源占用的浪费。当量比较大的时候，会影响到业务的正常开展。</p>
<ul>
<li>在try中关闭</li>
<li>在finally中关闭</li>
<li>使用try()的方式 【推荐】</li>
</ul>
<h5 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h5><p>Reader字符输入流，Writer字符输出流，专门用于字符的形式读取和写入数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是AB</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Reader</span></span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(f)) &#123;</span><br><span class="line">            <span class="comment">// 创建字符数组，其长度就是文件的长度</span></span><br><span class="line">            <span class="keyword">char</span>[] all = <span class="keyword">new</span> <span class="keyword">char</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            <span class="comment">// 以字符流的形式读取文件所有内容</span></span><br><span class="line">            fr.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> b : all) &#123;</span><br><span class="line">                <span class="comment">// 打印出来是A B</span></span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h5><h6 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h6><blockquote>
<p>工作后经常接触的编码方式有如下几种：<br><strong>ISO-8859-1 ASCII</strong> 数字和西欧字母<br><strong>GBK GB2312 BIG5</strong> 中文<br><strong>UNICODE</strong> (统一码，万国码)</p>
<p>其中<br>ISO-8859-1 包含 ASCII<br>GB2312 是简体中文，BIG5是繁体中文，GBK同时包含简体和繁体以及日文。<br>UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含其中</p>
</blockquote>
<h5 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h5><p>缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区达到一定的量，才把这些数据，一起写入到硬盘中去。按照这种操作模式，就不会像字节流、字符流那样每写一个字节都访问硬盘，从而减少了IO操作。</p>
<h6 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h6><p>有的时候，需要立即把数据写入到硬盘中，而不是等缓存满了才写出去。这时候就需要用到<code>flush</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向文件lol2.txt中写入三行语句</span></span><br><span class="line">        File f =<span class="keyword">new</span> File(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建文件字符流</span></span><br><span class="line">        <span class="comment">//缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">        <span class="keyword">try</span>(FileWriter fr = <span class="keyword">new</span> FileWriter(f);PrintWriter pw = <span class="keyword">new</span> PrintWriter(fr);) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;garen kill teemo&quot;</span>);</span><br><span class="line">            <span class="comment">//强制把缓存中的数据写入硬盘，无论缓存是否已满</span></span><br><span class="line">                pw.flush();           </span><br><span class="line">            pw.println(<span class="string">&quot;teemo revive after 1 minutes&quot;</span>);</span><br><span class="line">                pw.flush();</span><br><span class="line">            pw.println(<span class="string">&quot;teemo try to garen, but killed again&quot;</span>);</span><br><span class="line">                pw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><ul>
<li><code>DataInputStream</code> 数据输入流</li>
<li><code>DataOutputStream</code> 数据输出流</li>
</ul>
<h5 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h5><p>对象流指的是可以直接把一个以流的形式传输给其他的介质，比如硬盘。</p>
<p>一个对象以流的形式进行传输，叫做序列化。</p>
<p>该对象所对应的类，必须是实现<code>Serializable</code>接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Hero garen</span></span><br><span class="line">        <span class="comment">//要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口</span></span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">        h.name = <span class="string">&quot;garen&quot;</span>;</span><br><span class="line">        h.hp = <span class="number">616</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//准备一个文件用于保存该对象</span></span><br><span class="line">        File f =<span class="keyword">new</span> File(<span class="string">&quot;d:/garen.lol&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">//创建对象输出流</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">            ObjectOutputStream oos =<span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            <span class="comment">//创建对象输入流              </span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            ObjectInputStream ois =<span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        ) &#123;</span><br><span class="line">            oos.writeObject(h);</span><br><span class="line">            Hero h2 = (Hero) ois.readObject();</span><br><span class="line">            System.out.println(h2.name);</span><br><span class="line">            System.out.println(h2.hp);</span><br><span class="line">               </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="流关系图"><a href="#流关系图" class="headerlink" title="流关系图"></a>流关系图</h5><p><img src="http://wrr123.github.io/2021/03/11/java%E4%B8%AD%E7%BA%A7-how2j/002.png" alt></p>
<h4 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="与数组的区别"><a href="#与数组的区别" class="headerlink" title="与数组的区别"></a>与数组的区别</h6><ul>
<li><p>数组的局限性</p>
</li>
<li><p>ArrayList存放对象</p>
<p>引入了容器的概念。容器的容量<code>capacity</code>会随着对象的增加，自动增长。常见的容器有<code>ArrayList</code>等。</p>
</li>
</ul>
<h6 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h6><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>增加</td>
</tr>
<tr>
<td>contains</td>
<td>判断是否存在</td>
</tr>
<tr>
<td>get</td>
<td>获取指定位置的对象</td>
</tr>
<tr>
<td>indexOf</td>
<td>获取对象所处的位置</td>
</tr>
<tr>
<td>remove</td>
<td>删除</td>
</tr>
<tr>
<td>size</td>
<td>获取大小</td>
</tr>
<tr>
<td>toArray</td>
<td>转换为数组</td>
</tr>
<tr>
<td>addAll</td>
<td>把另一个容器的所有对象加进来</td>
</tr>
<tr>
<td>clear</td>
<td>清空</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Q1: 在ArrayList的for循环遍历中，是不能删除数据的。那么，如何删除数据呢？</strong></p>
<ul>
<li>使用迭代器遍历，<code>Iterator</code></li>
</ul>
<h6 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h6><h6 id="泛型Generic"><a href="#泛型Generic" class="headerlink" title="泛型Generic"></a>泛型Generic</h6><p>不指定泛型的容器，可以存放任何类型的元素；</p>
<p>指定了泛型的容器，只能存放指定类型的元素及其子类。</p>
<p><strong>泛型的简写：在JDK7之后，后面的泛型可以用<code>&lt;&gt;</code>来代替。</strong></p>
<h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>for</td>
<td>for循环遍历</td>
</tr>
<tr>
<td>itertor</td>
<td>迭代器</td>
</tr>
<tr>
<td>for:</td>
<td>增强for循环</td>
</tr>
</tbody>
</table>
</div>
<h5 id="其他集合"><a href="#其他集合" class="headerlink" title="其他集合"></a>其他集合</h5><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><p>一个概念：</p>
<p>序列分先进先出<code>FIFO</code>,先进后出<code>FILO</code></p>
<p><code>FIFO</code>在Java中叫做Queue队列；</p>
<p><code>FILO</code>在Java中叫做Stack栈。</p>
<p>双向链表-Deque</p>
<p>队列-Queue</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>offer</td>
<td>在最后添加元素</td>
</tr>
<tr>
<td>poll</td>
<td>取出第一个元素</td>
</tr>
<tr>
<td>peek</td>
<td>查看第一个元素</td>
</tr>
</tbody>
</table>
</div>
<h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><ul>
<li>HashMap的键值对</li>
<li>键不能重复，值可以重复</li>
</ul>
<h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><ul>
<li>元素不能重复</li>
<li>没有顺序</li>
<li>遍历</li>
</ul>
<h6 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h6><p>它是一个接口。</p>
<p>Collection是Set，List，Queue和Deque的接口。</p>
<h6 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h6><p>它是一个容器的工具类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>reverse</td>
<td>反转</td>
</tr>
<tr>
<td>shuffle</td>
<td>混淆</td>
</tr>
<tr>
<td>sort</td>
<td>排序</td>
</tr>
<tr>
<td>swap</td>
<td>交换</td>
</tr>
<tr>
<td>rotate</td>
<td>滚动</td>
</tr>
<tr>
<td>synchronizedList</td>
<td>线程安全化</td>
</tr>
</tbody>
</table>
</div>
<h5 id="关系和区别"><a href="#关系和区别" class="headerlink" title="关系和区别"></a>关系和区别</h5><h6 id="ArrayList-vs-HashSet"><a href="#ArrayList-vs-HashSet" class="headerlink" title="ArrayList vs HashSet"></a>ArrayList vs HashSet</h6><ul>
<li>是否有顺序</li>
<li>是否重复</li>
</ul>
<h6 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a>ArrayList vs LinkedList</h6><ul>
<li>插入数据</li>
<li>定位数据</li>
</ul>
<h6 id="HashMap-vs-HashTable"><a href="#HashMap-vs-HashTable" class="headerlink" title="HashMap vs HashTable"></a>HashMap vs HashTable</h6><ul>
<li>HashMap可能存放<code>null</code>，HashTable不可以；</li>
<li>HashMap不是线程安全的类，HashTable是线程安全的。</li>
</ul>
<h6 id="几种set"><a href="#几种set" class="headerlink" title="几种set"></a>几种set</h6><ul>
<li>HashSet：无序的</li>
<li>LinkedHashSet：按照插入顺序</li>
<li>TreeSet：从小到大排序</li>
</ul>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><h6 id="HashCode原理"><a href="#HashCode原理" class="headerlink" title="HashCode原理"></a>HashCode原理</h6><ul>
<li>List查找的低效率</li>
<li>HashMap的性能表现</li>
<li>分析HashMap性能卓越的原因</li>
<li>HashSet判断是否重复</li>
</ul>
<h6 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h6><ul>
<li>Comparator</li>
<li>Comparable</li>
</ul>
<h6 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAggregate</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//传统方式</span></span><br><span class="line">        Collections.sort(heros,<span class="keyword">new</span> Comparator&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Hero o1, Hero o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>) (o2.hp-o1.hp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        Hero hero = heros.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;通过传统方式找出来的hp第三高的英雄名称是:&quot;</span> + hero.name);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//聚合方式</span></span><br><span class="line">        String name =heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-<span class="number">1</span>:<span class="number">1</span>)</span><br><span class="line">            .skip(<span class="number">2</span>)</span><br><span class="line">            .map(h-&gt;h.getName())</span><br><span class="line">            .findFirst()</span><br><span class="line">            .get();</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;通过聚合操作找出来的hp第三高的英雄名称是:&quot;</span> + name);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h5 id="集合中的泛型"><a href="#集合中的泛型" class="headerlink" title="集合中的泛型"></a>集合中的泛型</h5><ul>
<li>不使用泛型</li>
<li>使用泛型</li>
<li>子类对象</li>
<li>泛型的简写</li>
</ul>
<h5 id="支持泛型的类"><a href="#支持泛型的类" class="headerlink" title="支持泛型的类"></a>支持泛型的类</h5><ul>
<li>不支持泛型的Stack</li>
<li>支持泛型的Stack</li>
</ul>
<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><ul>
<li>? extends</li>
<li>? super</li>
<li>泛型通配符 ?</li>
</ul>
<h5 id="泛型转型"><a href="#泛型转型" class="headerlink" title="泛型转型"></a>泛型转型</h5><ul>
<li>对象转型</li>
<li>子类泛型转父类泛型</li>
<li>假设可以转型成功</li>
</ul>
<h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p>Java data base connection指通过java访问数据库。</p>
<h6 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h6><ul>
<li>增加 create</li>
<li>读取查询 retrieve</li>
<li>更新 update</li>
<li>删除 delete</li>
</ul>
<h6 id="预编译-statement"><a href="#预编译-statement" class="headerlink" title="预编译 statement"></a>预编译 statement</h6><h6 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h6><h6 id="ORM-Object-Relationship-Database-Mapping"><a href="#ORM-Object-Relationship-Database-Mapping" class="headerlink" title="ORM(Object Relationship Database Mapping)"></a>ORM(Object Relationship Database Mapping)</h6><h6 id="Dao-data-access-object"><a href="#Dao-data-access-object" class="headerlink" title="Dao(data access object)"></a>Dao(data access object)</h6><h6 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h6><p>数据库连接池原理—使用池</p>
<blockquote>
<p>与传统方式不同，连接池在使用之前，就会创建好一定数量的连接。<br>如果有任何线程需要使用连接，那么就从连接池里面<strong>借用</strong>，<strong>而不是自己重新创建</strong>.<br>使用完毕后，又把这个连接<strong>归还</strong>给连接池供下一次或者其他线程使用。<br>倘若发生多线程并发情况，连接池里的连接被<strong>借用光</strong>了，那么其他线程就会临时等待，直到有连接被<strong>归还</strong>回来，再继续使用。<br>整个过程，这些连接都<strong>不会被关闭</strong>，而是不断的被循环使用，从而节约了启动和关闭连接的时间。</p>
</blockquote>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>java二分查找</title>
    <url>/2020/08/11/java%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h4 id="二分查找的原理"><a href="#二分查找的原理" class="headerlink" title="二分查找的原理"></a>二分查找的原理</h4><p>要求：必须要有一个有序的列表。如果没有的话，可以先使用排序算法进行排序。</p>
<blockquote>
<p>以升序数列为例，比较一个元素与数列中的中间位置的元素的大小，如果比中间位置的元素大，则继续在后半部分的数列中进行二分查找；如果比中间位置的元素小，则在数列的前半部分进行比较；如果相等，则找到了元素的位置。每次比较的数列长度都会是之前数列的一半，直到找到相等元素的位置或者最终没有找到要找的元素。</p>
</blockquote>
<span id="more"></span>
<h5 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归实现二分查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分查找的优化"><a href="#二分查找的优化" class="headerlink" title="二分查找的优化"></a>二分查找的优化</h4><p>为了找到 key 值所在的相对位置，让 key 的值更接近划分的位置，从而减少比较的次数。</p>
<p>这种二分查找的优化有个名字，叫插值查找，插值查找对于数列比较大并且比较均匀的数列来说，性能会好很多；但是如果数列极不均匀，则插值查找未必会比二分查找的性能好。</p>
<h4 id="二分查找的适用场景"><a href="#二分查找的适用场景" class="headerlink" title="二分查找的适用场景"></a>二分查找的适用场景</h4><p>二分查找要求数列本身有序，所以在选择的时候需要确认数列是否本身有序，如果无序，则还需要进行排序，确认这样的代价是否符合实际需求。</p>
<p>其实我们在获取一个列表的很多时候，可以直接使用数据库针对某个字段进行排序，在程序中需要找出某个值的元素时，就很适合使用二分查找了。</p>
<p>二分查找适合元素稍微多一些的数列，如果元素只有十几或者几十个，则其实可以直接使用顺序查找。</p>
<p>一般对一个有序列表，如果只需要对其进行一次排序，之后不再变化或者很少变化，则每次进行二分查找的效率就会很高；但是如果在一个有序列表中频繁地插入、删除数据，那么维护这个有序数列就会感觉很累。</p>
<h4 id="在数据结构中-非递减排序-的意思"><a href="#在数据结构中-非递减排序-的意思" class="headerlink" title="在数据结构中 非递减排序 的意思"></a>在数据结构中 <code>非递减排序</code> 的意思</h4><p>一个栗子：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,........ : 递增排列</span><br><span class="line">9,8,7,6,5......... : 递减排列</span><br><span class="line">1，2，3，3，4，5，8，8，.............. : 非递减排列</span><br><span class="line">9，8，7，7，6，5，5，2，1，........ : 非递增排列</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>java算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java二维数组</title>
    <url>/2020/10/28/java%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h4><p>在 java 中二维数组被看作数组的数组，即二维数组是一个特殊的一维数组，其每个元素又是一个一维数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type arr[][];</span><br><span class="line">type[][] arr;</span><br><span class="line"><span class="comment">// 其中 type 表示二维数组的类型，arr 表示数组名称，第一个中括号表示行，第二个中括号表示列。</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array=<span class="keyword">new</span> type[][]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,…,值 n&#125;;</span><br><span class="line">array=<span class="keyword">new</span> type[][]&#123;<span class="keyword">new</span> 构造方法(参数列),…&#125;;</span><br><span class="line">type[][] array=&#123;&#123;第<span class="number">1</span>行第<span class="number">1</span>列的值,第<span class="number">1</span>行第<span class="number">2</span>列的值,…&#125;,&#123;第<span class="number">2</span>行第<span class="number">1</span>列的值,第<span class="number">2</span>行第<span class="number">2</span>列的值,…&#125;,…&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java代码规范</title>
    <url>/2020/09/27/java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h4 id="mybatis-不要为了多个查询条件而写-1-1"><a href="#mybatis-不要为了多个查询条件而写-1-1" class="headerlink" title="mybatis 不要为了多个查询条件而写 1=1"></a>mybatis 不要为了多个查询条件而写 <code>1=1</code></h4><blockquote>
<p>当遇到多个查询条件，使用where 1=1 可以很方便的解决我们的问题，但是这样很可能会造成非常大的性能损失，因为添加了 “where 1=1 ”的过滤条件之后，数据库系统就无法使用索引等查询优化策略，数据库系统将会被迫对每行数据进行扫描（即全表扫描） 以比较此行是否满足过滤条件，当表中的数据量较大时查询速度会非常慢；此外，还会存在SQL 注入的风险。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBookInfo&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.tjt.platform.entity.BookInfo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span>  </span><br><span class="line"> select count(*) from t_rule_BookInfo t where 11=1  </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title !=null and title !=&#x27;&#x27; &quot;</span>&gt;</span>  </span><br><span class="line"> AND title = #&#123;title&#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author !=null and author !=&#x27;&#x27; &quot;</span>&gt;</span>  </span><br><span class="line"> AND author = #&#123;author&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBookInfo&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.tjt.platform.entity.BookInfo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span>  </span><br><span class="line"> select count(*) from t_rule_BookInfo t  </span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title !=null and title !=&#x27;&#x27; &quot;</span>&gt;</span>  </span><br><span class="line"> title = #&#123;title&#125;   </span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author !=null and author !=&#x27;&#x27; &quot;</span>&gt;</span>   </span><br><span class="line"> AND author = #&#123;author&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p><strong>UPDATE 操作也一样，可以用标记 <code>where</code> 来代替 <code>1=1</code></strong></p>
<span id="more"></span>
<h4 id="迭代-entrySet-获取-Map-的-key-和-value"><a href="#迭代-entrySet-获取-Map-的-key-和-value" class="headerlink" title="迭代 entrySet() 获取 Map 的 key 和 value"></a>迭代 <code>entrySet()</code> 获取 Map 的 key 和 value</h4><p>当循环中只需要获取 Map 的主键 key 时，迭代 ketSet() 是正确的；但是，当需要主键 key 和取值 value 时，迭代 entrySet() 才是最高效的做法，其比迭代 keySet() 后再去通过 get 取值性能更佳。</p>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map 获取value 反例:  </span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet())&#123;  </span><br><span class="line">    String value = map.get(key);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map 获取key &amp; value 正例:  </span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String,String&gt; entry : map.entrySet())&#123;  </span><br><span class="line"> String key = entry.getKey();  </span><br><span class="line"> String value = entry.getValue();  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="使用-Collection-isEmpty-检测空"><a href="#使用-Collection-isEmpty-检测空" class="headerlink" title="使用 Collection.isEmpty() 检测空"></a>使用 Collection.isEmpty() 检测空</h4><blockquote>
<p>使用Collection.size() 来检测是否为空在逻辑上没有问题，但是使用Collection.isEmpty() 使得代码更易读，并且可以获得更好的性能；除此之外，任何Collection.isEmpty() 实现的时间复杂度都是O(1) ，不需要多次循环遍历，但是某些通过Collection.size() 方法实现的时间复杂度可能是O(n)</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Object&gt; collection = <span class="keyword">new</span> LinkedList&lt;&gt;();  </span><br><span class="line"><span class="keyword">if</span> (collection.size() == <span class="number">0</span>)&#123;  </span><br><span class="line"> System.out.println(<span class="string">&quot;collection is empty.&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Object&gt; collection = <span class="keyword">new</span> LinkedList&lt;&gt;();  </span><br><span class="line"><span class="keyword">if</span> (collection.isEmpty())&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;collection is empty.&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//检测是否为null 可以使用CollectionUtils.isEmpty()  </span></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(collection))&#123; </span><br><span class="line">     System.out.println(<span class="string">&quot;collection is null.&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="初始化集合时，尽量指定其大小"><a href="#初始化集合时，尽量指定其大小" class="headerlink" title="初始化集合时，尽量指定其大小"></a>初始化集合时，尽量指定其大小</h4><p>尽量在初始化时，指定集合的大小，能有效减少集合的扩容次数，因为集合每次扩容的时间复杂度很可能是 <code>O(n)</code>,耗费时间和性能。</p>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化list，往list 中添加元素反例： </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  </span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)&#123;  </span><br><span class="line"> list.add(i);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化list，往list 中添加元素正例：  </span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  </span><br><span class="line"><span class="comment">//指定集合list 的容量大小  </span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(arr.length);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)&#123;  </span><br><span class="line">    list.add(i);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="使用-StringBuilder-拼接字符串"><a href="#使用-StringBuilder-拼接字符串" class="headerlink" title="使用 StringBuilder 拼接字符串"></a>使用 StringBuilder 拼接字符串</h5><p>一般的字符串拼接在编译期 Java 会对其进行优化，但是在循环中字符串的拼接 Java 编译期无法执行优化，所以需要使用 StringBuilder 进行替换</p>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在循环中拼接字符串反例  </span></span><br><span class="line">String str = <span class="string">&quot;&quot;</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;  </span><br><span class="line">    <span class="comment">//在循环中字符串拼接Java 不会对其进行优化  </span></span><br><span class="line">    str += i;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在循环中拼接字符串正例  </span></span><br><span class="line">String str1 = <span class="string">&quot;Love&quot;</span>;  </span><br><span class="line">String str2 = <span class="string">&quot;Courage&quot;</span>;  </span><br><span class="line">String strConcat = str1 + str2;  <span class="comment">//Java 编译器会对该普通模式的字符串拼接进行优化  </span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;  </span><br><span class="line">   <span class="comment">//在循环中，Java 编译器无法进行优化，所以要手动使用StringBuilder  </span></span><br><span class="line">   &amp;nbsp;sb.append(i);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="若需频繁调用-Collection-contains-方法则使用-Set"><a href="#若需频繁调用-Collection-contains-方法则使用-Set" class="headerlink" title="若需频繁调用 Collection.contains() 方法则使用 Set"></a>若需频繁调用 Collection.contains() 方法则使用 Set</h4><blockquote>
<p>在Java 集合类库中，List的contains 方法普遍时间复杂度为O(n)，若代码中需要频繁调用contains 方法查找数据则先将集合list 转换成HashSet 实现，将O(n) 的时间复杂度将为O(1)。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//频繁调用Collection.contains() 反例  </span></span><br><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)&#123;  </span><br><span class="line">    <span class="comment">//时间复杂度为O(n)  </span></span><br><span class="line">    <span class="keyword">if</span> (list.contains(i))  </span><br><span class="line">    System.out.println(<span class="string">&quot;list contains &quot;</span>+ i);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//频繁调用Collection.contains() 正例  </span></span><br><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">Set&lt;Object&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)&#123;  </span><br><span class="line">    <span class="comment">//时间复杂度为O(1)  </span></span><br><span class="line">    <span class="keyword">if</span> (set.contains(i))&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;list contains &quot;</span>+ i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="使用静态代码块实现赋值静态成员变量"><a href="#使用静态代码块实现赋值静态成员变量" class="headerlink" title="使用静态代码块实现赋值静态成员变量"></a>使用静态代码块实现赋值静态成员变量</h4><p>对于集合类型的静态成员变量，应该使用静态代码块赋值，而不是使用集合实现来赋值。</p>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值静态成员变量反例 </span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;()&#123;  </span><br><span class="line">    &#123;  </span><br><span class="line">        map.put(<span class="string">&quot;Leo&quot;</span>,<span class="number">1</span>);  </span><br><span class="line">        map.put(<span class="string">&quot;Family-loving&quot;</span>,<span class="number">2</span>);  </span><br><span class="line">        map.put(<span class="string">&quot;Cold on the out side passionate on the inside&quot;</span>,<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;()&#123;  </span><br><span class="line">    &#123;  </span><br><span class="line">        list.add(<span class="string">&quot;Sagittarius&quot;</span>);  </span><br><span class="line">        list.add(<span class="string">&quot;Charming&quot;</span>);  </span><br><span class="line">        list.add(<span class="string">&quot;Perfectionist&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值静态成员变量正例  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">    map.put(<span class="string">&quot;Leo&quot;</span>,<span class="number">1</span>);  </span><br><span class="line">    map.put(<span class="string">&quot;Family-loving&quot;</span>,<span class="number">2</span>);  </span><br><span class="line">    map.put(<span class="string">&quot;Cold on the out side passionate on the inside&quot;</span>,<span class="number">3</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"> <span class="keyword">static</span> &#123;  </span><br><span class="line">    list.add(<span class="string">&quot;Sagittarius&quot;</span>);  </span><br><span class="line">    list.add(<span class="string">&quot;Charming&quot;</span>);  </span><br><span class="line">    list.add(<span class="string">&quot;Perfectionist&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="删除未使用的局部变量、方法参数、私有方法、字段和多余的括号。"><a href="#删除未使用的局部变量、方法参数、私有方法、字段和多余的括号。" class="headerlink" title="删除未使用的局部变量、方法参数、私有方法、字段和多余的括号。"></a>删除未使用的局部变量、方法参数、私有方法、字段和多余的括号。</h4><h4 id="工具类中屏蔽构造函数"><a href="#工具类中屏蔽构造函数" class="headerlink" title="工具类中屏蔽构造函数"></a>工具类中屏蔽构造函数</h4><blockquote>
<p>工具类是一堆静态字段和函数的集合，其不应该被实例化；但是，Java 为每个没有明确定义构造函数的类添加了一个隐式公有构造函数，为了避免不必要的实例化，应该显式定义私有构造函数来屏蔽这个隐式公有构造函数。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;  </span><br><span class="line"><span class="comment">//工具类构造函数反例  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(PasswordUtils.class);  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CRYPT_ALGO = <span class="string">&quot;PBEWithMD5AndDES&quot;</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptPassword</span><span class="params">(String aPassword)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PasswordUtils(aPassword).encrypt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;  </span><br><span class="line"><span class="comment">//工具类构造函数正例  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(PasswordUtils.class);  </span><br><span class="line"><span class="comment">//定义私有构造函数来屏蔽这个隐式公有构造函数  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PasswordUtils</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CRYPT_ALGO = <span class="string">&quot;PBEWithMD5AndDES&quot;</span>;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptPassword</span><span class="params">(String aPassword)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PasswordUtils(aPassword).encrypt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除多余的异常捕获并抛出"><a href="#删除多余的异常捕获并抛出" class="headerlink" title="删除多余的异常捕获并抛出"></a>删除多余的异常捕获并抛出</h4><blockquote>
<p>用catch 语句捕获异常后，若什么也不进行处理，就只是让异常重新抛出，这跟不捕获异常的效果一样，可以删除这块代码或添加别的处理。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多余异常反例  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">fileReader</span><span class="params">(String fileName)</span><span class="keyword">throws</span> IOException</span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) &#123;  </span><br><span class="line">        String line;  </span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            builder.append(line);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> builder.toString();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        <span class="comment">//仅仅是重复抛异常 未作任何处理  </span></span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多余异常正例  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">fileReader</span><span class="params">(String fileName)</span><span class="keyword">throws</span> IOException</span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName))) &#123;  </span><br><span class="line">        String line;  </span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            builder.append(line);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> builder.toString();  </span><br><span class="line">        <span class="comment">//删除多余的抛异常，或增加其他处理：  </span></span><br><span class="line">        <span class="comment">/*catch (Exception e) &#123;  </span></span><br><span class="line"><span class="comment">            return &quot;fileReader exception&quot;;  </span></span><br><span class="line"><span class="comment">        &#125;*/</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串转化使用-String-valueOf-value-代替-quot-quot-value"><a href="#字符串转化使用-String-valueOf-value-代替-quot-quot-value" class="headerlink" title="字符串转化使用 String.valueOf(value) 代替 &quot;&quot; + value"></a>字符串转化使用 String.valueOf(value) 代替 <code>&quot;&quot; + value</code></h4><blockquote>
<p>把其它对象或类型转化为字符串时，使用String.valueOf(value) 比 “”+value 的效率更高。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把其它对象或类型转化为字符串反例：  </span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">520</span>;  </span><br><span class="line"><span class="comment">// &quot;&quot; + value  </span></span><br><span class="line">String strLove = <span class="string">&quot;&quot;</span> + num; </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把其它对象或类型转化为字符串正例：  </span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">520</span>;  </span><br><span class="line"><span class="comment">// String.valueOf() 效率更高  </span></span><br><span class="line">String strLove = String.valueOf(num); </span><br></pre></td></tr></table></figure>
<h4 id="避免使用-BigDecimal-double"><a href="#避免使用-BigDecimal-double" class="headerlink" title="避免使用 BigDecimal(double)"></a>避免使用 BigDecimal(double)</h4><blockquote>
<p>BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BigDecimal 反例      </span></span><br><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(<span class="number">0.11D</span>);</span><br></pre></td></tr></table></figure>
<p>一个正例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BigDecimal 正例  </span></span><br><span class="line">BigDecimal bigDecimalbigDecimal1 = bigDecimal.valueOf(<span class="number">0.11D</span>); </span><br></pre></td></tr></table></figure>
<h4 id="返回空数组和非-null"><a href="#返回空数组和非-null" class="headerlink" title="返回空数组和非 null"></a>返回空数组和非 null</h4><blockquote>
<p>若程序运行返回null，需要调用方强制检测null，否则就会抛出空指针异常；返回空数组或空集合，有效地避免了调用方因为未检测null 而抛出空指针异常的情况，还可以删除调用方检测null 的语句使代码更简洁。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回null 反例  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result[] getResults() &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line"> &#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Result&gt; <span class="title">getResultList</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Result&gt; <span class="title">getResultMap</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回空数组和空集正例  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result[] getResults() &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result[<span class="number">0</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Result&gt; <span class="title">getResultList</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Result&gt; <span class="title">getResultMap</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> Collections.emptyMap();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先使用常量或确定值调用-equals-方法"><a href="#优先使用常量或确定值调用-equals-方法" class="headerlink" title="优先使用常量或确定值调用 equals 方法"></a>优先使用常量或确定值调用 <code>equals</code> 方法</h4><blockquote>
<p>对象的equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals 方法。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用 equals 方法反例  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileReader</span><span class="params">(String fileName)</span><span class="keyword">throws</span> IOException</span>&#123;  </span><br><span class="line"> <span class="comment">// 可能抛空指针异常 </span></span><br><span class="line">  <span class="keyword">return</span> fileName.equals(<span class="string">&quot;Charming&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用 equals 方法正例  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fileReader</span><span class="params">(String fileName)</span><span class="keyword">throws</span> IOException</span>&#123;  </span><br><span class="line">    <span class="comment">// 使用常量或确定有值的对象来调用 equals 方法  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Charming&quot;</span>.equals(fileName);   </span><br><span class="line">    <span class="comment">//或使用：java.util.Objects.equals() 方法  </span></span><br><span class="line">   <span class="keyword">return</span> Objects.equals(<span class="string">&quot;Charming&quot;</span>,fileName);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="枚举的属性字段必须是私有且不可变"><a href="#枚举的属性字段必须是私有且不可变" class="headerlink" title="枚举的属性字段必须是私有且不可变"></a>枚举的属性字段必须是私有且不可变</h4><blockquote>
<p>枚举通常被当做常量使用，如果枚举中存在公共属性字段或设置字段方法，那么这些枚举常量的属性很容易被修改；理想情况下，枚举中的属性字段是私有的，并在私有构造函数中赋值，没有对应的Setter 方法，最好加上final 修饰符。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SwitchStatus</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 枚举的属性字段反例  </span></span><br><span class="line">    DISABLED(<span class="number">0</span>, <span class="string">&quot;禁用&quot;</span>),  </span><br><span class="line">    ENABLED(<span class="number">1</span>, <span class="string">&quot;启用&quot;</span>);  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;  </span><br><span class="line">    <span class="keyword">private</span> String description;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SwitchStatus</span><span class="params">(<span class="keyword">int</span> value, String description)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">        <span class="keyword">this</span>.description = description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.description = description;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SwitchStatus</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 枚举的属性字段正例  </span></span><br><span class="line">    DISABLED(<span class="number">0</span>, <span class="string">&quot;禁用&quot;</span>),  </span><br><span class="line">    ENABLED(<span class="number">1</span>, <span class="string">&quot;启用&quot;</span>);  </span><br><span class="line">    <span class="comment">// final 修饰  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SwitchStatus</span><span class="params">(<span class="keyword">int</span> value, String description)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">        <span class="keyword">this</span>.description = description;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 没有Setter 方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> description;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="String-split-String-regexp-部分关键字需要转译"><a href="#String-split-String-regexp-部分关键字需要转译" class="headerlink" title="String.split(String regexp) 部分关键字需要转译"></a><code>String.split(String regexp)</code> 部分关键字需要转译</h4><blockquote>
<p>使用字符串String 的split 方法时，传入的分隔字符串是正则表达式，则部分关键字（比如 .<a href></a>| 等）需要转义。</p>
</blockquote>
<p>一个反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.split(String regex) 反例  </span></span><br><span class="line">String[] split = <span class="string">&quot;a.ab.abc&quot;</span>.split(<span class="string">&quot;.&quot;</span>);  </span><br><span class="line">System.out.println(Arrays.toString(split));   <span class="comment">// 结果为[]  </span></span><br><span class="line">String[] split1 = <span class="string">&quot;a|ab|abc&quot;</span>.split(<span class="string">&quot;|&quot;</span>);  </span><br><span class="line">System.out.println(Arrays.toString(split1));  <span class="comment">// 结果为[&quot;a&quot;, &quot;|&quot;, &quot;a&quot;, &quot;b&quot;, &quot;|&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] </span></span><br></pre></td></tr></table></figure>
<p>一个正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.split(String regex) 正例  </span></span><br><span class="line"><span class="comment">// . 需要转译  </span></span><br><span class="line">String[] split2 = <span class="string">&quot;a.ab.abc&quot;</span>.split(<span class="string">&quot;\\.&quot;</span>);  </span><br><span class="line">System.out.println(Arrays.toString(split2));  <span class="comment">// 结果为[&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;]  </span></span><br><span class="line"><span class="comment">// | 需要转译  </span></span><br><span class="line">String[] split3 = <span class="string">&quot;a|ab|abc&quot;</span>.split(<span class="string">&quot;\\|&quot;</span>);  </span><br><span class="line">System.out.println(Arrays.toString(split3));  <span class="comment">// 结果为[&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;]  </span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java位运算</title>
    <url>/2020/08/25/java%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>位：二进制位，简称 “位” 。是二进制计数系统中表示小于 2 的整数的符号，一般用 0 或者 1 表示，是具有相等概率的两种状态中的一种。二进制位的位数可表示一个机器字的字长，一个二进制位包含的信息量称为一比特（bit）。</p>
<p>一个栗子：</p>
<blockquote>
<p>举个栗子：<br> int占4个字节（byte）<br> 1byte = 8bit<br> 换算下来，一个int类型即占32bit<br> int i = 88; 这里的88为十进制，转换为二进制为：1011000，使用完整的32位表示即为：00000000 00000000 00000000 01011000</p>
</blockquote>
<span id="more"></span>
<h4 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h4><blockquote>
<p>在计算机内，有符号数有三种表示法：原码、反码以及补码。<br> 原码：就是二进制定点表示法，即最高位为符号位，“0”正负“1”，其余位表示数值的大小。<br> 反码：正数的反码与其原码相同；负数的反码是对正数逐位取反，符号位保持为1。<br> 补码：正数的补码与其原码相同；负数的补码是在其反码的末位加1。</p>
</blockquote>
<p>一个栗子：</p>
<blockquote>
<p>同样的，我们使用 “88” 举例说明原码、反码以及补码。<br> “88”的原码：00000000 00000000 00000000 01011000<br> “88”的反码：00000000 00000000 00000000 01011000<br> “88”的补码：00000000 00000000 00000000 01011000<br> 对于负数 “-88”，其原码、反码以及补码如下：<br> “-88”的原码：10000000 00000000 00000000 01011000<br> “-88”的反码：11111111 11111111 11111111 10100111<br> “-88”的补码：11111111 11111111 11111111 10101000</p>
</blockquote>
<h4 id="什么叫位运算"><a href="#什么叫位运算" class="headerlink" title="什么叫位运算"></a>什么叫位运算</h4><blockquote>
<p>程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）。</p>
</blockquote>
<p>下表列出了 <strong>位运算</strong> 的基本运算（A = 8，B = 9）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>按位与&amp;</td>
<td>如果相对应位都是1，则结果为1，否则为0</td>
<td>A&amp;B=8，即1000</td>
</tr>
<tr>
<td>按位或\</td>
<td></td>
<td>如果相对应位都是0，则结果为0，否则为1</td>
<td>A</td>
<td>B=9，即1001</td>
</tr>
<tr>
<td>按位异或^</td>
<td>如果相对应位值相同，则结果为0，否则为1</td>
<td>A^B=1，即0001</td>
</tr>
<tr>
<td>按位取反~</td>
<td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0</td>
<td>~A=7，即0111</td>
</tr>
<tr>
<td>左移 &lt;&lt;</td>
<td>按位左移运算符。左操作数按位左移右操作数指定的位数</td>
<td>A &lt;&lt; 2 = 32，即1000 00</td>
</tr>
<tr>
<td>右移 &gt;&gt;</td>
<td>按位右移运算符。左操作数按位右移右操作数指定的位数</td>
<td>A &gt;&gt; 2 = 2，即0010</td>
</tr>
</tbody>
</table>
</div>
<h4 id="位运算的常用小技巧"><a href="#位运算的常用小技巧" class="headerlink" title="位运算的常用小技巧"></a>位运算的常用小技巧</h4><h5 id="判断奇偶数"><a href="#判断奇偶数" class="headerlink" title="判断奇偶数"></a>判断奇偶数</h5><p><strong>只要根据最末位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。</strong></p>
<p>因此可以用 <code>if((a &amp; 1) ==0)</code> 代替 <code>if(a % 2 == 0)</code> 来判断 a 是不是偶数。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 0-100 之间的所有偶数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a); <span class="comment">// a = 2</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + b); <span class="comment">// b = 1</span></span><br></pre></td></tr></table></figure>
<h5 id="交换符号"><a href="#交换符号" class="headerlink" title="交换符号"></a>交换符号</h5><p>交换符号就是正数变成负数，负数变成正数。</p>
<p>因此变换符号只需要 <strong>执行取反操作 + 1 即可。</strong></p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">15</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + (~a + <span class="number">1</span>)); <span class="comment">// a = 15</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + (~b + <span class="number">1</span>)); <span class="comment">// b = -15</span></span><br></pre></td></tr></table></figure>
<h4 id="java-逻辑运算符"><a href="#java-逻辑运算符" class="headerlink" title="java 逻辑运算符"></a>java 逻辑运算符</h4><p>包含下面的6种：</p>
<ul>
<li><p><code>&amp;&amp;</code>: 短路与，其两边的表达式必须都是 true，才返回 true，否则返回 false。</p>
</li>
<li><p><code>&amp;</code>: 不短路与，其两边的表达式都会执行到</p>
</li>
<li><code>||</code>: 短路或，其两边的表达式只要有一个为 true，就返回 true，否则返回 false。</li>
<li><code>|</code>:  不短路或，其两边的表达式都会执行到</li>
<li><code>!</code>： 取相反的操作，若表达式为 true，返回 false，反之亦然。</li>
<li><code>^</code>: 当两边的表达式结果不一样时，返回 true， 一样时，返回 false。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java关键字用法</title>
    <url>/2020/10/12/java%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h4 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h4><h5 id="构造方法中的-this-关键字"><a href="#构造方法中的-this-关键字" class="headerlink" title="构造方法中的 this 关键字"></a>构造方法中的 this 关键字</h5><p>构造方法是一个类的对象在通过 new 关键字创建时自动调用的，在程序中不能像调用其他方法一样通过方法名（也就是类名）来调用。但如果一个类有多个构造方法，可以在一个构造方法中通过 <code>this(...params)</code> 来调用其他的构造方法。</p>
<p>使用 this 在调用其他构造方法存在如下的几个约束：</p>
<ol>
<li>只能在构造方法中通过 this 来调用其他构造方法，在普通方法中不行。</li>
<li>不能使用 this 递归调用构造方法，即不能在一个构造方法中直接或间接调用其本身。</li>
<li>通过 this 调用其他构造方法必须放在构造方法的第一行执行。由于 super 调用父类的构造方法也必须放在构造方法的第一行执行，因此，this 和 super 不能出现在同一个构造方法中。</li>
<li>在构造方法中也可以使用 this 关键字来访问本类中的成员变量和成员函数。其用法和非构造方法中的 this 关键字相同。</li>
</ol>
<span id="more"></span>
<h5 id="非构造方法中的-this-关键字"><a href="#非构造方法中的-this-关键字" class="headerlink" title="非构造方法中的 this 关键字"></a>非构造方法中的 this 关键字</h5><p>可以通过 this 关键字来调用类中的成员变量和成员方法（函数）。</p>
<h5 id="继承关系下的-this-关键字"><a href="#继承关系下的-this-关键字" class="headerlink" title="继承关系下的 this 关键字"></a>继承关系下的 this 关键字</h5><p>在继承关系下，父类中的 this 关键字并不总是表示父类中的变量和方法。</p>
<p>this 关键字的 4 中用法如下：</p>
<ol>
<li>this(params…) 访问其他的构造方法</li>
<li>this.xxx 访问类中的成员变量xxx</li>
<li>this.yyy(params…) 访问类中的成员方法yyy</li>
<li>this 当前类对象的引用</li>
</ol>
<blockquote>
<p>对第一种，无论子类是否有相同参数的构造方法，this(paras…);访问的始终是父类中的构造方法。<br>对第二种，无论子类是否有覆盖了该成员变量，this.xxx;访问的始终是父类中的成员变量。<br>对第三种，如果子类重写了该成员方法，则this.yyy(paras…);访问的是子类的成员方法，如果子类没有重写该成员方法，则this.yyy(paras…);访问的是父类的成员方法。<br>对第四种，this始终代表的是子类的对象。</p>
</blockquote>
<h5 id="super-和-this-的异同"><a href="#super-和-this-的异同" class="headerlink" title="super 和 this 的异同"></a>super 和 this 的异同</h5><blockquote>
<p>super在一个类中用来引用其父类的成员，它是在子类中访问父类成员的一个桥梁，并不是任何一个对象的引用，而this则表示当前类对象的引用。在代码中Object o = super;是错误的，Object o = this;则是允许的。<br>super关键字的作用在于当子类中覆盖了父类的某个成员变量，或者重写了父类的某个成员方法时还能够访问到父类的成员变量和成员方法。如果子类中没有重写父类的成员变量和成员方法，则子类会继承父类的所有非private的成员变量和成员方法。这时在子类中无论通过this来访问成员和通过super来访问成员，结果都是一样的</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存区域</title>
    <url>/2020/09/30/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h4 id="概览图"><a href="#概览图" class="headerlink" title="概览图"></a>概览图</h4><p>java内存区域分布图</p>
<p><img src="http://wrr123.github.io/2020/09/30/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/java内存区域.png" alt></p>
<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java分布式系统</title>
    <url>/2020/09/13/java%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="什么叫分布式系统"><a href="#什么叫分布式系统" class="headerlink" title="什么叫分布式系统"></a>什么叫分布式系统</h4><p>分布式系统是一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。</p>
<p>分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是 <strong>利用更多的机器，处理更多的数据。</strong></p>
<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java初始化list的集中方法</title>
    <url>/2020/11/06/java%E5%88%9D%E5%A7%8B%E5%8C%96list%E7%9A%84%E9%9B%86%E4%B8%AD%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="在-Java-中初始化-List-的几种方法"><a href="#在-Java-中初始化-List-的几种方法" class="headerlink" title="在 Java 中初始化 List 的几种方法"></a>在 Java 中初始化 List 的几种方法</h4><p><img src="http://wrr123.github.io/2020/11/06/java%E5%88%9D%E5%A7%8B%E5%8C%96list%E7%9A%84%E9%9B%86%E4%B8%AD%E6%96%B9%E6%B3%95/001.png" alt></p>
<h5 id="使用-双括号语法"><a href="#使用-双括号语法" class="headerlink" title="使用{ { } }双括号语法"></a>使用<code>&#123; &#123; &#125; &#125;</code>双括号语法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;String&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java初始化二维数组</title>
    <url>/2020/08/11/java%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="定义二维数组"><a href="#定义二维数组" class="headerlink" title="定义二维数组"></a>定义二维数组</h4><ul>
<li><p>先 new 对象，然后再初始化每个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nt[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>]; </span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接赋初值来创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] b = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>new 完对象直接初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2020/11/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="多线程的基本概念"><a href="#多线程的基本概念" class="headerlink" title="多线程的基本概念"></a>多线程的基本概念</h4><p><img src="http://wrr123.github.io/2020/11/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.png" alt></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java定时器Quartz-2.3</title>
    <url>/2020/08/21/java%E5%AE%9A%E6%97%B6%E5%99%A8Quartz-2-3/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Quartz 是基于 Spring 框架之上的更加强大的定时器，它不仅可以实现其他定时器(如 Java 定时器，Soring 定时器)的功能，还实现了非常繁复的时间触发执行的任务， Quartz 有两种方式来调度定时任务，一是使用 Spring 提供的 MethodInvokingJobDetailFactoryBean 代理类，Quartz 通过该代理直接调度任务类的某个函数；二是任务类继承 QuartzJobBean 类或者实现 org.quatrz.Job 接口，Quartz 通过该父类或者接口进行调度。</p>
<span id="more"></span>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul>
<li>基于 XML 文件的方式</li>
<li>基于注解的方式</li>
</ul>
<h4 id="几个核心的概念"><a href="#几个核心的概念" class="headerlink" title="几个核心的概念"></a>几个核心的概念</h4><ol>
<li>Job：是一个接口，只有一个方法void execute(JobExecutionContext context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中；</li>
<li>JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。</li>
<li>Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等；</li>
<li>Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。</li>
<li>Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。</li>
</ol>
<h4 id="cronTrigger-表达式"><a href="#cronTrigger-表达式" class="headerlink" title="cronTrigger 表达式"></a>cronTrigger 表达式</h4><blockquote>
<p><code>Quartz</code>有两大触发器，除了上面使用的<code>SimpleTrigger</code>外，就是<code>CronTrigger</code>。<code>CronTrigger</code>能够提供复杂的触发器表达式的支持。<code>CronTrigger</code>是基于<code>Unix Cron</code>守护进程，它是一个调度程序，支持简单而强大的触发器语法。</p>
<p>使用<code>CronTrigger</code>主要的是要掌握<code>Cron</code>表达式。<code>Cron</code>表达式包含6个必要组件和一个可选组件，如下表所示。</p>
<p>Cron 表达式是由 7个子表达式组成的字符串，描述了时间表的详细信息。<br>格式：[秒] [分] [小时] [日] [月] [周] [年]</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>位置</th>
<th>含义</th>
<th>允许的特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>秒（0~59）</td>
<td>, - * /</td>
</tr>
<tr>
<td>2</td>
<td>分（0~59）</td>
<td>, - * /</td>
</tr>
<tr>
<td>3</td>
<td>小时（0~23）</td>
<td>, - * /</td>
</tr>
<tr>
<td>4</td>
<td>日期（1~31）</td>
<td>, - * / ? L W C</td>
</tr>
<tr>
<td>5</td>
<td>月（JAN~DEC或1~12）</td>
<td>, - * /</td>
</tr>
<tr>
<td>6</td>
<td>星期（SUN~SAT或1~7）</td>
<td>, - * / ? L C #</td>
</tr>
<tr>
<td>7</td>
<td>年（可选，1970~2099），若为空，表示全部时间范围</td>
<td>, - * /</td>
</tr>
</tbody>
</table>
</div>
<p>特殊字符含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特 殊 字 符</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>通配符，任意值</td>
</tr>
<tr>
<td>?</td>
<td>无特定值。通常和其他指定的值一起使用，表示必须显示该值但不能检查</td>
</tr>
<tr>
<td>-</td>
<td>范围。e.g.小时部分10-12表示10:00，11:00， 12:00</td>
</tr>
<tr>
<td>,</td>
<td>列分隔符。可以让你指定一系列的值。e.g.在星期域中指定MON、TUE和WED</td>
</tr>
<tr>
<td>/</td>
<td>增量。表示一个值的增量，e.g.分钟域中0/1表示从0开始，每次增加1min</td>
</tr>
<tr>
<td>L</td>
<td>表示Last。它在日期和星期域中表示有所不同。在日期域中，表示这个月的最后一天，而在星期域中，它永远是7（星期六）。当你希望使用星期中某一天时，L字符非常有用。e.g.星期域中6L表示每一个月的最后一个星期五</td>
</tr>
<tr>
<td>W</td>
<td>在本月内离当天最近的工作日触发，所谓的最近工作日，即当天到工作日的前后最短距离，如果当天即为工作日，则距离是0；所谓本月内指的是不能跨月取到最近工作日，即使前/后月份的最后一天/第一天确实满足最近工作日。e.g. LW表示本月的最后一个工作日触发，W强烈依赖月份。</td>
</tr>
<tr>
<td>#</td>
<td>表示该月的第几个星期，e.g. 1#2表示每一个月的第一个星期一</td>
</tr>
<tr>
<td>C</td>
<td>日历值。日期值是根据一个给定的日历计算出来的。在日期域中给定一个20C将在20日（日历包括20日）或20日后日历中包含的第一天（不包括20日）激活触发器。例如在一个星期域中使用6C表示日历中星期五（日历包括星期五）或者第一天（日历不包括星期五）</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>java开发手册-异常日志</title>
    <url>/2021/01/20/java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C-%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h4 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h4><h5 id="1-【强制】-错误码的制定原则：快速溯源、沟通标准化。"><a href="#1-【强制】-错误码的制定原则：快速溯源、沟通标准化。" class="headerlink" title="1. 【强制】 错误码的制定原则：快速溯源、沟通标准化。"></a>1. <span style="color:brown">【强制】</span> 错误码的制定原则：快速溯源、沟通标准化。</h5><p><span style="color:sienna;">说明：</span> 错误码想得过于完美和复杂，就像康熙字典中的生僻字一样，用词似乎精准，但是字典不容易随身携带并且简单易懂。</p>
<p><span style="color:green;">正例：</span> 错误码回答的问题是谁的错？错在哪？</p>
<ol>
<li>错误码必须能够快速知晓错误来源，可快速判断是谁的问题。</li>
<li>错误码必须能够进行清晰得比对（代码中容易 <code>equals</code>）。</li>
<li>错误码有利于团队快速对错误原因达到一致认知。</li>
</ol>
<h5 id="2-【强制】-错误码不体现版本号和错误等级信息。"><a href="#2-【强制】-错误码不体现版本号和错误等级信息。" class="headerlink" title="2. 【强制】 错误码不体现版本号和错误等级信息。"></a>2. <span style="color:brown;">【强制】</span> 错误码不体现版本号和错误等级信息。</h5><span id="more"></span>
<p><span style="color:sienna;">说明：</span> 错误码以不断追加地方式进行兼容。错误等级由日志和错误码本身的释义来决定。</p>
<h5 id="3-【强制】-全部正常，但不得不填充错误码时返回五个零：00000。"><a href="#3-【强制】-全部正常，但不得不填充错误码时返回五个零：00000。" class="headerlink" title="3. 【强制】 全部正常，但不得不填充错误码时返回五个零：00000。"></a>3. <span style="color:brown;">【强制】</span> 全部正常，但不得不填充错误码时返回五个零：<code>00000</code>。</h5><h5 id="4-【强制】-错误码为字符串类型，共-5-位，分成两个部分：错误产生来源-四位数字编号。"><a href="#4-【强制】-错误码为字符串类型，共-5-位，分成两个部分：错误产生来源-四位数字编号。" class="headerlink" title="4. 【强制】 错误码为字符串类型，共 5 位，分成两个部分：错误产生来源 + 四位数字编号。"></a>4. <span style="color:brown;">【强制】</span> 错误码为字符串类型，共 5 位，分成两个部分：错误产生来源 + 四位数字编号。</h5><p><span style="color:sienna;">说明：</span> 错误产生来源为<code>A/B/C</code>，<code>A</code> 表示错误来源于用户，比如参数错误、用户安装版本过低、用户支付超时等问题；<code>B</code> 表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题；<code>C</code> 表示错误来源于第三方服务，比如 <code>CDN</code> 服务出错，消息投递超时等问题；四位数字编号从 <code>0001</code> 到 <code>9999</code>，大类之间的步长间距预留 <code>100</code>。</p>
<h5 id="5-【强制】-编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行，审批生效，编号即被永久固定。"><a href="#5-【强制】-编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行，审批生效，编号即被永久固定。" class="headerlink" title="5. 【强制】 编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行，审批生效，编号即被永久固定。"></a>5. <span style="color:brown;">【强制】</span> 编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行，审批生效，编号即被永久固定。</h5><h5 id="6-【强制】-错误码使用者避免随意定义新的错误码。"><a href="#6-【强制】-错误码使用者避免随意定义新的错误码。" class="headerlink" title="6. 【强制】 错误码使用者避免随意定义新的错误码。"></a>6. <span style="color:brown;">【强制】</span> 错误码使用者避免随意定义新的错误码。</h5><p><span style="color:sienna;">说明：</span> 尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。</p>
<h5 id="7-【强制】-错误码不能直接输出给用户作为提示信息使用。"><a href="#7-【强制】-错误码不能直接输出给用户作为提示信息使用。" class="headerlink" title="7. 【强制】 错误码不能直接输出给用户作为提示信息使用。"></a>7. <span style="color:brown;">【强制】</span> 错误码不能直接输出给用户作为提示信息使用。</h5><p><span style="color:sienna;">说明：</span> 堆栈（stack_trace）、错误信息（error_message）、错误码（error_code）、提示信息（user_tip）是一个有效关联并互相转义的和谐整体，但是请勿互相越俎代庖。</p>
<h5 id="8-【推荐】-错误码之外的业务独特信息由error-message-来承载，而不是让错误本身涵盖过多具体业务属性。"><a href="#8-【推荐】-错误码之外的业务独特信息由error-message-来承载，而不是让错误本身涵盖过多具体业务属性。" class="headerlink" title="8. 【推荐】 错误码之外的业务独特信息由error_message 来承载，而不是让错误本身涵盖过多具体业务属性。"></a>8. <span style="color:orange;">【推荐】</span> 错误码之外的业务独特信息由<code>error_message</code> 来承载，而不是让错误本身涵盖过多具体业务属性。</h5><h5 id="9-【推荐】-在获取第三方服务错误时，向上抛出允许本系统转义，由-C-转为-B，并且在错误信息上带上原有的第三方错误码。"><a href="#9-【推荐】-在获取第三方服务错误时，向上抛出允许本系统转义，由-C-转为-B，并且在错误信息上带上原有的第三方错误码。" class="headerlink" title="9. 【推荐】 在获取第三方服务错误时，向上抛出允许本系统转义，由 C 转为 B，并且在错误信息上带上原有的第三方错误码。"></a>9. <span style="color:orange;">【推荐】</span> 在获取第三方服务错误时，向上抛出允许本系统转义，由 <code>C</code> 转为 <code>B</code>，并且在错误信息上带上原有的第三方错误码。</h5><h5 id="10-【参考】-错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。"><a href="#10-【参考】-错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。" class="headerlink" title="10. 【参考】 错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。"></a>10. <span style="color:green;">【参考】</span> 错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。</h5><p><span style="color:sienna;">说明：</span> 在无法更加具体确定的错误场景中，可以直接使用一级宏观错误码，分别是：<strong>A0001</strong>(用户端错误)、<strong>B0001</strong>(系统执行出错)、<strong>C0001</strong>(调用第三方服务错误)。</p>
<p><span style="color:green;">正例：</span> 调用第三方服务出错时一级、中间件错误是二级、消息服务出错是三级。</p>
<h5 id="11-【参考】-错误码的后三位编码与-HTTP-状态码没有任何关系。"><a href="#11-【参考】-错误码的后三位编码与-HTTP-状态码没有任何关系。" class="headerlink" title="11. 【参考】 错误码的后三位编码与 HTTP 状态码没有任何关系。"></a>11. <span style="color:green;">【参考】</span> 错误码的后三位编码与 <code>HTTP</code> 状态码没有任何关系。</h5><h5 id="12-【参考】-错误码有利于不同文化背景的开发者进行交流与代码协作。"><a href="#12-【参考】-错误码有利于不同文化背景的开发者进行交流与代码协作。" class="headerlink" title="12. 【参考】 错误码有利于不同文化背景的开发者进行交流与代码协作。"></a>12. <span style="color:green;">【参考】</span> 错误码有利于不同文化背景的开发者进行交流与代码协作。</h5><p><span style="color:sienna;">说明：</span> 英文单词形式的错误码不利于非英语母语国家（如阿拉伯语、希伯来语、俄罗斯语等）之间的开发者互相协作。</p>
<h5 id="13-【参考】-错误码即人性，感性认知-口口相传，使用纯数字来进行错误码编排不利于感性记忆和分类。"><a href="#13-【参考】-错误码即人性，感性认知-口口相传，使用纯数字来进行错误码编排不利于感性记忆和分类。" class="headerlink" title="13. 【参考】 错误码即人性，感性认知 + 口口相传，使用纯数字来进行错误码编排不利于感性记忆和分类。"></a>13. <span style="color:green;">【参考】</span> 错误码即人性，感性认知 + 口口相传，使用纯数字来进行错误码编排不利于感性记忆和分类。</h5><p><span style="color:sienna;">说明：</span> 数字是一个整体，每位数字的地位和含义是相同的。</p>
<p><span style="color:red;">反例：</span> 一个五位数字 <code>12345</code>，第 <code>1</code> 位是错误等级，第 <code>2</code> 位是错误来源，<code>345</code> 是编号，人的大脑不会主动地拆开并分辨每位数字地不同含义。</p>
<h4 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h4><h5 id="1-【强制】-应用中不可直接使用日志系统（Log4j、Logback）中的-API，而应依赖使用日志框架（SLF4J、JCL—Jakarta-Commons-Logging）中的-API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。"><a href="#1-【强制】-应用中不可直接使用日志系统（Log4j、Logback）中的-API，而应依赖使用日志框架（SLF4J、JCL—Jakarta-Commons-Logging）中的-API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。" class="headerlink" title="1. 【强制】 应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架（SLF4J、JCL—Jakarta Commons Logging）中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。"></a>1. <span style="color:brown;">【强制】</span> 应用中不可直接使用日志系统（Log4j、Logback）中的 <code>API</code>，而应依赖使用日志框架（SLF4J、JCL—Jakarta Commons Logging）中的 <code>API</code>，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</h5><p><span style="color:sienna;">说明：</span> 日志框架（SLF4J、JCL-Jakarta Commons Logging）的使用方式（推荐使用 SLF4J）</p>
<p>使用 <code>SLF4J</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Test.class);</span><br></pre></td></tr></table></figure>
<p>使用 <code>JCL</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Test.class);</span><br></pre></td></tr></table></figure>
<h5 id="2-【强制】-所有日志文件至少保存-15-天，因为有些异常具备以-周-为频次发生的特点。对于当天日志，以-应用名-log-来保存，保存在-home-admin-应用名-logs-目录下，过往日志格式为-logname-log-保存日期-，日期格式：yyyy-MM-dd"><a href="#2-【强制】-所有日志文件至少保存-15-天，因为有些异常具备以-周-为频次发生的特点。对于当天日志，以-应用名-log-来保存，保存在-home-admin-应用名-logs-目录下，过往日志格式为-logname-log-保存日期-，日期格式：yyyy-MM-dd" class="headerlink" title="2. 【强制】 所有日志文件至少保存 15 天，因为有些异常具备以 周  为频次发生的特点。对于当天日志，以 应用名.log 来保存，保存在 /home/admin/应用名/logs/ 目录下，过往日志格式为: {logname}.log.{保存日期}，日期格式：yyyy-MM-dd"></a>2. <span style="color:brown;">【强制】</span> 所有日志文件至少保存 15 天，因为有些异常具备以 <code>周</code>  为频次发生的特点。对于当天日志，以 <code>应用名.log</code> 来保存，保存在 <code>/home/admin/应用名/logs/</code> 目录下，过往日志格式为: <code>&#123;logname&#125;.log.&#123;保存日期&#125;</code>，日期格式：<code>yyyy-MM-dd</code></h5><p><span style="color:green;">正例：</span> 以 <code>app</code> 应用为例，日志保存在 <code>/home/admin/appserver/logs/app.log</code>，历史日志名称为 <code>app.log.2017-12-01</code>。</p>
<h5 id="3-【强制】-根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存的日志不少于六个月，并且进行网络多机备份。"><a href="#3-【强制】-根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存的日志不少于六个月，并且进行网络多机备份。" class="headerlink" title="3. 【强制】 根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存的日志不少于六个月，并且进行网络多机备份。"></a>3. <span style="color:brown;">【强制】</span> 根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存的日志不少于六个月，并且进行网络多机备份。</h5><h5 id="4-【强制】-应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName-logType-logName-log"><a href="#4-【强制】-应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName-logType-logName-log" class="headerlink" title="4. 【强制】 应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log."></a>4. <span style="color:brown;">【强制】</span> 应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：<code>appName_logType_logName.log</code>.</h5><ul>
<li><code>logType</code>: 日志类型，如 <code>stats/monitor/access</code>等</li>
<li><code>logName</code>: 日志描述。</li>
</ul>
<p>这种命名的好处：通过文件就可以知道日志文件属于什么应用、什么类型、什么目的，也有利于归类查找。</p>
<p><span style="color:sienna;">说明：</span> 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。</p>
<p><span style="color:green;">正例：</span> <code>mppserver</code> 应用中单独监控时区转换异常，如：<code>mppserver_monitor_timeZoneConvert.log</code>。</p>
<h5 id="5-【强制】-在日志输出时，字符串变量之间的拼接使用占位符的方式。"><a href="#5-【强制】-在日志输出时，字符串变量之间的拼接使用占位符的方式。" class="headerlink" title="5. 【强制】 在日志输出时，字符串变量之间的拼接使用占位符的方式。"></a>5. <span style="color:brown;">【强制】</span> 在日志输出时，字符串变量之间的拼接使用占位符的方式。</h5><p><span style="color:sienna;">说明：</span> 因为 <code>String</code> 字符串的拼接会使用 <code>StringBuilder</code> 的 <code>append()</code> 方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。</p>
<p><span style="color:green;">正例：</span> <code>logger.debug(&quot;Processing trade with id: &#123;&#125; and symbol: &#123;&#125;&quot;, id, symbol);</code></p>
<h5 id="6-【强制】-对于-trace-debug-info-级别的日志输出，必须进行日志级别的开关判断。"><a href="#6-【强制】-对于-trace-debug-info-级别的日志输出，必须进行日志级别的开关判断。" class="headerlink" title="6. 【强制】 对于 trace/debug/info 级别的日志输出，必须进行日志级别的开关判断。"></a>6. <span style="color:brown;">【强制】</span> 对于 <code>trace/debug/info</code> 级别的日志输出，必须进行日志级别的开关判断。</h5><p><span style="color:sienna;">说明：</span> 虽然在 <code>debug(参数)</code>  的方法体内第一行代码 <code>isDisabled(Level.DEBUG_INT)</code> 为真时（<code>Slf4j</code> 的常见实现 <code>Log4j</code> 和 <code>Logback</code>）,就直接 <code>return</code>,但是参数可能会进行字符串拼接运算。此外，如果 <code>debug(getName())</code> 这种参数内有 <code>getName()</code> 方法调用，无谓浪费方法调用的开销。</p>
<p><span style="color:green;">正例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果判断为真，那么可以输出 trace 和 debug 级别的日志</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Current ID is: &#123;&#125; and name is: &#123;&#125;&quot;</span>, id, getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-【强制】-避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置-additivity-false。"><a href="#7-【强制】-避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置-additivity-false。" class="headerlink" title="7. 【强制】 避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置 additivity = false。"></a>7. <span style="color:brown;">【强制】</span> 避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置 <code>additivity = false</code>。</h5><p><span style="color:green;">正例：</span> <code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></p>
<h5 id="8-【强制】-生产环境禁止直接使用-System-out-或-System-err-输出日志或使用e-printStackTrace-打印异常堆栈。"><a href="#8-【强制】-生产环境禁止直接使用-System-out-或-System-err-输出日志或使用e-printStackTrace-打印异常堆栈。" class="headerlink" title="8. 【强制】 生产环境禁止直接使用 System.out 或 System.err 输出日志或使用e.printStackTrace() 打印异常堆栈。"></a>8. <span style="color:brown;">【强制】</span> 生产环境禁止直接使用 <code>System.out</code> 或 <code>System.err</code> 输出日志或使用<code>e.printStackTrace()</code> 打印异常堆栈。</h5><p><span style="color:sienna;">说明：</span> 标准日志输出和标准错误输出文件每次 <code>Jboss</code> 重启时才滚动，如果大量输出送出这两个文件，容易造成文件大小超出操作系统大小限制。</p>
<h5 id="9-【强制】-异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字-throws-向上抛出。"><a href="#9-【强制】-异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字-throws-向上抛出。" class="headerlink" title="9. 【强制】 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 向上抛出。"></a>9. <span style="color:brown;">【强制】</span> 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 <code>throws</code> 向上抛出。</h5><p><span style="color:green;">正例：</span> </p>
<p><code>logger.error(&quot;inputParams: &#123;&#125; and errorMessage: &#123;&#125;&quot;, 各类参数或者对象 toString(), e.getMessage(), e)</code></p>
<h5 id="10-【强制】-日志打印时禁止直接使用-JSON-工具将对象转换为-String。"><a href="#10-【强制】-日志打印时禁止直接使用-JSON-工具将对象转换为-String。" class="headerlink" title="10. 【强制】 日志打印时禁止直接使用 JSON 工具将对象转换为 String。"></a>10. <span style="color:brown;">【强制】</span> 日志打印时禁止直接使用 <code>JSON</code> 工具将对象转换为 <code>String</code>。</h5><p><span style="color:sienna;">说明：</span> 如果对象里某些 <code>get</code> 方法被覆写，存在抛出异常的情况，则可能会因为打印日志而影响正常业务流程的执行。</p>
<p><span style="color:green;">正例：</span> 打印日志仅打印出业务相关属性值或者调用其对象的 <code>toString()</code> 方法。</p>
<h5 id="11-【推荐】-谨慎的记录日志。生产环境禁止输出-debug-日志；有选择地输出-info-日志；如果使用-warn-来记录刚上线的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。"><a href="#11-【推荐】-谨慎的记录日志。生产环境禁止输出-debug-日志；有选择地输出-info-日志；如果使用-warn-来记录刚上线的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。" class="headerlink" title="11. 【推荐】 谨慎的记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。"></a>11. <span style="color:orange;">【推荐】</span> 谨慎的记录日志。生产环境禁止输出 <code>debug</code> 日志；有选择地输出 <code>info</code> 日志；如果使用 <code>warn</code> 来记录刚上线的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。</h5><p><span style="color:sienna;">说明：</span> 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p>
<h5 id="12-【推荐】-可以使用-warn-日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出-error-日志，避免频繁报警。"><a href="#12-【推荐】-可以使用-warn-日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出-error-日志，避免频繁报警。" class="headerlink" title="12. 【推荐】 可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 日志，避免频繁报警。"></a>12. <span style="color:orange;">【推荐】</span> 可以使用 <code>warn</code> 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 <code>error</code> 日志，避免频繁报警。</h5><p><span style="color:sienna;">说明：</span> 注意日志输出的级别，<code>error</code> 级别只记录系统逻辑出错、异常或重要的错误信息。</p>
<h5 id="13-【推荐】-尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。"><a href="#13-【推荐】-尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。" class="headerlink" title="13. 【推荐】 尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。"></a>13. <span style="color:orange;">【推荐】</span> 尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。</h5><p><span style="color:sienna;">说明：</span> 国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java快慢指针</title>
    <url>/2020/08/18/java%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h4 id="一个问题：判断一个单向链表是否为环形链表"><a href="#一个问题：判断一个单向链表是否为环形链表" class="headerlink" title="一个问题：判断一个单向链表是否为环形链表"></a>一个问题：判断一个单向链表是否为环形链表</h4><p>“快慢指针” 的思路：</p>
<p>当我们在遍历链表的时候，设计两个指针，分别为快指针和慢指针，快指针每次走 2 步，慢指针每次走 1 步，这样的话当我们的两个指针在链表中，如果第二次相遇的话，说明这个链表是环形链表。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看 链表中是否存在环形</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasRing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;T&gt; fastTemp = head, lowTemp = head;</span><br><span class="line">        <span class="keyword">while</span> (lowTemp.getNext() != <span class="keyword">null</span> &amp;&amp; fastTemp.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fastTemp = fastTemp.getNext().getNext();</span><br><span class="line">            lowTemp = lowTemp.getNext();</span><br><span class="line">            <span class="keyword">if</span> (lowTemp == fastTemp) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j],我们就增加 j 以跳过该重复项。</p>
<p>当我们遇到 nums[i] 不等于 nums[j] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将重复相同的过程，直到 j 到达数组的末尾为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java排列组合算法</title>
    <url>/2020/10/21/java%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="组合和排列的区别"><a href="#组合和排列的区别" class="headerlink" title="组合和排列的区别"></a>组合和排列的区别</h4><p>排列：需要考虑取出元素的顺序。</p>
<p>组合：组合取出元素的顺序是不考虑的。</p>
<p><strong>因组合是不考虑顺序的，故组合的个数比排列的个数要少。</strong></p>
<p>计算公式：</p>
<p><img src="http://wrr123.github.io/2020/10/21/java%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95/002.png" alt></p>
<span id="more"></span>
<h4 id="经典的案例：从-n-个数中取出-m-个数的组合"><a href="#经典的案例：从-n-个数中取出-m-个数的组合" class="headerlink" title="经典的案例：从 n 个数中取出 m 个数的组合"></a>经典的案例：从 n 个数中取出 m 个数的组合</h4><p>实现方法一</p>
<p><img src="http://wrr123.github.io/2020/10/21/java%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95/001.png" alt></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java数组扩容</title>
    <url>/2020/08/11/java%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h4 id="数组扩容的几个方法"><a href="#数组扩容的几个方法" class="headerlink" title="数组扩容的几个方法"></a>数组扩容的几个方法</h4><h5 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] copy = Arrays.copyOf(array, <span class="number">2</span> * array.length);</span><br><span class="line"><span class="comment">// 第一个参数为原数组对象</span></span><br><span class="line"><span class="comment">// 第二个参数为新数组的长度</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="使用动态的-ArrayList-类"><a href="#使用动态的-ArrayList-类" class="headerlink" title="使用动态的 ArrayList 类"></a>使用动态的 <code>ArrayList</code> 类</h5><p>它可以随意的添加或删除元素，而不用考虑自身的长度问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 将arrayList转换成数组</span></span><br><span class="line">Object[] objs = staff.toArray();</span><br></pre></td></tr></table></figure>
<h4 id="延申：ArrayList-和-LinkedList-之间的区别"><a href="#延申：ArrayList-和-LinkedList-之间的区别" class="headerlink" title="延申：ArrayList 和 LinkedList 之间的区别"></a>延申：ArrayList 和 LinkedList 之间的区别</h4><ul>
<li>ArrayList 的实现是基于数组的，LinkedList 的实现是基于双向链表。</li>
<li>对于随机访问，ArrayList 优于 LinkedList。</li>
<li>对于插入和删除操作，LinkedList 优于 ArrayList。</li>
<li>LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，另一个指向后一个元素。</li>
</ul>
<p><strong>ArrayList 使用一个内置数组来存储元素，起始容量是 10， 当数组需要扩容时，扩容公式为 <code>(old * 3) / 2 + 1</code>，也就是说每次容量会增加 50%。这意味着如果包含大量元素，将会浪费很大的空间。这种浪费是由 ArrayList 本身决定的。</strong></p>
<h4 id="Java复制数组的几个方法"><a href="#Java复制数组的几个方法" class="headerlink" title="Java复制数组的几个方法"></a>Java复制数组的几个方法</h4><ul>
<li><p>Arrays类的 <code>copy()</code> 方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.copyOf(dataType[] srcArray,<span class="keyword">int</span> length);</span><br></pre></td></tr></table></figure>
<p>  其中，srcArray 表示要进行复制的数组，length 表示复制后的新数组的长度。</p>
<p>  <strong>注意：目标数组如果已经存在，将会被重构。</strong></p>
</li>
<li><p>Arrays类的 <code>copyOfRange()</code>方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.copyOfRange(dataType[] srcArray,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span><br></pre></td></tr></table></figure>
<p>  其中：</p>
<blockquote>
<ul>
<li>srcArray 表示原数组。</li>
<li>startIndex 表示开始复制的起始索引，目标数组中将包含起始索引对应的元素，另外，startIndex 必须在 0 到 srcArray.length 之间。</li>
<li>endIndex 表示终止索引，目标数组中将不包含终止索引对应的元素，endIndex 必须大于等于 startIndex，可以大于 srcArray.length，如果大于 srcArray.length，则目标数组中使用默认值填充。</li>
</ul>
</blockquote>
<p>  <strong>注意：目标数组如果已经存在，将会被重构。</strong></p>
</li>
<li><p>System类的 <code>arraycopy()</code> 方法</p>
</li>
<li><p>Object类的 <code>clone()</code> 方法</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java新特性</title>
    <url>/2020/11/09/java%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h4 id="Optional类的使用"><a href="#Optional类的使用" class="headerlink" title="Optional类的使用"></a><code>Optional</code>类的使用</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>这是在 Java8 引入的新特性，该类主要用来处理每个程序员都碰到过的麻烦问题——空指针异常(NullPointerException)。</p>
<p>从本质上来说，该类属于包含可选值的封装类（wrapper class），因此它既可以包含对象也可以仅仅为空。</p>
<p>一个简单的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenEmptyValue_thenReturnDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="string">&quot;anna@gmail.com&quot;</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    User result = Optional.ofNullable(user).orElse(user2);</span><br><span class="line"></span><br><span class="line">    assertEquals(user2.getEmail(), result.getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="使用Optional来解决空指针的问题？"><a href="#使用Optional来解决空指针的问题？" class="headerlink" title="使用Optional来解决空指针的问题？"></a>使用<code>Optional</code>来解决空指针的问题？</h5><p>使用<code>Optional.ofNullable()</code>将可能为空值的变量作为实参传入到这个方法中，之后使用<code>Optional.ifPresent()（如果实参不为空，就执行该实参的消费方法，否则什么都不做）</code>进行后续操作。</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>所谓方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。</p>
<p><strong>注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系。</strong></p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Lemon&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(array, String::compareTo);</span><br><span class="line">        System.out.println(String.join(<span class="string">&quot;, &quot;</span>, array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h6><p>除了可以使用静态方法和实例方法，我们还可以引用构造方法。</p>
<p>引用方法的几种方式：</p>
<ul>
<li><code>对象引用::实例方法</code></li>
<li><code>类名::静态方法</code></li>
<li><code>类名::实例方法</code></li>
</ul>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用构造方法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">        List&lt;Person&gt; persons = names.stream().map(Person::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person:&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="引用数组"><a href="#引用数组" class="headerlink" title="引用数组"></a>引用数组</h6><p>引用数组和引用构造器很像，格式为<code>类型[]::new</code>,其中类型可以为基本类型也可以是类。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function&lt;Integer, int[]&gt; fun = n -&gt; new int[n];</span></span><br><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Integer, Integer[]&gt; fun2 = Integer[]::<span class="keyword">new</span>;</span><br><span class="line">Integer[] arr2 = fun2.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Java-8-中-Collectors-的方法"><a href="#Java-8-中-Collectors-的方法" class="headerlink" title="Java 8 中 Collectors 的方法"></a>Java 8 中 <code>Collectors</code> 的方法</h4><p><code>Collectors</code> 提供了一系列的静态方法供我们使用，通常情况下我们静态导入即可。</p>
<h5 id="类型归纳"><a href="#类型归纳" class="headerlink" title="类型归纳"></a>类型归纳</h5><p>其作用是将元素归纳进可变容器 <code>List, Map, Set, Collection 或者 ConcurrentMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collectors.toList();</span><br><span class="line">  Collectors.toMap();</span><br><span class="line">  Collectors.toSet();</span><br><span class="line">  Collectors.toCollection();</span><br><span class="line">  Collectors.toConcurrentMap();</span><br></pre></td></tr></table></figure>
<h5 id="joining"><a href="#joining" class="headerlink" title="joining"></a>joining</h5><p>将元素以某种规则连接起来。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   输出 FelordcnTomcatJettyUndertowResin</span></span><br><span class="line"> servers.stream().collect(Collectors.joining());</span><br><span class="line"></span><br><span class="line"> <span class="comment">//   输出 Felordcn,Tomcat,Jetty,Undertow,Resin</span></span><br><span class="line"> servers.stream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span> ));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//   输出 [Felordcn,Tomcat,Jetty,Undertow,Resin]</span></span><br><span class="line"> servers.stream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>)); </span><br></pre></td></tr></table></figure>
<h5 id="collectingAndThen"><a href="#collectingAndThen" class="headerlink" title="collectingAndThen"></a><code>collectingAndThen</code></h5><blockquote>
<p>该方法先执行了一个归纳操作，然后再对归纳的结果进行 <code>Function</code> 函数处理输出一个新的结果。</p>
</blockquote>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如我们将servers joining 然后转成大写，结果为： FELORDCN,TOMCAT,JETTY,UNDERTOW,RESIN   </span></span><br><span class="line"> servers.stream.collect(Collectors.collectingAndThen(Collectors.joining(<span class="string">&quot;,&quot;</span>), String::toUpperCase));</span><br></pre></td></tr></table></figure>
<h5 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a><code>groupingBy</code></h5><blockquote>
<p>按照条件对元素进行分组，和 <strong>SQL</strong> 中的 <code>group by</code> 用法有异曲同工之妙，通常也建议使用 <strong>Java</strong> 进行分组处理以减轻数据库压力。<code>groupingBy</code> 也有三个重载方法</p>
</blockquote>
<ol>
<li><p>第一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</span><br><span class="line">Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                      Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>它可以对元素进行第一次分组之后，再次对另一个字段进行分组</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二次分组，先按类别分组，再按分数分组</span></span><br><span class="line">Map&lt;Integer, Map&lt;Integer, List&lt;Sample&gt;&gt;&gt; second = samples.stream().collect(Collectors.groupingBy(x -&gt; x.type, Collectors.groupingBy(x -&gt; x.score)));</span><br><span class="line"><span class="comment">// 分组后，reduce</span></span><br><span class="line"> Map&lt;Integer, Optional&lt;Integer&gt;&gt; fifth = samples.stream().collect(Collectors.groupingBy(x -&gt; x.type, Collectors.mapping(x -&gt; x.score, Collectors.reducing((x, y) -&gt; x + y))));</span><br><span class="line"><span class="comment">// 分组后，获取最大值</span></span><br><span class="line">Map&lt;Integer, Optional&lt;Sample&gt;&gt; forth = samples.stream().collect(Collectors.groupingBy(x -&gt; x.type, Collectors.maxBy((x, y) -&gt; x.score - y.score)));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>第三个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;</span><br><span class="line">Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                              Supplier&lt;M&gt; mapFactory,</span><br><span class="line">                              Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="partitioningBy"><a href="#partitioningBy" class="headerlink" title="partitioningBy"></a><code>partitioningBy</code></h5><h5 id="counting"><a href="#counting" class="headerlink" title="counting"></a><code>counting</code></h5><h5 id="maxBy-minBy"><a href="#maxBy-minBy" class="headerlink" title="maxBy/minBy"></a><code>maxBy/minBy</code></h5><p>这个两个方法分别提供了查找大小元素的操作。</p>
<h5 id="summingInt-Long-Double"><a href="#summingInt-Long-Double" class="headerlink" title="summingInt/Long/Double"></a><code>summingInt/Long/Double</code></h5><p>用来做累加计算。</p>
<h5 id="summarizingInt-Long-Double"><a href="#summarizingInt-Long-Double" class="headerlink" title="summarizingInt/Long/Double"></a><code>summarizingInt/Long/Double</code></h5><blockquote>
<p>这三个方法通过对元素某个属性的提取，会返回对元素该属性的统计数据对象，分别对应 <code>IntSummaryStatistics</code>、<code>DoubleSummaryStatistics</code>、<code>LongSummaryStatistics</code></p>
</blockquote>
<h5 id="mapping"><a href="#mapping" class="headerlink" title="mapping"></a>mapping</h5><blockquote>
<p>该方法是先对元素使用 <code>Function</code> 进行再加工操作，然后用另一个<code>Collector</code> 归纳。比如我们先去掉 <code>servers</code> 中元素的首字母，然后将它们装入 <code>List</code> 。</p>
</blockquote>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [elordcn, omcat, etty, ndertow, esin]</span></span><br><span class="line"> servers.stream.collect(Collectors.mapping(s -&gt; s.substring(<span class="number">1</span>), Collectors.toList()));</span><br></pre></td></tr></table></figure>
<h5 id="reducing"><a href="#reducing" class="headerlink" title="reducing"></a><code>reducing</code></h5>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java日志框架</title>
    <url>/2020/10/23/java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h4 id="java-日志框架的等级和优先级"><a href="#java-日志框架的等级和优先级" class="headerlink" title="java 日志框架的等级和优先级"></a>java 日志框架的等级和优先级</h4><p>log4j 定义了 8 个级别的 log ，优先级 <strong>从高到低</strong> 依次为：</p>
<p><code>OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL</code> 。</p>
<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java泛型中通配符T和问号的区别</title>
    <url>/2020/07/13/java%E6%B3%9B%E5%9E%8B%E4%B8%AD%E9%80%9A%E9%85%8D%E7%AC%A6T%E5%92%8C%E9%97%AE%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>这种参数类型可以用在类、接口和方法的创建中，分别为泛型类、泛型接口和泛型方法。</p>
<h4 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h4><blockquote>
<p>在Java SE 1.5之前，没有泛型的<a href="http://baike.baidu.com/view/780206.htm">情况</a>的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的<a href="http://baike.baidu.com/view/2886403.htm">强制类型转换</a>，而这种转换是要求开发者对<a href="http://baike.baidu.com/view/2245196.htm">实际参数</a>类型可以预知的情况下进行的。对于强制类型转换错误的情况，<a href="http://baike.baidu.com/view/487018.htm">编译器</a>可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</p>
<p>泛型的好处是在编译的时候检查<a href="http://baike.baidu.com/view/1965709.htm">类型安全</a>，并且所有的<a href="http://baike.baidu.com/view/965170.htm">强制转换</a>都是自动和<a href="http://baike.baidu.com/view/2852863.htm">隐式</a>的，以提高代码的重用率。</p>
</blockquote>
<h4 id="什么是泛型？为什么要使用泛型？"><a href="#什么是泛型？为什么要使用泛型？" class="headerlink" title="什么是泛型？为什么要使用泛型？"></a>什么是泛型？为什么要使用泛型？</h4><blockquote>
<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<h4 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h4><ul>
<li><p>泛型类</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class="line">  private 泛型标识 /*（成员变量类型）*/ var; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型方法</p>
<p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>通配符基本使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;?&gt; <span class="comment">//任意类型的ArrayList</span></span><br><span class="line">ArrayList&lt;? extends T&gt; <span class="comment">//继承自T的任意类型的ArrayList</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> T&gt; <span class="comment">//T或者是T的子类的任意类型的ArrayList</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java深度优先搜索</title>
    <url>/2020/08/11/java%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><h5 id="英文缩写"><a href="#英文缩写" class="headerlink" title="英文缩写"></a>英文缩写</h5><p>DFS(Depth First Search)</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>所谓深度优先搜索( <strong>亦称为回溯法</strong> )，是从图的一个顶点出发，每次遍历当前访问顶点的临界点，一直到访问的顶点没有未被访问的临界点为止。然后采用依次回退的方式，查看来的路上每一个顶点是否有其他未被访问的临界点。访问完成后，判断图中的顶点是否已经全部完成遍历，如果没有，以未访问的顶点为起始点，重复上述的过程。</p>
<p><strong>深度优先搜索是一个不断回溯的过程。</strong></p>
<span id="more"></span>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><h5 id="英文缩写-1"><a href="#英文缩写-1" class="headerlink" title="英文缩写"></a>英文缩写</h5><p>BFS(Breadth First Search)</p>
<p>亦称为 “宽度优先搜索”，“横向优先搜索”</p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>其类似于树的层次遍历。从图中的某一顶点出发，遍历每个顶点时，依次遍历其所有的邻接点，然后从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。</p>
<p>最后还需要做的操作就是查看图中是否存在尚未被访问的顶点，若有，则以该顶点为起始点，重复上述的过程。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java源码</title>
    <url>/2020/12/15/java%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h5 id="lastIndexOf-int-ch-int"><a href="#lastIndexOf-int-ch-int" class="headerlink" title="lastIndexOf(int ch) : int"></a>lastIndexOf(int ch) : int</h5><p>注释：Return the index within this string of the last occurrence of the specified character.</p>
<p>For values of <strong>ch</strong> in the range from <code>0</code> to <code>0xFFFF</code> (inclusive), the index (in Unicode code units) returned is the largest value <strong><em>i</em></strong>  such that:</p>
<p><code>this.charAt(k) == ch</code></p>
<p>is true. for other value of <strong>ch</strong> , it is the largest value <strong><em>k</em></strong> such that:</p>
<p><code>this.codePointAt(k) == ch</code></p>
<p>is true. In either case, if no such character occurs in this string, then <code>-1</code> is returned. the <strong>string</strong> is searched backwards starting at the last character.</p>
<span id="more"></span>
<h5 id="indexOf-String-str-int"><a href="#indexOf-String-str-int" class="headerlink" title="indexOf(String str) : int"></a>indexOf(String str) : int</h5><p>注释：Returns the index within this string of the first occurrence of the specified substring.</p>
<h5 id="indexOf-char-source-int-sourceOffset-int-sourceCount-char-target-int-targetOffset-int-targetCount-int-fromIndex-int"><a href="#indexOf-char-source-int-sourceOffset-int-sourceCount-char-target-int-targetOffset-int-targetCount-int-fromIndex-int" class="headerlink" title="indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) : int"></a>indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) : int</h5><p>注释：Code shared by String and StringBuffer to do searches. The source is the character array being searched, and the target is the string being searched for.</p>
<h5 id="lastIndexOf-String-str-int"><a href="#lastIndexOf-String-str-int" class="headerlink" title="lastIndexOf(String str) : int"></a>lastIndexOf(String str) : int</h5><p>注释: Returns the index within this string of the last occurrence of the specified substring. The last occurrence of the empty string <code>&quot;&quot;</code> is considered to occur at the index value <strong><code>this.length()</code></strong> .</p>
<p>The returned index is the largest value <strong>k</strong> for which:</p>
<p><code>this.startsWith(str, k)</code></p>
<p>If no such value of <strong>k</strong> exists, then <code>-1</code> is returned.</p>
<h5 id="lastIndexOf-char-source-int-sourceOffset-int-sourceCount-char-target-int-targetOffset-int-targetCount-int-fromIndex-int"><a href="#lastIndexOf-char-source-int-sourceOffset-int-sourceCount-char-target-int-targetOffset-int-targetCount-int-fromIndex-int" class="headerlink" title="lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) : int"></a>lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) : int</h5><p>注释: Code shared by <strong>String</strong> and <strong>StringBuffer</strong> to do searches. The source is the character array being searched,and the target is the string being searched for.</p>
<p><strong>给循环添加别名来直接跳出for、while循环，而不是仅仅跳出当前循环。</strong></p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">startSearchForLastChar:</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>, start = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span>[] source = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>], target = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source[j--] != target[k--]) &#123;</span><br><span class="line">                <span class="keyword">continue</span> startSearchForLastChar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...    </span><br></pre></td></tr></table></figure>
<h5 id="subString-int-beginIndex-String"><a href="#subString-int-beginIndex-String" class="headerlink" title="subString(int beginIndex) : String"></a>subString(int beginIndex) : String</h5><p>注释： Returns a string that is a substring of this string. The substring begins with the character at the specified index and extends to the end of this string.</p>
<p>几个方法使用的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;unhappy&quot;</span>.substring(<span class="number">2</span>) <span class="comment">// &quot;happy&quot;</span></span><br><span class="line"><span class="string">&quot;Harbison&quot;</span>.substring(<span class="number">3</span>) <span class="comment">// &quot;bison&quot;</span></span><br><span class="line"><span class="string">&quot;emptiness&quot;</span>.substring(<span class="number">9</span>) <span class="comment">// &quot;&quot;    </span></span><br></pre></td></tr></table></figure>
<h5 id="substring-int-beginIndex-int-endIndex-String"><a href="#substring-int-beginIndex-int-endIndex-String" class="headerlink" title="substring(int beginIndex, int endIndex) : String"></a>substring(int beginIndex, int endIndex) : String</h5><p>注释: Returns a string that is a substring if this string. The substring begins at the specified <strong>beginIndex</strong> and extends to the character at index <strong><code>endIndex - 1</code></strong> . Thus the length of the substring is <strong><code>endIndex - beginIndex</code></strong> .</p>
<p>几个方法使用的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hamburger&quot;</span>.substring(<span class="number">4</span>, <span class="number">8</span>) <span class="comment">// &quot;urge&quot;</span></span><br><span class="line"><span class="string">&quot;simles&quot;</span>.substring(<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// &quot;imle&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="subSequence-int-beginIndex-int-endIndex-CharSequence"><a href="#subSequence-int-beginIndex-int-endIndex-CharSequence" class="headerlink" title="subSequence(int beginIndex, int endIndex) : CharSequence"></a>subSequence(int beginIndex, int endIndex) : CharSequence</h5><p>注释: Returns a character sequence that is a subsequence of this sequence.</p>
<p><strong>java8开始，在匿名内部类使用外部变量是，要么是使用final修饰的，要么是自初始化值之后，值不会被改变。</strong></p>
<h5 id="replace-char-oldChar-char-newChar-String"><a href="#replace-char-oldChar-char-newChar-String" class="headerlink" title="replace(char oldChar, char newChar) : String"></a>replace(char oldChar, char newChar) : String</h5><p>注释: returns a string resulting from replacing all occurrences of <strong>oldChar</strong> in this string with <strong>newChar</strong> .</p>
<p>几个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;mesquite in your cellar&quot;</span>.replace(<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>) <span class="comment">// &quot;mosquite in your collar&quot;</span></span><br><span class="line"> <span class="string">&quot;JonL&quot;</span>.replace(<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;x&#x27;</span>) <span class="comment">// &quot;JonL&quot; (no change)</span></span><br></pre></td></tr></table></figure>
<h5 id="matches-String-regex-boolean"><a href="#matches-String-regex-boolean" class="headerlink" title="matches(String regex) : boolean"></a>matches(String regex) : boolean</h5><p>注释: Tells whether or not this string matches the given <strong>regular expression</strong> .</p>
<p>An invocation of this method of form <strong>str</strong> <code>.matches(regex)</code> yields exactly the same result as the expression </p>
<p><code>java.util.regex.Pattern.matches(String, CharSequence)</code> </p>
<p><code>matches(regex, str)</code>.</p>
<h5 id="contains-CharSequence-s-boolean"><a href="#contains-CharSequence-s-boolean" class="headerlink" title="contains(CharSequence s) : boolean"></a>contains(CharSequence s) : boolean</h5><p>注释: Returns true if and only if this string contains the specified sequence of char values.</p>
<h5 id="replaceFirst-String-regex-replacement-String"><a href="#replaceFirst-String-regex-replacement-String" class="headerlink" title="replaceFirst(String regex, replacement) : String"></a>replaceFirst(String regex, replacement) : String</h5><p>注释: replaces the first substring of this string that matches the given <strong>regular expression</strong> with the given replacement.</p>
<p>这等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pattern.compile(regex)</span><br><span class="line">Pattern.matcher(CharSequence)</span><br><span class="line">Matcher.replaceFirst(replacement)</span><br></pre></td></tr></table></figure>
<h5 id="replaceAll-String-regex-String-replacement-String"><a href="#replaceAll-String-regex-String-replacement-String" class="headerlink" title="replaceAll(String regex, String replacement) : String"></a>replaceAll(String regex, String replacement) : String</h5><p>注释: Replaces each substring of this string that matches the given <strong>regular expression</strong> with the given replacement.</p>
<p><strong>java8中，类的实例方法和变量的实例方法一样吗?</strong></p>
<p>形式：</p>
<ul>
<li><p>instance::MethodName</p>
<p>没有隐式的参数传递。</p>
</li>
<li><p>ClassName::MethodName</p>
<p>这个会隐式的传递一个 <strong>this</strong> 变量，作为第一个参数。</p>
</li>
</ul>
<h5 id="split-String-regex-int-limit-String"><a href="#split-String-regex-int-limit-String" class="headerlink" title="split(String regex, int limit) : String[]"></a>split(String regex, int limit) : String[]</h5><p>注释: Splits this string around matches of the given <strong>regular expression</strong> .</p>
<p>
    The array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. The substrings in the array are int the order in which they occur in this string. If the expression does not match any part of the input then the resulting array has just one element, namely this string.
</p>

<p>
    When there is a positive-width match at the beginning of this string then an empty leading substring is included at the beginning of the resulting array.
    A zero-width match at the beginning however never produces such empty leading substring.
</p>

<p>
    The <code>limit</code> parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array. If the limit <i>n</i> is greater than zero then the pattern will be applied at most <i>n</i> &nbsp;-&nbsp;1 times,the array's length will be no greater than <i>n</i>, and the array's last entry will contain all input beyond the last matched delimiter. If <i>n</i> is non-positive then the pattern will be applied as many times as possible and the array can have any length. If <i>n</i> is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded.
</p>

<h5 id="static-join-CharSequence-delimiter-CharSequence…-elements-String"><a href="#static-join-CharSequence-delimiter-CharSequence…-elements-String" class="headerlink" title="static join(CharSequence delimiter, CharSequence… elements) : String"></a>static join(CharSequence delimiter, CharSequence… elements) : String</h5><p>Returns a new String composed of copies of <code>CharSequence element</code> joined together with a copy of the specified <code>delimeter</code> .</p>
<blockquote>
    For example,
    <pre>
        <code>
            String message = String.join("-", "Java", "is", "cool");
            // message returned is: "Java-is-cool"
        </code>
    </pre>
</blockquote>

<p>Note that if an element is null, then <code>&quot;null&quot;</code> is added.</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java科学计数法</title>
    <url>/2020/08/22/java%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/</url>
    <content><![CDATA[<h4 id="什么叫-Java-的科学计数法"><a href="#什么叫-Java-的科学计数法" class="headerlink" title="什么叫 Java 的科学计数法"></a>什么叫 Java 的科学计数法</h4><h5 id="1-有效数字"><a href="#1-有效数字" class="headerlink" title="1. 有效数字"></a>1. 有效数字</h5><p>在一个近似数中，从左边第一个不是 0 的数字起，到精确到的位数止，这中间的所有数字都叫做这个近似数的有效数字。</p>
<p>一个栗子：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">890314000保留三位有效数字为8.90×10的8次方 （四舍）</span><br><span class="line">839960000保留三位有效数字为8.40×10的8次方 （五入）</span><br><span class="line">0.00934593保留三位有效数字为9.35×10的-3次方</span><br></pre></td></tr></table></figure>
<h5 id="2-E-记号"><a href="#2-E-记号" class="headerlink" title="2. E 记号"></a>2. E 记号</h5><blockquote>
<p>大多数计算器及计算机程序用科学记数法显示非常大和非常小的结果。因为指数上标（例如1011）在屏幕上显示不方便，字母E或e通常是用来代表的十次幂（写作“×10b”），E或e之后的数字是它的指数；换句话说，任何两实数a和b（b应为整数），“aEb”所表示的值是a × 10b。注意，这种用法中字母e不是数学常数e，也不是指数函数exp()（采用用大写字母E显示可以更大程度地避免误解）；尽管它也表示指数，但这个符号通常被称为（科学计数法）E或e符号，而不是指数中的底数符号（尽管后者也会出现）。在正式的出版物中尽量不要使用这种显示方法。<br>注意科学记数法中的e或E与数学常数e或函数exp没有关系。<br>这种写法是因为一些计算机程序中不方便写上标而产生的，在正式出版物中不应当使用这种写法。<br>我国国家标准中科学计数法均用a ×10b的形式表示，而不是aEb（参见GB3101-1993，GBT15835-2011，GBT8170-2008）。</p>
</blockquote>
<h4 id="Java-中的科学计数法"><a href="#Java-中的科学计数法" class="headerlink" title="Java 中的科学计数法"></a>Java 中的科学计数法</h4><h5 id="在-Java-中，当-double-的取值范围符合条件时，将会以科学计数法的形式显示。"><a href="#在-Java-中，当-double-的取值范围符合条件时，将会以科学计数法的形式显示。" class="headerlink" title="在 Java 中，当 double 的取值范围符合条件时，将会以科学计数法的形式显示。"></a>在 Java 中，当 double 的取值范围符合条件时，将会以科学计数法的形式显示。</h5><h5 id="三个处理科学计数法的类"><a href="#三个处理科学计数法的类" class="headerlink" title="三个处理科学计数法的类"></a>三个处理科学计数法的类</h5><ol>
<li>NumberFormat</li>
<li>DecimalFormat</li>
<li>BigDecimal</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java算法</title>
    <url>/2020/11/11/java%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java类图</title>
    <url>/2020/09/16/java%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h4 id="IDEA-开发工具中，java-类图"><a href="#IDEA-开发工具中，java-类图" class="headerlink" title="IDEA 开发工具中，java 类图"></a>IDEA 开发工具中，java 类图</h4><h5 id="一些线条解释"><a href="#一些线条解释" class="headerlink" title="一些线条解释"></a>一些线条解释</h5><ul>
<li>单箭头蓝色实线 <strong>类继承类</strong></li>
<li>单箭头绿色实线 <strong>接口继承接口</strong></li>
<li>单箭头绿色虚线 <strong>类实现接口</strong></li>
</ul>
<h5 id="延伸-1：Set-里面的-key-值不能重复，为什么？"><a href="#延伸-1：Set-里面的-key-值不能重复，为什么？" class="headerlink" title="延伸-1：Set 里面的 key 值不能重复，为什么？"></a>延伸-1：Set 里面的 key 值不能重复，为什么？</h5>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式</title>
    <url>/2020/09/21/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
<p>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码的可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块基石一样。项目中合理的使用设计模式可以完美的解决很多问题，每种模式在现实中都有相应的原理来与之对应，每一种模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它被广泛应用的原因。</p>
<p>简单来说:</p>
<ul>
<li>模式：在某些场景下，针对某类问题的某种通用的解决方案</li>
<li>场景：项目所在的环境</li>
<li>问题：约束条件，项目目标等</li>
<li>解决方案：通用、可复用的设计，解决约束达到目标</li>
</ul>
<span id="more"></span>
<h4 id="设计模式的三个分类"><a href="#设计模式的三个分类" class="headerlink" title="设计模式的三个分类"></a>设计模式的三个分类</h4><p>创建型模式：对象实例化的模式，创新型模式用于解耦对象的实例化过程</p>
<p>结构性模式：把类或对象结合在一起形成一个更大的结构</p>
<p>行为型模式：类和对象如何交互，及划分责任和算法。</p>
<p><img src="http://wrr123.github.io/2020/09/21/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/001.png" alt></p>
<h4 id="各分类模式中的关键点"><a href="#各分类模式中的关键点" class="headerlink" title="各分类模式中的关键点"></a>各分类模式中的关键点</h4><ol>
<li>创新型模式</li>
</ol>
<ul>
<li>单例模式：某个类只能有一个实例，提供一个全局的访问点</li>
<li>简单工厂：一个工厂类根据传入的参量决定创建出哪一种产品类的实例</li>
<li>工厂方法：定义一个创建对象的接口，让子类决定实例化哪个类</li>
<li>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类</li>
<li>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造</li>
<li>原型模式：通过复制现有的实例来创建新的实例</li>
</ul>
<ol>
<li>结构型模式<ul>
<li>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口</li>
<li>组合模式：将对象组合成树形结构以表示 “部分-整体” 的层次结构</li>
<li>装饰模式：动态的给对象添加新的功能</li>
<li>代理模式：为其他对象提供一个代理以便控制这个对象的访问</li>
<li>享元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象</li>
<li>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口</li>
<li>桥接模式：将抽象部分和它的实现部分分离，是它们都可以独立的变化。</li>
</ul>
</li>
<li>行为型模式<ul>
<li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现</li>
<li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器</li>
<li>策略模式：定义一系列算法，把它们封装起来，并且使它们可以相互替换</li>
<li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为</li>
<li>观察者模式：对象间的一对多的依赖关系</li>
<li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态</li>
<li>中介者模式：用一个中介对象来封装一系列的对象交互</li>
<li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求进行参数化</li>
<li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能</li>
<li>责任链模式：将请求的发送者和接收者解耦，使得多个对象都有处理这个请求的机会</li>
<li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java重定向和转发</title>
    <url>/2020/09/22/java%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><h5 id="使用-response-对象，为-JSP-的内置对象"><a href="#使用-response-对象，为-JSP-的内置对象" class="headerlink" title="使用 response 对象，为 JSP 的内置对象"></a>使用 response 对象，为 JSP 的内置对象</h5><p>可以直接使用 sendRedirect() 重定向，重定向之后会在浏览器地址栏出现重定向页面的 URL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><h5 id="使用-RequestDispatcher-类"><a href="#使用-RequestDispatcher-类" class="headerlink" title="使用 RequestDispatcher 类"></a>使用 RequestDispatcher 类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestDispatcher  rd = request.getRequestDispatcher(<span class="string">&quot;想要跳转的地址&quot;</span>);  </span><br><span class="line">rd.forward(response,request);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h4><p>当使用转发时，JSP 容器将使用一个内部的方法来调用目标页面，新的页面继续处理一个请求，而浏览器不会知道这个过程。与之相反，重定义方式的含义是第一个页面通知浏览器发送一个新的页面请求。</p>
<p>因此，当你使用重定向时，浏览器中所显示的 URL 会变成新页面的 URL，而当使用转发时，该 URL 会保持不变。</p>
<p>重定向的速度比转发慢，因为浏览器还得发出一个新的请求。</p>
<p>同时，由于重定向方式产生了一个新的请求，所以经过一次重定向后，request 内的对象将无法使用。</p>
<p>转发只转发项目内部的 Web 网页，重定向 <strong>可以将页面跳转到项目外的web界面。</strong></p>
<p>转发方法的调用者和被调用者之间共享相同的 request 对象和 response 对象，它们属于同一个访问请求和响应过程；而重定向方法调用者与被调用者使用各自的 request 对象和 response 对象，它们属于两个独立的访问请求和响应过程。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合框架</title>
    <url>/2020/08/12/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li>HashMap 是一个散列表，它存储的内容是键值对( key-value )映射。</li>
<li>HashMap 实现了 Map 接口，根据建的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的值为 null，不支持线程同步。</li>
<li>HashMap 是无需的，即不会记录插入的顺序。</li>
<li>HashMap 继承于 AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</li>
</ul>
<span id="more"></span>
<h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 HashMap 类      </span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 HashMap 对象 Sites</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; Sites = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        Sites.put(<span class="number">1</span>, <span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">2</span>, <span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">3</span>, <span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        Sites.put(<span class="number">4</span>, <span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line">        System.out.println(Sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sites.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Google</span></span><br></pre></td></tr></table></figure>
<h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remove(key) 方法来删除 key 对应的键值对( key-value )</span></span><br><span class="line">Sites.remove(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 删除所有的键值对</span></span><br><span class="line">Sites.clear();</span><br></pre></td></tr></table></figure>
<h5 id="计算大小"><a href="#计算大小" class="headerlink" title="计算大小"></a>计算大小</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sites.size();</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h5 id="迭代-HashMap"><a href="#迭代-HashMap" class="headerlink" title="迭代 HashMap"></a>迭代 HashMap</h5><ul>
<li>可以使用 <code>for-each</code> 来迭代 HashMap 中的 <strong>元素</strong></li>
<li>可以使用 <code>keySet()</code> 方法来获取所有的 key</li>
<li>可以使用 <code>values()</code> 方法来获取所有的 value</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 key 和 value</span></span><br><span class="line"><span class="keyword">for</span> (Integer i : Sites.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key: &quot;</span> + i + <span class="string">&quot; value: &quot;</span> + Sites.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="延申1：HashMap-和-HashTable-的异同点"><a href="#延申1：HashMap-和-HashTable-的异同点" class="headerlink" title="延申1：HashMap 和 HashTable 的异同点"></a>延申1：HashMap 和 HashTable 的异同点</h5><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><p>HashMap 和 HashTable 都是存储 “键值对( key-value )”的散列表。</p>
<p>存储的思想都是：通过 table 数组存储，数组的每一个元素都是一个 Entry，而一个 Entry 就是一个单向链表，Entry 链表中的每一个节点保存了 key-value 键值对数据。</p>
<h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ol>
<li><p>继承和实现方式不同</p>
<p>HashMap 继承于 AbstractMap，而 HashTable 继承于 Dictionary。</p>
</li>
<li><p>线程安全不同</p>
<ul>
<li>HashTable 的函数几乎都是同步的，即它是线程安全的，支持多线程。</li>
<li>HashMap 的函数则是 <strong>非同步的，它不是线程安全的。</strong></li>
</ul>
</li>
<li><p>对 null 值的处理不同</p>
<ul>
<li>HashMap 的 key，value 都可以为 null 。</li>
<li>HashTable 的 key，value 都不可以为 null 。</li>
</ul>
</li>
<li><p>支持的遍历种类不同</p>
<ul>
<li>HashMap 只支持 Iterator (迭代器)遍历。</li>
<li>HashTable 支持 Iterator (迭代器) 和 Enumeration (枚举器)两种遍历方式。</li>
</ul>
</li>
<li><p>容量的初始值和增加的方式不一样</p>
<ul>
<li>HashMap 默认的容量大小为 16，增加容量时，每次将容量变为 “原始容量 * 2 ”</li>
<li>HashTable 默认的容量大小为 11，增加容量时，每次将容量变为 “原始容量 * 2 + 1 ”</li>
</ul>
</li>
<li><p>添加 key-value 时的 hash 值算法不同</p>
<ul>
<li>HashMap 添加元素时，是使用自定义的哈希算法。</li>
<li>HashTable 没有自定义哈希算法，而是直接采用的 key 的 hashCode()。</li>
</ul>
</li>
</ol>
<h5 id="延申2：HashMap-的-key-为自定义对象时，需要注意什么？"><a href="#延申2：HashMap-的-key-为自定义对象时，需要注意什么？" class="headerlink" title="延申2：HashMap 的 key 为自定义对象时，需要注意什么？"></a>延申2：HashMap 的 key 为自定义对象时，需要注意什么？</h5><p>需要 <strong>自定义对象的 hashCode() 方法和 equals() 方法。</strong></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins入门</title>
    <url>/2020/11/26/jenkins%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="jenkins部署实现原理"><a href="#jenkins部署实现原理" class="headerlink" title="jenkins部署实现原理"></a>jenkins部署实现原理</h4><p><img src="http://wrr123.github.io/2020/11/26/jenkins%E5%85%A5%E9%97%A8/整体流程图.png" alt></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jqGrid基本使用</title>
    <url>/2020/06/30/jqGrid%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="设置表头的文件居中显示？"><a href="#设置表头的文件居中显示？" class="headerlink" title="设置表头的文件居中显示？"></a>设置表头的文件居中显示？</h4><blockquote>
<p>使用原始的css的方式，在页面上找需要居中的table下的th/td，设置css属性为text-align: center就可以了。</p>
</blockquote>
<h4 id="在列添加事件时，如何传递对象参数"><a href="#在列添加事件时，如何传递对象参数" class="headerlink" title="在列添加事件时，如何传递对象参数?"></a>在列添加事件时，如何传递对象参数?</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>:<span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ele = <span class="string">&#x27;&lt;a onclick=&quot;edit(&#x27;</span> + <span class="built_in">JSON</span>.stringify(user).replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quot;&#x27;</span>) + <span class="string">&#x27;);&quot;&gt;修改&lt;/a&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ele = <span class="string">&#x27;&lt;a onclick=&quot;edit(\&#x27;&#x27;</span> + <span class="built_in">JSON</span>.stringify(user).replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quot;&#x27;</span>) + <span class="string">&#x27;\&#x27;);&quot;&gt;修改&lt;/a&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前者得到的是json对象，后者取到的是json字符串.</span></span><br></pre></td></tr></table></figure>
<h4 id="手动清除table中显示的数据"><a href="#手动清除table中显示的数据" class="headerlink" title="手动清除table中显示的数据"></a>手动清除table中显示的数据</h4><blockquote>
<p>$(‘#gridTable’).jqGrid(‘clearGridData’);</p>
</blockquote>
<h4 id="获取行id"><a href="#获取行id" class="headerlink" title="获取行id"></a>获取行id</h4><blockquote>
<p>获取单行id</p>
<p>var id=$(‘#gridTable’).jqGrid(‘getGridParam’,’selrow’);</p>
<p>获取多行id</p>
<p>var ids=$(‘#gridTable’).jqGrid(‘getGridParam’,’selarrrow’);</p>
</blockquote>
<h4 id="获取每行的数据"><a href="#获取每行的数据" class="headerlink" title="获取每行的数据"></a>获取每行的数据</h4><blockquote>
<p>var rowData = $(“#gridTable”).jqGrid(‘getRowData’,rowId);</p>
</blockquote>
<h4 id="显示或者隐藏表格底部的滚动条"><a href="#显示或者隐藏表格底部的滚动条" class="headerlink" title="显示或者隐藏表格底部的滚动条"></a>显示或者隐藏表格底部的滚动条</h4><blockquote>
<p>​            $(“#jqGrid”).closest(“.ui-jqgrid-bdiv”).css({ “overflow-x” : <code>&quot;scroll&quot;</code> <code>&quot;hidden&quot;</code> });</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js-json遍历方法</title>
    <url>/2020/07/10/js-json%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="正常for循环"><a href="#正常for循环" class="headerlink" title="正常for循环"></a>正常for循环</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">var</span> len = jsobObj.length</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>;i &lt; len; i++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="js-中轻松遍历对象属性的几种方式"><a href="#js-中轻松遍历对象属性的几种方式" class="headerlink" title="js 中轻松遍历对象属性的几种方式"></a>js 中轻松遍历对象属性的几种方式</h4><h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p><code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致。如果对象的键-值都不可枚举，那么将返回由 <strong>键</strong> 组成的数组。</p>
<p>一个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleColors = &#123;</span><br><span class="line">  colorA: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  colorB: <span class="string">&#x27;black&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> natureColors = &#123;</span><br><span class="line">  colorC: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">  colorD: <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(natureColors, simpleColors);</span><br><span class="line"><span class="built_in">Object</span>.keys(natureColors); <span class="comment">// =&gt; [&#x27;colorC&#x27;, &#x27;colorD&#x27;]</span></span><br><span class="line">natureColors[<span class="string">&#x27;colorA&#x27;</span>];    <span class="comment">// =&gt; &#x27;white&#x27;</span></span><br><span class="line">natureColors[<span class="string">&#x27;colorB&#x27;</span>];    <span class="comment">// =&gt; &#x27;black&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><blockquote>
<p><strong>Object.values()</strong>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
</blockquote>
<p>一个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meals = &#123;</span><br><span class="line">  mealA: <span class="string">&#x27;Breakfast&#x27;</span>,</span><br><span class="line">  mealB: <span class="string">&#x27;Lunch&#x27;</span>,</span><br><span class="line">  mealC: <span class="string">&#x27;Dinner&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(meals)) &#123;</span><br><span class="line">  <span class="keyword">let</span> mealName = meals[key];</span><br><span class="line">  <span class="comment">// ... do something with mealName</span></span><br><span class="line">  <span class="built_in">console</span>.log(mealName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;Breakfast&#x27; &#x27;Lunch&#x27; &#x27;Dinner&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h5><blockquote>
<p><strong>Object.entries()</strong>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>
</blockquote>
<p>一个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meals = &#123;</span><br><span class="line">  mealA: <span class="string">&#x27;Breakfast&#x27;</span>,</span><br><span class="line">  mealB: <span class="string">&#x27;Lunch&#x27;</span>,</span><br><span class="line">  mealC: <span class="string">&#x27;Dinner&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(meals)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;:&#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;mealA:Breakfast&#x27; &#x27;mealB:Lunch&#x27; &#x27;mealC:Dinner&#x27;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp-how2j</title>
    <url>/2021/03/14/jsp-how2j/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>JSP(Java Servlet Page)</p>
<p>更够在html文件中写java代码。</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><h5 id="为什么JSP可以在html文件中运行java代码呢？"><a href="#为什么JSP可以在html文件中运行java代码呢？" class="headerlink" title="为什么JSP可以在html文件中运行java代码呢？"></a>为什么JSP可以在html文件中运行java代码呢？</h5><ul>
<li>因为JSP被转译成了Servlet</li>
</ul>
<span id="more"></span>
<h4 id="页面元素"><a href="#页面元素" class="headerlink" title="页面元素"></a>页面元素</h4><p>jsp由下面这些元素组成：</p>
<ol>
<li>静态内容，就是html，css，javascript等内容</li>
<li>指令 以<code>&lt;%@</code>开始，以<code>%&gt;</code>结尾。</li>
<li>表达式 <code>&lt;%= %&gt;</code> 用于输出一段html</li>
<li>ScriptLet 在<code>&lt;% .. %&gt;</code>之间，可以写任何java代码</li>
<li>声明 在<code>&lt;%! %&gt;</code>之间可以声明字段或者方法。<strong>但是不建议这么做</strong></li>
<li>动作 <code>&lt;jsp:include page=&quot;fileName&quot;&gt;</code> 在jsp页面中包含另一个页面。</li>
<li>注释 <code>&lt;%-- %&gt;</code></li>
</ol>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>pageContext 当前页面</li>
<li>requestContext 一次请求</li>
<li>sessionContext 当前会话</li>
<li>applicationContext 全局，所有用户共享</li>
</ul>
<h4 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h4><ol>
<li>request</li>
<li>response</li>
<li>out</li>
<li>pageContext</li>
<li>session</li>
<li>application</li>
<li>page</li>
<li>config</li>
<li>exception</li>
</ol>
<h4 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h4><p>JSP Standard Tag Library 标准标签库</p>
<p>JSTL库有 core、i18n、fmt和sql等等。</p>
<h4 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h4><p>EL(Expression Language)</p>
<ul>
<li>获取数据 <code>$&#123;name&#125;</code></li>
<li>执行运算</li>
<li>获取web开发常用对象</li>
<li>调用java方法</li>
</ul>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>js中prop函数和attr函数的区别</title>
    <url>/2020/07/15/js%E4%B8%ADprop%E5%87%BD%E6%95%B0%E5%92%8Cattr%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="先搞懂-attribute-与-property"><a href="#先搞懂-attribute-与-property" class="headerlink" title="先搞懂 attribute 与 property"></a>先搞懂 attribute 与 property</h5><blockquote>
<p>当编写 HTML 源码时，你能在 HTML 元素里定义 attributes。然后，一旦浏览器解析你的代码，该 HTML 元素相应的 DOM 节点就会被创建。该节点是一个对象，因此它就拥有 properties。 因此，我们知道：attributes 是 HTML 元素（标签）的属性，而 properties 是 DOM 对象的属性。</p>
</blockquote>
<h5 id="再看看-attr-与-prop-的区别"><a href="#再看看-attr-与-prop-的区别" class="headerlink" title="再看看 attr() 与 prop() 的区别"></a>再看看 attr() 与 prop() 的区别</h5><blockquote>
<p>自 jQuery 1.6 版本起，<code>attr()</code> 方法对于未设置的 attributes （即标签中没写该 attributes）都会返回 <code>undefined</code>。对于检索和改变 DOM 的 properties，如表单元素的 checked、selected 或 disabled 状态，应使用 <code>.prop()</code> 方法。</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js中对url传参包含特殊字符的处理</title>
    <url>/2020/07/03/js%E4%B8%AD%E5%AF%B9url%E4%BC%A0%E5%8F%82%E5%8C%85%E5%90%AB%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="特殊字符的含义（十六进制）"><a href="#特殊字符的含义（十六进制）" class="headerlink" title="特殊字符的含义（十六进制）"></a>特殊字符的含义（十六进制）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">转义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:center">用来标定特定的文档位置</td>
<td style="text-align:center">%23</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">对特殊字符进行编码</td>
<td style="text-align:center">%25</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">分割不同的变量值对</td>
<td style="text-align:center">%26</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">在变量值中表示空格</td>
<td style="text-align:center">%2B</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">表示目录路径</td>
<td style="text-align:center">%2F</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">表示目录路径</td>
<td style="text-align:center">%5C</td>
</tr>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">用来连接键值对</td>
<td style="text-align:center">%3D</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">表示查询字符串的开始</td>
<td style="text-align:center">%3F</td>
</tr>
<tr>
<td style="text-align:center">空格</td>
<td style="text-align:center">空格</td>
<td style="text-align:center">%20</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">句号</td>
<td style="text-align:center">%2E</td>
</tr>
<tr>
<td style="text-align:center">:</td>
<td style="text-align:center">冒号</td>
<td style="text-align:center">%3A</td>
</tr>
</tbody>
</table>
</div>
<h4 id="js中替换变量使用方法"><a href="#js中替换变量使用方法" class="headerlink" title="js中替换变量使用方法"></a>js中替换变量使用方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; str.repalce(&#x2F;\#&#x2F;g, &#39;%23&#39;)</span><br></pre></td></tr></table></figure>
<p><strong>上述的方法如果需要替换的特殊字符比较多的话，会非常麻烦</strong>，故为了解决，使用下面的两个方法</p>
<h4 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI()"></a>encodeURI()</h4><p>一般用于编码整个URI,因为URI中的合法字符都不会被编码转换。</p>
<p>但是下面的一些特殊字符不会被编码：</p>
<p><code>**! @ # $&amp; * ( ) = : / ; ? + &#39; **</code></p>
<h4 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h4><p>把URI字符串采用UTF-8编码格式转化为escape格式的字符串。</p>
<p><strong>一般对传递的参数进行转换。</strong></p>
<h4 id="将url中的特殊字符转换成中文"><a href="#将url中的特殊字符转换成中文" class="headerlink" title="将url中的特殊字符转换成中文"></a>将url中的特殊字符转换成中文</h4><h5 id="函数decodeURI"><a href="#函数decodeURI" class="headerlink" title="函数decodeURI()"></a>函数decodeURI()</h5><p><code>decodeURI()</code> 函数能解码由<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI"><code>encodeURI</code></a> 创建或其它流程得到的统一资源标识符（URI）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个例子</span></span><br><span class="line"><span class="keyword">const</span> uri = <span class="string">&#x27;https://mozilla.org/?x=шеллы&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> encoded = <span class="built_in">encodeURI</span>(uri);</span><br><span class="line"><span class="built_in">console</span>.log(encoded);</span><br><span class="line"><span class="comment">// expected output: &quot;https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(encoded));</span><br><span class="line">  <span class="comment">// expected output: &quot;https://mozilla.org/?x=шеллы&quot;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// catches a malformed URI</span></span><br><span class="line">  <span class="built_in">console</span>.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js中数组常用方法总结</title>
    <url>/2020/07/07/js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="掘金文档参考"><a href="#掘金文档参考" class="headerlink" title="掘金文档参考"></a><a href="https://juejin.im/post/5aab704ef265da239a5f8f52">掘金文档参考</a></h4><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><img src="http://wrr123.github.io/2020/07/07/js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/22.png" alt></p>
<h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p><img src="http://wrr123.github.io/2020/07/07/js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/11.png" alt></p>
<h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p><img src="http://wrr123.github.io/2020/07/07/js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/33.png" alt></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p><img src="http://wrr123.github.io/2020/07/07/js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/44.png" alt></p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p><img src="http://wrr123.github.io/2020/07/07/js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/55.png" alt></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p><img src="http://wrr123.github.io/2020/07/07/js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/66.png" alt></p>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>concat() 方法用于连接两个或者多个数组。</p>
<p>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的async和await关键字</title>
    <url>/2020/08/05/js%E4%B8%AD%E7%9A%84async%E5%92%8Cawait%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise，简单的说是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)。</p>
<p>Promise 是一个对象，它代表了一个异步操作的最终完成或失败。</p>
<p>本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</p>
<h5 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h5><p>不同于老式的传入 ‘回调’, 在使用 Promise 时，会有如下的约定：</p>
<ul>
<li>在本轮 <code>事件循环</code> 运行完成之前，回调函数是不会被调用的。</li>
<li>即使异步操作已经完成（成功或者失败），在这之后通过 <code>then()</code> 添加的函数也会被调用。</li>
<li>通过多次调用 <code>then()</code> 可以添加多个回调函数，它们会按照插入顺序依次执行。<br><em>Promise 很棒的一点就是 <code>链式调用</code></em></li>
</ul>
<h6 id="老式传入-回调-函数的改造"><a href="#老式传入-回调-函数的改造" class="headerlink" title="老式传入 回调 函数的改造"></a>老式传入 <code>回调</code> 函数的改造</h6><ol>
<li>setTimeout(function() {…}, 1000)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms))</span><br><span class="line">wait(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> saySomething(<span class="string">&#x27;10 seconds&#x27;</span>)).catch(failureCallback)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p><code>Promise.resolve()</code> 和 <code>Promise.reject()</code> 是手动创建一个已经 resolve 或者 reject 的 Promise 快捷方法。</p>
<p><code>Promise.all()</code> 和 <code>Promise.race()</code> 是并行运行异步操作的两个组合式工具。</p>
<p>通常，我们递归调用一个由异步函数组成的数组时，相当于一个 Promise 链。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[func1, func2, func3].reduce(<span class="function">(<span class="params">p, f</span>) =&gt;</span> p.then(f), <span class="built_in">Promise</span>.resolve())</span><br><span class="line">.then(<span class="function"><span class="params">result3</span> =&gt;</span> &#123; <span class="comment">/* use result3 */</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(func1).then(func2).then(func3);</span><br></pre></td></tr></table></figure></p>
<h5 id="promise对象的基本语法"><a href="#promise对象的基本语法" class="headerlink" title="promise对象的基本语法"></a>promise对象的基本语法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="async-await起到什么作用"><a href="#async-await起到什么作用" class="headerlink" title="async/await起到什么作用"></a>async/await起到什么作用</h4><blockquote>
<p><code>async/await</code>从字面意思上很好理解，<code>async</code>是异步的意思，<code>await</code>有等待的意思，而两者的用法上也是如此。<code>async</code>用于申明一个<code>function</code>是异步的，而<code>await</code> 用于等待一个异步方法执行完成。</p>
</blockquote>
<h5 id="async-await中的错误处理"><a href="#async-await中的错误处理" class="headerlink" title="async/await中的错误处理"></a>async/await中的错误处理</h5><ul>
<li>用try-catch来做错误捕捉</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用promise的catch来做错误捕捉</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;1&#x27;</span>).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="js中的解构赋值"><a href="#js中的解构赋值" class="headerlink" title="js中的解构赋值"></a>js中的解构赋值</h4><p><strong>解构赋值</strong>语法是一种JavaScript表达式。通过 <strong>解构赋值</strong>，可以将属性/值从对象/数组中取出，来赋值给其他的变量。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的call函数</title>
    <url>/2020/07/15/js%E4%B8%AD%E7%9A%84call%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="方法重用"><a href="#方法重用" class="headerlink" title="方法重用"></a>方法重用</h4><p>使用<code>call()</code>方法，你可以编写能够在不同对象上使用的方法。</p>
<h4 id="函数是对象方法"><a href="#函数是对象方法" class="headerlink" title="函数是对象方法"></a>函数是对象方法</h4><p>在javascript中，函数是对象的方法。</p>
<p>如果一个函数不是JavaScript对象的方法，那么它就是全局对象的方法。</p>
<h4 id="JavaScript-call方法使用实例"><a href="#JavaScript-call方法使用实例" class="headerlink" title="JavaScript call方法使用实例"></a>JavaScript call方法使用实例</h4><p><code>call()</code>方法是预定义的JavaScript方法</p>
<p><strong>它可以用来调用所有者对象作为参数的方法</strong></p>
<p>通过<code>call()</code>方法，你可以使用属于另一个对象的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    firstName:<span class="string">&quot;Bill&quot;</span>,</span><br><span class="line">    lastName: <span class="string">&quot;Gates&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    firstName:<span class="string">&quot;Steve&quot;</span>,</span><br><span class="line">    lastName: <span class="string">&quot;Jobs&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1);  <span class="comment">// 将返回 &quot;Bill Gates&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="带参数的call"><a href="#带参数的call" class="headerlink" title="带参数的call()"></a>带参数的call()</h4><p>call()方法可以接受参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName + <span class="string">&quot;,&quot;</span> + city + <span class="string">&quot;,&quot;</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  firstName:<span class="string">&quot;Bill&quot;</span>,</span><br><span class="line">  lastName: <span class="string">&quot;Gates&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.call(person1, <span class="string">&quot;Seattle&quot;</span>, <span class="string">&quot;USA&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="call函数和apply函数比较"><a href="#call函数和apply函数比较" class="headerlink" title="call函数和apply函数比较"></a>call函数和apply函数比较</h4><p>用法很相似，都能够编写用于不同对象的方法</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li><p><code>call()</code>方法分别接受参数</p>
</li>
<li><p><code>apply()</code>方法接受数组形式的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params">city, country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName + <span class="string">&quot;,&quot;</span> + city + <span class="string">&quot;,&quot;</span> + country;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  firstName:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName: <span class="string">&quot;Doe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">person.fullName.apply(person1, [<span class="string">&quot;Oslo&quot;</span>, <span class="string">&quot;Norway&quot;</span>]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js正则的几个方法(一)</title>
    <url>/2020/07/15/js%E6%AD%A3%E5%88%99%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95-%E4%B8%80/</url>
    <content><![CDATA[<p><code>exec()</code>和<code>test()</code>方法的使用</p>
<ul>
<li><blockquote>
<p>test() 方法用于检测一个字符串是否匹配某个模式. 返回true/false</p>
</blockquote>
</li>
<li><blockquote>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组。</p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>layui和element-ui文件上传功能</title>
    <url>/2020/06/22/layui%E5%92%8Celement-ui%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h5 id="layui文件上传"><a href="#layui文件上传" class="headerlink" title="layui文件上传"></a>layui文件上传</h5><p>使用layui的<code>upload</code>模块， <code>var upload = layui.upload</code><br>核心方法和基础参数选项<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">upload.render(&#123;</span><br><span class="line">    elem: <span class="string">&#x27;指向容器选择器，string/object,&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;服务器上传接口, string&#x27;</span>,</span><br><span class="line">    data: <span class="string">&#x27;请求上传接口的额外参数, object&#x27;</span>,</span><br><span class="line">    headers: <span class="string">&#x27;接口的请求头&#x27;</span>,</span><br><span class="line">    accept: <span class="string">&#x27;指定允许上传时校验的文件类型，string，可选值(images图片，file所有文件，video视频，audio音频，默认值为images)&#x27;</span>,</span><br><span class="line">    choose: <span class="string">&#x27;在文件被选择后触发，且该回调在before之前。一般用于非自动上传（即auto：false）的场景，如预览图片等&#x27;</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>choose: function(obj)&#123;&#125;</code><br>将每次选择的文件追加到文件上传队列<br>obj.pushFile()<br>预览本地文件，如果是多文件的话，则会遍历<br>obj.preview((index, file, result) =&gt; {})<br>重命名文件名称<br>obj.resetFile(index, file, ‘123.png’)<br>对单个上传失败的文件进行重新上传<br>obj.upload(index, file)<br>删除列表中对应的文件，一般在某个事件中使用<br>delete files[index]</p>
<p>css的样式分类</p>
<ul>
<li>外联<br>引入外部的css文件</li>
<li>内联<br>在<code>&lt;head&gt;</code>标签下，添加<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>嵌入(内嵌)<br>直接在元素上添加属性style<br>三者间的区别：优先级不同<br>嵌入 &gt; 内联 &gt; 外联</li>
</ul>
<p>将方法绑定到<code>window</code>对象上之后，在<code>iframe</code>上可以访问到吗？<br>iframe中的window对象和原来的window对象不是同一个，<br>可在iframe中使用<code>window.parent</code>来访问原来的</p>
<p>layui使用upload组件时，点击上传按钮，没有反应，控制台也没有报错？<br>使用<code>layui.use(&#39;upload&#39;, function() &#123;...&#125;)</code>可以成功。</p>
<p>当span和img在一行时，如何进行垂直居中？<br>设置它们的style属性：<code>vertical-align: middle</code></p>
<p>background-color覆盖的范围<br>只覆盖元素的content、border和padding，而margin不会显示该背景颜色。margin的颜色是由外层元素的背景颜色决定的。</p>
<p>layui的form组件，select带搜索的选择框，可以支持中文搜索吗？</p>
<p>layui的upload组件，在上传文件前，如何进行数据校验来终止文件上传？</p>
<h5 id="element-ui文件上传"><a href="#element-ui文件上传" class="headerlink" title="element-ui文件上传"></a>element-ui文件上传</h5><p>组件<code>&lt;el-upload&gt;</code><br>属性参数：<br>on-success 文件上传成功时的钩子<br>before-upload 文件上传之前的钩子，参数上传的文件，若返回false或者返回promise且被reject，则停止上传。</p>
<p>java java.nio.file.Files<br>使用<code>files</code>将复制文件</p>
<p>git使用rebase合并其他分支内容</p>
<ul>
<li>切换到需要合并的分支上 <code>git checkout feature</code></li>
<li>变基到你的主分支上 <code>git rebase master</code><br>或者将两个命令合并到一起 <code>git rebase master feature</code></li>
</ul>
<p>注解<code>@RequestBody</code>修饰的参数类型可以为map吗，为什么？<br>可以的，<code>@RequestBody</code>接受的参数是来自于requestBody中，即请求体。<br>一般用于处理 <strong>非content-type: application/x-www-form-urlencoded</strong>编码格式的数据，比如 <strong>application/json、application/xml等类型的数据</strong><br>而注解<code>@RequestParams</code>接受的参数是来自requestHeader中，即请求头<br>可以接受简单类型的参数，也可以接受对象类型。<br>它一般用来处理content-type为application/x-www-form-urlencoded编码的内容。ajax默认是这个编码。</p>
<p>mybatis-plus自定义分页查询sql语句<br>在dao层重新定义一个方法(第一个参数必须是分页对象 <strong>Page</strong>, 第二个及其后面的参数可以是查询条件参数，返回值也必须是分页对象),<br>在xml文件中新建对应的sql语句,<br>在service层中传入响应的参数，实现该方法即可。</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>linux入门命令</title>
    <url>/2021/01/28/linux%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>常见的执行 <code>Linux</code> 命令的格式是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“ 命令名称 [命令参数] [命令对象]</span><br></pre></td></tr></table></figure>
<p>注意，命令名称、命令参数、命令对象之间请用空格键分隔。</p>
<p>命令对象一般是指要处理的文件、目录、用户等资源，而命令参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用 <code>--</code> 与 <code>-</code> 作为前缀。</p>
<p>命令参数的长格式和短格式示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>长格式</td>
<td><code>man --help</code></td>
</tr>
<tr>
<td>短格式</td>
<td><code>man -h</code></td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h4 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h4><h5 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a><code>echo</code> 命令</h5><p><span style="color:red;">echo命令</span> 用于在 <code>shell</code> 中打印 <code>shell</code> 变量的值，或者直接输出指定的字符串。<code>linux</code> 的 <code>echo</code> 命令，在 <code>shell</code> 编程中极为常用，在终端下打印变量 <code>value</code> 的时候也是常常用到的，因此有必要了解下 <code>echo</code> 的用法，<code>echo</code> 命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。 </p>
<h6 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-e: 激活转义字符。</span><br></pre></td></tr></table></figure>
<p>使用 <code>-e</code> 选项时，若字符串中出现如下的字符，则特别加以处理，而不会将它当成一般文字输出：</p>
<ul>
<li><code>\a</code> 发出警告声；</li>
<li><code>\b</code> 删除前一个字符；</li>
<li><code>\c</code> 最后不加上换行符号；</li>
<li><code>\f</code> 换行但光标仍然停留在原来的位置；</li>
<li><code>\n</code> 换行且光标移至行首；</li>
<li><code>\r</code> 光标移至行首，但不换行；</li>
<li><code>\t</code> 插入 <code>tab</code>；</li>
<li><code>\v</code> 与 <code>\f</code> 相同；</li>
<li><code>\\</code> 插入 <code>\</code> 字符；</li>
<li><code>\nnn</code> 插入 <code>nnn(八进制)</code> 所代表的 <code>ASCII</code> 字符；</li>
</ul>
<h5 id="date-命令"><a href="#date-命令" class="headerlink" title="date 命令"></a><code>date</code> 命令</h5><p><span style="color:red;">date命令</span> 是显示或设置系统时间与日期。</p>
<p>很多 <code>shell</code> 脚本里面需要打印不同格式的日期或时间，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类 <code>unix</code> 系统中，日期被存储为一个整数，其大小为自世界标准时间（<code>UTC</code>） <code>1970年1月1日0时0分0秒</code> 起流逝的秒数。</p>
<p><img src="http://wrr123.github.io/2021/01/28/linux%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4/001.png" alt></p>
<h5 id="reboot-命令"><a href="#reboot-命令" class="headerlink" title="reboot 命令"></a><code>reboot</code> 命令</h5><p><span style="color:red;">reboot命令</span> 用来重新启动正在运行的 <code>Linux</code> 操作系统。</p>
<h6 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h6><ul>
<li><code>-d</code> 重新开机时不把数据写入记录文件 <code>/var/tmp/wtmp</code>。本参数具有 <code>-n</code> 参数效果。</li>
<li><code>-f</code> 强制重新启动，不调用 <code>shutdown</code> 指令的功能；</li>
<li><code>-i</code> 在重开机之前，先关闭所有网络界面；</li>
<li><code>-n</code> 重开机之前不检查是否有未结束的程序；</li>
<li><code>-w</code> 仅作测试，并不真正将系统重新开机，只会把重开机的数据写入<code>/var/log</code> 目录下的 <code>wtmp</code> 记录文件。</li>
</ul>
<h5 id="poweroff-命令"><a href="#poweroff-命令" class="headerlink" title="poweroff 命令"></a><code>poweroff</code> 命令</h5><p><span style="color:red;">poweroff命令</span> 用来关闭计算机操作系统并且切断系统电源。</p>
<h5 id="wget-命令"><a href="#wget-命令" class="headerlink" title="wget 命令"></a><code>wget</code> 命令</h5><p><span style="color:red;">wget命令</span> 用来从指定的 <code>url</code> 下载文件。<code>wget</code> 非常稳定，它在带宽很窄的情况下和不稳定的网络中有很强的适应性，如果由于网络的原因下载失败，<code>wget</code> 会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次连到服务器上停止的地方继续下载。这对从那些限制了链接时间的服务器上下载<span style="color:red;">大文件</span>非常有用。</p>
<h6 id="使用-wget-断点续传"><a href="#使用-wget-断点续传" class="headerlink" title="使用 wget 断点续传"></a>使用 <code>wget</code> 断点续传</h6><p><code>wget -c http://www.linuxde.net/testfile.zip</code></p>
<h6 id="使用-wget-后台下载"><a href="#使用-wget-后台下载" class="headerlink" title="使用 wget 后台下载"></a>使用 <code>wget</code> 后台下载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -b http:&#x2F;&#x2F;www.linuxde.net&#x2F;testfile.zip</span><br><span class="line"></span><br><span class="line">Continuing in background, pid 1840.</span><br><span class="line">Output will be written to &#96;wget-log&#39;.</span><br></pre></td></tr></table></figure>
<p>可以使用命令 <code>tail -f wget-log</code> 来察看下载进度。</p>
<h6 id="伪装代理名称下载"><a href="#伪装代理名称下载" class="headerlink" title="伪装代理名称下载"></a>伪装代理名称下载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --user-agent&#x3D;&quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit&#x2F;534.16 (KHTML, like Gecko) Chrome&#x2F;10.0.648.204 Safari&#x2F;534.16&quot; http:&#x2F;&#x2F;www.linuxde.net&#x2F;testfile.zip</span><br></pre></td></tr></table></figure>
<p><span style="color:red;">有些网站能通过判断代理名称不是浏览器而拒绝你的下载请求。不过可以通过 <code>--user-agent</code> 参数伪装。</span></p>
<h6 id="测试下载链接"><a href="#测试下载链接" class="headerlink" title="测试下载链接"></a>测试下载链接</h6><p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加 <code>--spider</code> 参数进行检查。</p>
<p><code>wget --spider URL</code></p>
<p>如果下载链接正确，则显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Spider mode enabled. Check if remote file exists.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text&#x2F;html]</span><br><span class="line">Remote file exists and could contain further links,</span><br><span class="line">but recursion is disabled -- not retrieving.</span><br></pre></td></tr></table></figure>
<p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --spider url</span><br><span class="line">Spider mode enabled. Check if remote file exists.</span><br><span class="line">HTTP request sent, awaiting response... 404 Not Found</span><br><span class="line">Remote file does not exist -- broken link!!!</span><br></pre></td></tr></table></figure>
<p>你可以在以下几种情况下使用 <code>--spider</code> 参数：</p>
<ul>
<li>定时下载之前进行检查</li>
<li>间隔检测网站是否可用</li>
<li>检查网站页面的死链接</li>
</ul>
<h6 id="增加重试次数"><a href="#增加重试次数" class="headerlink" title="增加重试次数"></a>增加重试次数</h6><p><code>wget --tries=40 URL</code></p>
<p>如果网络有问题或下载一个大文件也有可能失败。<code>wget</code> 默认重试 <code>20</code> 次连接下载文件。如果需要，可以使用 <code>--tries</code> 参数增加重试次数。</p>
<h6 id="下载多个文件"><a href="#下载多个文件" class="headerlink" title="下载多个文件"></a>下载多个文件</h6><p><code>wget -i fileList.txt</code></p>
<p>首先，保存一份下载链接文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; fileList.txt</span><br><span class="line">url1</span><br><span class="line">url2</span><br><span class="line">url3</span><br><span class="line">url4</span><br></pre></td></tr></table></figure>
<p>接着使用这个文件和参数 <code>-i</code> 下载</p>
<h6 id="镜像网站"><a href="#镜像网站" class="headerlink" title="镜像网站"></a>镜像网站</h6><p><code>wget --mirror -p --convert-links -P ./LOCAL URL</code></p>
<p>下载整个网站到本地</p>
<ul>
<li><code>--miror</code>开户镜像下载。</li>
<li><code>-p</code>下载所有为了html页面显示正常的文件。</li>
<li><code>--convert-links</code>下载后，转换成本地的链接。</li>
<li><code>-P ./LOCAL</code>保存所有文件和目录到本地指定目录。</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本指令</title>
    <url>/2020/08/10/linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h4><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。</p>
<p>业界所说的 shell 通常都是指 shell 脚本，但需要知道，<code>shell</code> 和 <code>shell script</code> 是两个不同的概念。</p>
<p>由于习惯的原因，简洁起见，通常所说的 “shell 编程”都是指 shell 脚本编程，不是指开发 shell 自身。</p>
<p>一个栗子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 shell 。</strong></p>
<span id="more"></span>
<h4 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h4><ul>
<li><code>grep -nri &lt;字符串&gt;</code></li>
</ul>
<h4 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h4><h5 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alh&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：等于号(<code>=</code>) 前后不能有空格。</strong></p>
<h5 id="删除别名"><a href="#删除别名" class="headerlink" title="删除别名"></a>删除别名</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unalias</span> name <span class="comment"># name 为要删除的别名名称</span></span><br></pre></td></tr></table></figure>
<p><em>如果创建和删除别名需要永久生效，请在配置文件（如 .bashrc）中配置。</em></p>
<h4 id="source-命令"><a href="#source-命令" class="headerlink" title="source 命令"></a>source 命令</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>在当前 bash 环境下读取并执行 fileName 中的命令。</p>
<p><strong>注：该命令通常用命令 <code>.</code> 来替代</strong></p>
<h5 id="source-fileName-sh-fileName-及-fileName-执行脚本的区别"><a href="#source-fileName-sh-fileName-及-fileName-执行脚本的区别" class="headerlink" title="source fileName, sh fileName 及 ./fileName 执行脚本的区别"></a>source fileName, sh fileName 及 ./fileName 执行脚本的区别</h5><blockquote>
<ol>
<li>当shell脚本具有可执行权限时，用<code>sh filename</code>与<code>./filename</code>执行脚本是没有区别得。<code>./filename</code>是因为当前目录没有在PATH中，所有”.”是用来表示当前目录的。</li>
<li><code>sh filename</code> 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell。</li>
<li><code>source filename</code>：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。</li>
</ol>
</blockquote>
<h4 id="Linux-下快速删除已输入的命令"><a href="#Linux-下快速删除已输入的命令" class="headerlink" title="Linux 下快速删除已输入的命令"></a>Linux 下快速删除已输入的命令</h4><ul>
<li><code>ctrl + c</code>: 终止已经执行或未开始执行的命令</li>
<li><code>ctrl + w</code>: 往回删除一个单词，光标放在最末尾</li>
<li><code>ctrl + u</code>: 删除光标以前的字符</li>
<li><code>ctrl + k</code>: 删除光标以后的字符</li>
<li><code>ctrl + a</code>： 移动光标到字符头</li>
<li><code>ctrl + e</code>: 移动光标到字符末</li>
<li><code>ctrl + l</code>: 清屏</li>
</ul>
<h4 id="eval-的用法"><a href="#eval-的用法" class="headerlink" title="eval 的用法"></a><code>eval</code> 的用法</h4><h5 id="eval-command-line"><a href="#eval-command-line" class="headerlink" title="eval command-line"></a><code>eval command-line</code></h5><p>其中 command-line 是在终端上键入的一条普通命令行。<strong>然而，当在它前面放上 <code>eval</code> 时，其结果是 shell 在执行命令行之前扫描它两次。</strong></p>
<p>一个栗子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipe=<span class="string">&quot;|&quot;</span></span><br><span class="line"><span class="built_in">eval</span> ls <span class="variable">$pipe</span> wc -l</span><br><span class="line"><span class="comment"># shell 第 1 次扫描命令行时，它替换出 pipe 的值 `|`,接着 eval 使它再次扫描命令行，这是 shell 把 `|` 作为管道符号了。</span></span><br></pre></td></tr></table></figure>
<h4 id="wc命令—统计文件的字节数、字数、行数"><a href="#wc命令—统计文件的字节数、字数、行数" class="headerlink" title="wc命令—统计文件的字节数、字数、行数"></a>wc命令—统计文件的字节数、字数、行数</h4><p style="color:sienna;">
    wc命令统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为"-"，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。
</p>

<p>语法格式：wc [参数] [文件]</p>
<p>常用的参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:center">统计字数，或 <code>--words:只显示字数</code>。一个字被定义为由空白、跳格或换行字符分割的字符串</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">统计字节数，或<code>--bytes,--chars</code>，只显示Bytes数</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td style="text-align:center">统计行数，<code>或--lines</code>，只显示列数</td>
</tr>
<tr>
<td style="text-align:center">-m</td>
<td style="text-align:center">统计字符数</td>
</tr>
<tr>
<td style="text-align:center">-L</td>
<td style="text-align:center">打印最长行的长度</td>
</tr>
<tr>
<td style="text-align:center">—help</td>
<td style="text-align:center">显示帮助信息</td>
</tr>
<tr>
<td style="text-align:center">—version</td>
<td style="text-align:center">显示版本信息</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>lombok注解篇</title>
    <url>/2020/09/29/lombok%E6%B3%A8%E8%A7%A3%E7%AF%87/</url>
    <content><![CDATA[<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h5 id="NoArgsConsturctor"><a href="#NoArgsConsturctor" class="headerlink" title="@NoArgsConsturctor"></a><code>@NoArgsConsturctor</code></h5><p>生成一个无参的构造方法，这个 annotation 在与其他的 annotation 配合起来使用的时候更加能凸显出它的重要性，例如在使用 hibernate 这种框架的时候，如果有一个有参数的构造方法的时候，NoArgsConstructor 会展示出它的作用。</p>
<h5 id="AllArgsConsturctor"><a href="#AllArgsConsturctor" class="headerlink" title="@AllArgsConsturctor"></a><code>@AllArgsConsturctor</code></h5><p>会生成一个包含常量和标识了 <code>@NonNull</code> 注解的变量的构造方法。生成的构造方法是 private，如果想要对外提供使用可以使用 <code>staticName</code> 选项生成一个 static 方法。</p>
<h5 id="RequiredArgsConsturctor"><a href="#RequiredArgsConsturctor" class="headerlink" title="@RequiredArgsConsturctor"></a><code>@RequiredArgsConsturctor</code></h5><p>会生成一个包含所有变量，同时如果变量使用了 <code>@NonNull</code> 注解，会进行是否为空的校验。</p>
<span id="more"></span>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS开机启动项</title>
    <url>/2020/08/30/macOS%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%B9/</url>
    <content><![CDATA[<h4 id="直接通过设置来管理"><a href="#直接通过设置来管理" class="headerlink" title="直接通过设置来管理"></a>直接通过设置来管理</h4><p><a href="https://jingyan.baidu.com/article/73c3ce28dee1a1e50343d9f8.html">系统偏好设置</a></p>
<h4 id="通过-plist-来管理"><a href="#通过-plist-来管理" class="headerlink" title="通过 plist 来管理"></a>通过 plist 来管理</h4><h5 id="macOS-系统的启动项会以-plist-的文件存在于以下的目录中："><a href="#macOS-系统的启动项会以-plist-的文件存在于以下的目录中：" class="headerlink" title="macOS 系统的启动项会以 .plist 的文件存在于以下的目录中："></a>macOS 系统的启动项会以 <code>.plist</code> 的文件存在于以下的目录中：</h5><ul>
<li>/Library/LaunchDaemons：系统启动时运行，用户不登录也会运行。</li>
<li>/Library/LaunchAgents：用户登录后运行。</li>
<li>~/Library/LaunchAgents：用户自定义的用户启动项</li>
<li>/System/Library/LaunchDaemons：系统自带的启动项</li>
<li>/System/Library/LaunchAgents：系统自带的启动项</li>
</ul>
<span id="more"></span>
<h3 id="每个-plist-文件中，有-3-个属性控制着是否会开机自动启动。"><a href="#每个-plist-文件中，有-3-个属性控制着是否会开机自动启动。" class="headerlink" title="每个 .plist 文件中，有 3 个属性控制着是否会开机自动启动。"></a>每个 .plist 文件中，有 3 个属性控制着是否会开机自动启动。</h3><ul>
<li>KeepAlive：决定程序是否需要一直运行，如果是 false 则需要时才启动。默认 false</li>
<li>RunAtLoad：开机时是否运行。默认 false。</li>
<li>SuccessfulExit：此项为 true 时，程序正常退出时重启（即退出码为 0）；为 false 时，程序非正常退出时重启。此项设置时会隐含默认 RunAtLoad = true，因为程序需要至少运行一次才能获得退出状态。</li>
</ul>
<h3 id="所以其实针对这三项，不同的值有不同的表现："><a href="#所以其实针对这三项，不同的值有不同的表现：" class="headerlink" title="所以其实针对这三项，不同的值有不同的表现："></a>所以其实针对这三项，不同的值有不同的表现：</h3><ul>
<li>如果 KeepAlive = false：<ul>
<li>当 RunAtLoad = false 时：程序只有在有需要的时候运行。</li>
<li>当 RunAtLoad = true 时：程序在启动时会运行一次，然后等待在有需要的时候运行。</li>
<li>当 SuccessfulExit = true / false 时：不论 RunAtLoad 值是什么，都会在启动时运行一次。其后根据 SuccessfulExit 值来决定是否重启。</li>
</ul>
</li>
<li>如果 KeepAlive = true ：不论 RunAtLoad/SuccessfulExit 值是什么，都会启动时运行且一直保持运行状态。</li>
</ul>
<p>如果不希望开机自动运行，则需要：</p>
<ol>
<li>找到对应程序的 .plist 文件</li>
<li>删除 SuccessfulExit 属性。</li>
<li>将 RunAtLoad / KeepAlive 均设为 false 。</li>
</ol>
]]></content>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS文件编码转换</title>
    <url>/2020/09/07/macOS%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="查看文件编码"><a href="#查看文件编码" class="headerlink" title="查看文件编码"></a>查看文件编码</h4><ol>
<li>在 Vim 中可以直接查看文件编码</li>
<li><code>ecna</code> 命令查看文件编码</li>
<li><code>file</code> 命令查看文件编码<span id="more"></span>
</li>
</ol>
<h4 id="文件编码转换"><a href="#文件编码转换" class="headerlink" title="文件编码转换"></a>文件编码转换</h4><ol>
<li><p>在 Vim 中转换<br><code>:set fileencoding=utf-8</code></p>
</li>
<li><p>enconv </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 将一个 GBK 编码的文件转换成 UTF-8 的</span><br><span class="line">enconv -L zh-CN -x UTF-8 fileName</span><br></pre></td></tr></table></figure>
</li>
<li><p>iconv<br>iconv 的命令格式如下：<br><code>iconv -f encoding -t encoding inputFile</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 将一个 UTF-8 编码的转换成 GBK 编码(file2 文件必须存在)</span><br><span class="line">iconv -c -f GBK -t UTF-8 file1 &gt; file2</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上查看和安装字体</title>
    <url>/2020/08/16/mac%E4%B8%8A%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<h4 id="查看安装的字体"><a href="#查看安装的字体" class="headerlink" title="查看安装的字体"></a>查看安装的字体</h4><ol>
<li><p>使用应用程序 Font Book.app</p>
</li>
<li><p>使用命令行的方式</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls ~/Library/Fonts/</span><br><span class="line">ls /Library/Fonts/</span><br><span class="line">ls /System/Library/Fonts/</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fc-list :lang=zh</code>  查看支持中文的字体</p>
</li>
</ol>
<span id="more"></span>
<h4 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h4><p>官方说明：</p>
<blockquote>
<p>在访达中连按所需的字体，然后在打开的字体预览窗口中点按“安装字体”。在 Mac 验证该字体并打开“<a href="https://support.apple.com/zh-cn/guide/font-book/welcome">字体册</a>”应用后，该字体即安装完毕并可供使用。</p>
</blockquote>
<p><img src="http://wrr123.github.io/2020/08/16/mac%E4%B8%8A%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93/001.png" alt></p>
<p><strong>使用 brew 安装</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew tap caskroom/fonts</span><br><span class="line">brew cask install font-hack-nerd-font</span><br><span class="line">// font-hack-nerd-font 为想要安装的字体名称</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下常用的命令行工具</title>
    <url>/2020/10/10/mac%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h4 id="命令行模式下格式化-json-格式的字符串"><a href="#命令行模式下格式化-json-格式的字符串" class="headerlink" title="命令行模式下格式化 json 格式的字符串"></a>命令行模式下格式化 json 格式的字符串</h4><p><code>jq</code></p>
<p><img src="http://wrr123.github.io/2020/10/10/mac%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/jq.png" alt></p>
]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac批量修改文件名称</title>
    <url>/2020/08/16/mac%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<h4 id="批量修改文件名的方法"><a href="#批量修改文件名的方法" class="headerlink" title="批量修改文件名的方法"></a>批量修改文件名的方法</h4><ul>
<li><p>方式一 <code>使用 sed 命令</code></p>
<p>  一个栗子</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls *jpg|sed -r <span class="string">&#x27;s#(.*).jpg#mv &amp;  \1.mp4#&#x27;</span>|bash</span><br></pre></td></tr></table></figure>
</li>
</ul>
<span id="more"></span>
<ul>
<li><p>方式二 <code>使用 rename 命令</code></p>
<p>  格式：rename 原名 替换名 要改的文件</p>
<blockquote>
<p>原字符串：将文件名需要替换的字符串； 目标字符串：将文件名中含有的原字符替换成目标字符串； 文件：指定要改变文件名的文件列表。</p>
</blockquote>
<p>  一个栗子</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@cache01 <span class="built_in">test</span>]<span class="comment"># ls </span></span><br><span class="line">01.txt  03.txt  05.txt  07.txt  09.txt</span><br><span class="line">02.txt  04.txt  06.txt  08.txt  10.txt</span><br><span class="line">[root@cache01 <span class="built_in">test</span>]<span class="comment"># rename txt jpg *</span></span><br><span class="line">[root@cache01 <span class="built_in">test</span>]<span class="comment"># ls </span></span><br><span class="line">01.jpg  03.jpg  05.jpg  07.jpg  09.jpg</span><br><span class="line">02.jpg  04.jpg  06.jpg  08.jpg  10.jpg</span><br></pre></td></tr></table></figure>
<p>  rename 的一些用法</p>
<blockquote>
<p><code>rename</code> 支持 perl 的正则表达式</p>
<h5 id="替换文件名中特定字段"><a href="#替换文件名中特定字段" class="headerlink" title="替换文件名中特定字段"></a>替换文件名中特定字段</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rename <span class="string">&quot;s/AA/aa/&quot;</span> *  <span class="comment"># 把文件名中的AA替换成aa</span></span><br></pre></td></tr></table></figure>
<p>这一行命令的解释就是，对当前文件夹下满足 <code>*</code> 的所有文件，文件名中包含 <code>AA</code> 字符的替换为 <code>aa</code> 其中 <code>&quot;s/pattern/new/&quot;</code> 中的 <code>/</code> 一个都不能少。</p>
<h5 id="修改文件后缀"><a href="#修改文件后缀" class="headerlink" title="修改文件后缀"></a>修改文件后缀</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rename <span class="string">&quot;s/.html/.php/&quot;</span> *     <span class="comment"># 把.html 后缀的改成 .php后缀</span></span><br><span class="line">rename <span class="string">&quot;s/.png/.jpg/&quot;</span> *      <span class="comment"># 将 png 改为 jpg</span></span><br></pre></td></tr></table></figure>
<p>批量修改文件后缀名</p>
<h5 id="批量添加文件后缀"><a href="#批量添加文件后缀" class="headerlink" title="批量添加文件后缀"></a>批量添加文件后缀</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rename <span class="string">&quot;s/$/.txt/&quot;</span> *     <span class="comment"># 把所有的文件名都以txt结尾</span></span><br></pre></td></tr></table></figure>
<p>因为支持正则表达式，那么 <code>$</code> 表示的就是结尾，将结尾替换为 <code>.txt</code> 也就意味着给所有文件添加 <code>.txt</code> 的后缀</p>
<h5 id="批量删除文件名"><a href="#批量删除文件名" class="headerlink" title="批量删除文件名"></a>批量删除文件名</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rename <span class="string">&quot;s/.txt//&quot;</span> *      <span class="comment"># 把所有以.txt结尾的文件名的.txt删掉</span></span><br></pre></td></tr></table></figure>
<p>同理，结尾有 <code>.txt</code> 的内容替换为空，也就是删掉后缀了。</p>
<h5 id="应用正则匹配的部分文件名"><a href="#应用正则匹配的部分文件名" class="headerlink" title="应用正则匹配的部分文件名"></a>应用正则匹配的部分文件名</h5><p>假如需要在批量修改的时候保留部分文件名，可以使用引用 <code>\1</code> ，比如有下面格式的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Screenshot from 2019-01-02 15-56-49.jpg</span><br></pre></td></tr></table></figure>
<p>我只希望保留其中的日期部分，那么可以</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rename -n <span class="string">&quot;s/Screenshot from ([0-9\\- ]+).jpg/\1.jpg/&quot;</span> *</span><br></pre></td></tr></table></figure>
<p>将 <code>()</code> 匹配的内容取出来放到替换部分。</p>
</blockquote>
</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown中的数学公式语法</title>
    <url>/2021/03/01/markdown%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h4><p>使用 <code>^</code> 表示上标，使用 <code>_</code> 表示下标，如果上下标的内容多于一个字符，可以使用<strong>大括号</strong>括起来：</p>
<p>如 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$f(x) &#x3D; a_1x^n + a_2x^&#123;n-1&#125; + a_3x^&#123;n-2&#125;$</span><br></pre></td></tr></table></figure>
<p>显示效果为</p>
<script type="math/tex; mode=display">
f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}</script><p>如果左右两边都有上下标，可以使用 <code>\sideset</code> 语法。</p>
<p>如 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\sideset&#123;^n_k&#125;&#123;^x_y&#125;a$</span><br></pre></td></tr></table></figure>
<p>显示效果为：</p>
<script type="math/tex; mode=display">
\sideset {^n_k}{^x_y}a</script><span id="more"></span>
<h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>在 <code>markdown</code> 语法中，<code>$ &#123; &#125; _</code> 都是有特殊含义的，所以需要加 <code>\</code> 进行转义。小括号与方括号可以使用原始的 <code>(), []</code>。大括号需要使用 <code>\</code> 转义，也可以使用 <code>\lbrace</code> 和 <code>\rbrace</code>。</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#123;x*y\&#125;</span><br><span class="line">\lbrace x*y \rblace</span><br></pre></td></tr></table></figure>
<p>显示效果为 ${ x*y }$。</p>
<p><strong>原始符号不会随着公式大小自动缩放，需要使用 <code>/left</code> 和 <code>/right</code> 来实现自动缩放。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\left \lbrace \sum_&#123;i&#x3D;0&#125;^n i^3 &#x3D; \frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125; \right \rbrace$$</span><br></pre></td></tr></table></figure>
<p>效果为：</p>
<script type="math/tex; mode=display">
\left \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \right \rbrace</script><p>不使用 <code>\left</code> 和 <code>\right</code>的效果如下：</p>
<script type="math/tex; mode=display">
\lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9}  \rbrace</script><h4 id="分数与开方"><a href="#分数与开方" class="headerlink" title="分数与开方"></a>分数与开方</h4><h5 id="可以使用-frac-或-over-实现分数的显示："><a href="#可以使用-frac-或-over-实现分数的显示：" class="headerlink" title="可以使用 \frac 或 \over 实现分数的显示："></a>可以使用 <code>\frac</code> 或 <code>\over</code> 实现分数的显示：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\frac xy$</span><br><span class="line">$x + 3 \over y + 5$</span><br></pre></td></tr></table></figure>
<p>分别显示为：$\frac xy$ 和 $x + 3 \over y + 5$ 。</p>
<h5 id="开方使用-sqrt"><a href="#开方使用-sqrt" class="headerlink" title="开方使用 \sqrt:"></a>开方使用 <code>\sqrt</code>:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ \sqrt &#123;x ^ 5&#125;$</span><br><span class="line">$ \sqrt [3] &#123;\frac xy&#125;$</span><br></pre></td></tr></table></figure>
<p>分别显示为 $ \sqrt {x ^ 5}$ 和 $ \sqrt [3] {\frac xy}$ 。</p>
<h4 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h4><h5 id="求和使用-sum，可以加上下标"><a href="#求和使用-sum，可以加上下标" class="headerlink" title="求和使用 \sum，可以加上下标"></a>求和使用 <code>\sum</code>，可以加上下标</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ \sum_&#123;i&#x3D;0&#125;^n$</span><br></pre></td></tr></table></figure>
<p>显示为 $ \sum _{i=0}^n $。</p>
<h5 id="积分使用-int，可加上下限，双重积分用-iint"><a href="#积分使用-int，可加上下限，双重积分用-iint" class="headerlink" title="积分使用 \int，可加上下限，双重积分用 \iint"></a>积分使用 <code>\int</code>，可加上下限，双重积分用 <code>\iint</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ \int_1^\infty $</span><br><span class="line">$ \iint_1^\infty $</span><br></pre></td></tr></table></figure>
<p>分别显示为 $ \int_1^\infty $ 和 $\iint_1^\infty$。</p>
<h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>极限使用 <code>\lim</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ \lim_&#123;x \to 0&#125; $</span><br></pre></td></tr></table></figure>
<p>显示为 $ \lim_{x \to 0} $。</p>
<h4 id="表格和矩阵"><a href="#表格和矩阵" class="headerlink" title="表格和矩阵"></a>表格和矩阵</h4><p>表格样式 <code>lcr</code> 表示居中，<code>|</code> 表示加入一条竖线，<code>\hline</code> 表示行间横线，列之间用 <code>&amp;</code> 分隔，行之间用 <code>\</code> 分隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">1 &amp; 1.97 &amp; 5 &amp; 12 \\\\</span><br><span class="line">2 &amp; -11 &amp; 19 &amp; -80 \\\\</span><br><span class="line">3 &amp; 70 &amp; 209 &amp; 1+i \\\\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>显示效果为:</p>
<script type="math/tex; mode=display">
\begin{array}{c|lcr}
n & \text{Left} & \text{Center} & \text{Right} \\\\
\hline
1 & 1.97 & 5 & 12 \\\\
2 & -11 & 19 & -80 \\\\
3 & 70 & 209 & 1+i \\\\
\end{array}</script><h4 id="常用数学符号"><a href="#常用数学符号" class="headerlink" title="常用数学符号"></a>常用数学符号</h4><p><img src="http://wrr123.github.io/2021/03/01/markdown%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/001.png" alt></p>
<h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><p><img src="http://wrr123.github.io/2021/03/01/markdown%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/002.png" alt></p>
<h4 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h4><p><img src="http://wrr123.github.io/2021/03/01/markdown%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/003.png" alt></p>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p><img src="http://wrr123.github.io/2021/03/01/markdown%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/004.png" alt></p>
<h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><p><img src="http://wrr123.github.io/2021/03/01/markdown%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/005.png" alt></p>
<h4 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h4><p>±± ：\pm<br>×× ：\times<br>÷÷：\div<br>∣∣：\mid</p>
<p>⋅⋅：\cdot<br>∘∘：\circ<br>∗∗: \ast<br>⨀⨀：\bigodot<br>⨂⨂：\bigotimes<br>⨁⨁：\bigoplus<br>≤≤：\leq<br>≥≥：\geq<br>≠≠：\neq<br>≈≈：\approx<br>≡≡：\equiv<br>∑∑：\sum<br>∏∏：\prod<br>∐∐：\coprod</p>
<p>集合运算符：<br>∅∅：\emptyset<br>∈∈：\in<br>∉∉：\notin<br>⊂⊂：\subset<br>⊃⊃ ：\supset<br>⊆⊆ ：\subseteq<br>⊇⊇ ：\supseteq<br>⋂⋂ ：\bigcap<br>⋃⋃ ：\bigcup<br>⋁⋁ ：\bigvee<br>⋀⋀ ：\bigwedge<br>⨄⨄ ：\biguplus<br>⨆⨆：\bigsqcup</p>
<p>对数运算符：<br>loglog ：\log<br>lglg ：\lg<br>lnln ：\ln</p>
<p>三角运算符：<br>⊥⊥：\bot<br>∠∠：\angle<br>30∘30∘：30^\circ<br>sinsin ：\sin<br>coscos ：\cos<br>tantan ：\tan<br>cotcot ：\cot<br>secsec ：\sec<br>csccsc ：\csc</p>
<p>微积分运算符：<br>y′xy′x：\prime<br>∫∫：\int<br>∬∬ ：\iint<br>∭∭ ：\iiint<br>∬∬⨌：\iiiint<br>∮∮ ：\oint<br>limlim ：\lim<br>∞∞ ：\infty<br>∇∇：\nabla</p>
<p>逻辑运算符：<br>∵∵：\because<br>∴∴ ：\therefore<br>∀∀ ：\forall<br>∃∃ ：\exists<br>≠≠ ：\not=<br>≯≯：\not&gt;<br>⊄⊄：\not\subset</p>
<p>戴帽符号：<br>y^y^ ：\hat{y}<br>yˇyˇ ：\check{y}<br>y˘y˘ ：\breve{y}</p>
<p>连线符号：<br>a+b+c+d¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯a+b+c+d¯：\overline{a+b+c+d}<br>a+b+c+d–––––––––––––a+b+c+d<em> ：\underline{a+b+c+d}<br>a+b+c1.0+d2.0a+b+c⏟1.0+d⏞2.0：\overbrace{a+\underbrace{b+c}</em>{1.0}+d}^{2.0}</p>
<p>箭头符号：<br>↑↑：\uparrow<br>↓↓：\downarrow<br>⇑⇑ ：\Uparrow<br>⇓⇓：\Downarrow<br>→→：\rightarrow<br>←← ：\leftarrow<br>⇒⇒ ：\Rightarrow<br>⇐⇐ ：\Leftarrow<br>⟶⟶ ：\longrightarrow<br>⟵⟵ ：\longleftarrow<br>⟹⟹：\Longrightarrow<br>⟸⟸ ：\Longleftarrow</p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>maven基础</title>
    <url>/2020/08/11/maven%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="新建一个简单的maven项目"><a href="#新建一个简单的maven项目" class="headerlink" title="新建一个简单的maven项目"></a>新建一个简单的maven项目</h4><h5 id="选择-archetype"><a href="#选择-archetype" class="headerlink" title="选择 archetype"></a>选择 <code>archetype</code></h5><p><img src="http://wrr123.github.io/2020/08/11/maven%E5%9F%BA%E7%A1%80/001.png" alt></p>
<span id="more"></span>]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus分页查询时，字段排序问题</title>
    <url>/2020/07/10/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%97%B6%EF%BC%8C%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="某些字段进行排序时，查询不出来数据？"><a href="#某些字段进行排序时，查询不出来数据？" class="headerlink" title="某些字段进行排序时，查询不出来数据？"></a>某些字段进行排序时，查询不出来数据？</h4>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus基本使用</title>
    <url>/2020/08/12/mybatis-plus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="忽略映射字段"><a href="#忽略映射字段" class="headerlink" title="忽略映射字段"></a>忽略映射字段</h4><p>某些属性不是数据库的表字段，但是又是必须使用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br></pre></td></tr></table></figure>
<p><code>@TableField(exist = true)</code> 表示该属性为数据库字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName</span> <span class="comment">// 数据库表相关</span></span><br><span class="line"><span class="meta">@TableId</span> <span class="comment">// 表主键标识</span></span><br><span class="line"><span class="meta">@TableField</span> <span class="comment">// 表字段标识</span></span><br><span class="line"><span class="meta">@TableLogic</span> <span class="comment">// 表字段逻辑处理注解(逻辑删除)</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="全局配置主键生成策略"><a href="#全局配置主键生成策略" class="headerlink" title="全局配置主键生成策略"></a>全局配置主键生成策略</h4><p>mybatis-plus 可以配置全局的主键生成策略：</p>
<p><img src="http://wrr123.github.io/2020/08/12/mybatis-plus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/001.png" alt></p>
<p>也可以通过 bean 的属性加注解的方式设置，主键上使用 <code>@TableId</code> 注解，注解的 type 属性有 6 种选值，对应 6 种主键生成策略。</p>
<p><img src="http://wrr123.github.io/2020/08/12/mybatis-plus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/002.png" alt></p>
<p>还可以在数据库中设置该表字段的生成策略，mybatis-plus 默认使用全局唯一的数字类型。</p>
<p><strong>三种设置的优先级： 注解 &gt; 全局 &gt; 默认</strong></p>
<h5 id="IdType"><a href="#IdType" class="headerlink" title="IdType"></a>IdType</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AUTO</td>
<td style="text-align:center">数据库自增</td>
</tr>
<tr>
<td style="text-align:center">INPUT</td>
<td style="text-align:center">自行输入</td>
</tr>
<tr>
<td style="text-align:center">ID_WORKER</td>
<td style="text-align:center">分布式全局唯一 ID 长整型类型</td>
</tr>
<tr>
<td style="text-align:center">UUID</td>
<td style="text-align:center">32 位 UUID 字符串</td>
</tr>
<tr>
<td style="text-align:center">NONE</td>
<td style="text-align:center">无状态</td>
</tr>
<tr>
<td style="text-align:center">ID_WORKER_STR</td>
<td style="text-align:center">分布式全局唯一 ID 字符串类型</td>
</tr>
</tbody>
</table>
</div>
<h5 id="在Oracle-数据库中使用-自增策略"><a href="#在Oracle-数据库中使用-自增策略" class="headerlink" title="在Oracle 数据库中使用 自增策略"></a>在Oracle 数据库中使用 自增策略</h5><ol>
<li><p>需要创建 <code>OracleKeyGenerate</code> 的 bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Configuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OracleKeyGenerate <span class="title">oracleKetGenerate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OracleKetGenerate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件 application.yml 中配置策略</p>
<p><img src="http://wrr123.github.io/2020/08/12/mybatis-plus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/003.png" alt></p>
</li>
<li><p>在实体类中添加注解</p>
<p>序列注解 <code>@KeySequence</code></p>
<p>id注解 <code>@TableId</code></p>
<p><img src="http://wrr123.github.io/2020/08/12/mybatis-plus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/004.png" alt></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis入门使用</title>
    <url>/2020/09/21/mybatis%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Mybatis-中大于号、小于号的转义写法"><a href="#Mybatis-中大于号、小于号的转义写法" class="headerlink" title="Mybatis 中大于号、小于号的转义写法"></a>Mybatis 中大于号、小于号的转义写法</h4><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><div class="table-container">
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>&lt;</th>
<th>&lt;=</th>
<th>&gt;</th>
<th>&gt;=</th>
<th>&amp;</th>
<th>‘</th>
<th>“</th>
</tr>
</thead>
<tbody>
<tr>
<td>转义符号</td>
<td><code>&amp;lt;</code></td>
<td><code>&amp;lt;=</code></td>
<td><code>%gt;</code></td>
<td><code>&amp;gt;=</code></td>
<td><code>&amp;amp;</code></td>
<td><code>&amp;apos;</code></td>
<td><code>&amp;quot;</code></td>
</tr>
</tbody>
</table>
</div>
<h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><p>使用 <code>&lt;![CDATA[sql语句]]&gt;</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">num &lt;![CDATA[ &lt;= ]]&gt; #&#123;num&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="mybatis-的-trim-标签的使用"><a href="#mybatis-的-trim-标签的使用" class="headerlink" title="mybatis 的 trim 标签的使用"></a>mybatis 的 trim 标签的使用</h4><p>trim 标签是一个格式化的标记，可以完成 set 或者是 where 标记的功能。</p>
<h5 id="trim-标签的属性"><a href="#trim-标签的属性" class="headerlink" title="trim 标签的属性"></a>trim 标签的属性</h5><ul>
<li>prefix 前缀覆盖并增加其内容，也就是给 sql 语句加上前缀</li>
<li>suffix 后缀覆盖并增加其内容，也就是给 sql 语句加上后缀</li>
<li>pfixOverrides 前缀判断的条件。取消指定的前缀，如 where，即删除第一次出现的 where</li>
<li>suffixOverrides 后缀判断的条件。取消指定的后缀，如 <code>and | . or ,</code> 等（自动去除多余的逗号），即删除最后一次出现的后缀。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis分页插件</title>
    <url>/2020/10/22/mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="Mybatis通用分页插件-PageHelper"><a href="#Mybatis通用分页插件-PageHelper" class="headerlink" title="Mybatis通用分页插件 PageHelper"></a>Mybatis通用分页插件 PageHelper</h4><h5 id="简述-mybatis-中-PageHelper-的使用"><a href="#简述-mybatis-中-PageHelper-的使用" class="headerlink" title="简述 mybatis 中 PageHelper 的使用"></a>简述 mybatis 中 PageHelper 的使用</h5><ol>
<li><p>需要引入 PageHelper 的 jar 包</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 mybatis 的全局配置文件 SqlMapConfig.xml 中配置该插件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置分页插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在执行 sql 前，添加插件完成分页功能</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public class TestPageHelper &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testPageHelper() &#123;</span><br><span class="line">        // 创建一个spring容器</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext-*&quot;);</span><br><span class="line">        // 从spring容器中获取mapper代理对象</span><br><span class="line">        TbItemMapper mapper = context.getBean(TbItemMapper.class);</span><br><span class="line">        // 执行查询并分页,TbItemExample是逆向工程自动生成的，用来进行条件查询，这里不设置则表示无条件</span><br><span class="line">        TbItemExample example = new TbItemExample();</span><br><span class="line">        //分页处理，显示第一页的10条数据</span><br><span class="line">        PageHelper.startPage(1, 10);</span><br><span class="line">        List<span class="tag">&lt;<span class="name">TbItem</span>&gt;</span> list = mapper.selectByExample(example);//查询</span><br><span class="line">        // 取商品列表</span><br><span class="line">        for(TbItem item : list) &#123;</span><br><span class="line">            System.out.println(item.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">        // 取分页信息</span><br><span class="line">        PageInfo<span class="tag">&lt;<span class="name">TbItem</span>&gt;</span> pageInfo = new PageInfo<span class="tag">&lt;<span class="name">TbItem</span>&gt;</span>(list);</span><br><span class="line">        long total = pageInfo.getTotal(); //获取总记录数</span><br><span class="line">        System.out.println(&quot;共有商品信息：&quot; + total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础操作</title>
    <url>/2020/09/25/mysql%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="数据库基础操作"><a href="#数据库基础操作" class="headerlink" title="数据库基础操作"></a>数据库基础操作</h4><h5 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create database 数据库名；</span><br></pre></td></tr></table></figure>
<p>有一个特殊符号 <code>-</code> 横杠，若数据库名称中包含横杠的话，可以使用反引号 `` 来包裹数据库名称。</p>
<h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="关于数据库"><a href="#关于数据库" class="headerlink" title="关于数据库"></a>关于数据库</h4><ul>
<li>创建数据库 <code>create database h_test;</code></li>
<li>查看数据库 <code>show databases;</code></li>
<li>查看当前所在数据库位置 <code>select database();</code></li>
<li>查看数据库创建信息 <code>show create database h_test;</code></li>
<li>修改数据库编码，可以使用上一条语句查看是否修改成功 <code>alter database h_test default character set gbk collate gbk_bin;</code></li>
<li>删除数据库 <code>drop database h_test;</code> <code>drop database if exists h_test;</code></li>
<li>可以直接创建数据库且设置编码方式 <code>create database h_test default character set utf8 collate utf8_general_ci;</code></li>
</ul>
<h4 id="关于数据表"><a href="#关于数据表" class="headerlink" title="关于数据表"></a>关于数据表</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//首先选定操作的数据库</span><br><span class="line">use h_test;</span><br><span class="line">//创建表student</span><br><span class="line">create table student(</span><br><span class="line">  id  int(11),</span><br><span class="line">  name  varchar(20),</span><br><span class="line">  age int(11)</span><br><span class="line">);</span><br><span class="line">// 复制表</span><br><span class="line">// 1. 复制表结构和表数据（ps：主键自增、索引、触发器、外键不会被复制）</span><br><span class="line">create table tb2 select * from tb1;</span><br><span class="line">// 2. 只复制表结构（ps：数据、触发器、外键不会被复制）</span><br><span class="line">create table tb2 like tb1;</span><br><span class="line">//查看数据表</span><br><span class="line">show tables;</span><br><span class="line">//查看数据表信息，后面加上参数/G可使结果更加美观</span><br><span class="line">show create table student;</span><br><span class="line">//查看表的的字段信息</span><br><span class="line">desc student;</span><br><span class="line">//修改表名</span><br><span class="line">alter table student rename [to] h_student;</span><br><span class="line">//修改字段名</span><br><span class="line">alter table h_student change name stu_name varchar(20);</span><br><span class="line">//修改字段的数据类型</span><br><span class="line">alter table h_student modify id int(20);</span><br><span class="line">//添加字段</span><br><span class="line">alter table h_student add grade float;</span><br><span class="line">//删除字段</span><br><span class="line">alter table h_student drop grade;</span><br><span class="line">//修改字段的位置</span><br><span class="line">alter table h_student modify stu_name varchar(20) first;</span><br><span class="line">alter table h_student modify id int(11) after age;</span><br><span class="line">//删除数据表</span><br><span class="line">drop table h_student;</span><br><span class="line">// 删除表（不管表是否存在）</span><br><span class="line">drop table if exists h_student;</span><br></pre></td></tr></table></figure>
<h4 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h4><div class="table-container">
<table>
<thead>
<tr>
<th>约束条件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>primary key</td>
<td>主键约束，用于唯一标识对应的记录</td>
</tr>
<tr>
<td>foreign key</td>
<td>外键约束</td>
</tr>
<tr>
<td>not null</td>
<td>非空约束</td>
</tr>
<tr>
<td>unique</td>
<td>唯一性约束</td>
</tr>
<tr>
<td>default</td>
<td>默认值约束，用于设置字段的默认值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><blockquote>
<p>作用：提高表中数据的查询速度<br>1.普通索引<br>2.唯一性索引<br>3.全文索引<br>4.单列索引<br>5.多列索引<br>6.空间索引</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建索引</span><br><span class="line">&#x2F;&#x2F;一.创建表的时候创建索引</span><br><span class="line">create table 表名(</span><br><span class="line">        字段名 数据类型[完整性约束条件],</span><br><span class="line">        ...</span><br><span class="line">        字段名 数据类型,</span><br><span class="line">        [UNIQUE|FULLTEXT|SPATIAL] INDEX|KEY</span><br><span class="line">  );</span><br><span class="line">&#x2F;&#x2F;1-1.创建普通索引</span><br><span class="line">create table test1(</span><br><span class="line">  id  INT,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  age INT,</span><br><span class="line">  INDEX (id)</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;可以插入一条数据,查看索引是否被使用</span><br><span class="line">explain select * from test1 where id&#x3D;1 \G;</span><br><span class="line">&#x2F;&#x2F;1-2.创建唯一性索引</span><br><span class="line">create table test2(</span><br><span class="line">  id  INT,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  age INT,</span><br><span class="line">  UNIQUE INDEX unique_id(id asc)</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;1-3.创建全文索引</span><br><span class="line">create table test3(</span><br><span class="line">  id  INT,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  age INT,</span><br><span class="line">  FULLTEXT INDEX fulltext_name(name)</span><br><span class="line">)ENGINE&#x3D;MyISAM;</span><br><span class="line">&#x2F;&#x2F;1-4.创建单列索引</span><br><span class="line">create table test4(</span><br><span class="line">  id  INT,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  age INT,</span><br><span class="line">  INDEX single_name(name(20))</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;1-5.创建多列索引</span><br><span class="line">create table test5(</span><br><span class="line">  id  INT,</span><br><span class="line">  name VARCHAR(20),</span><br><span class="line">  age INT,</span><br><span class="line">  INDEX multi(id,name(20))</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;1-6.创建空间索引</span><br><span class="line">create table test6(</span><br><span class="line">  id  INT,</span><br><span class="line">  space GEOMETRY NOT NULL,</span><br><span class="line">  SPATIAL INDEX sp(space)</span><br><span class="line">)ENGINE&#x3D;MyISAM;</span><br><span class="line">---------------------------------------------------</span><br><span class="line">&#x2F;&#x2F;二.使用create index语句在已经存在的表上创建索引</span><br><span class="line">&#x2F;&#x2F;首先新建一个表,这个表没有索引</span><br><span class="line">create table student(</span><br><span class="line">  id int,</span><br><span class="line">  age int,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  intro varchar(40),</span><br><span class="line">  g GEOMETRY NOT NULL</span><br><span class="line">)ENGINE&#x3D;MyISAM;</span><br><span class="line">&#x2F;&#x2F;2-1.创建普通索引</span><br><span class="line">create index index_id on student(id);</span><br><span class="line">&#x2F;&#x2F;2-2.创建唯一性索引</span><br><span class="line">create unique index uniqueidx on student(id);</span><br><span class="line">&#x2F;&#x2F;2-3.创建单列索引</span><br><span class="line">create index singleidx on student(age);</span><br><span class="line">&#x2F;&#x2F;2-4.创建多列索引</span><br><span class="line">create index mulitidx on student(name(20),intro(40));</span><br><span class="line">&#x2F;&#x2F;2-5.创建全文索引</span><br><span class="line">create fulltext index fulltextidx on student(name);</span><br><span class="line">&#x2F;&#x2F;2-6.创建空间索引</span><br><span class="line">create spatial index spatidx on student(g); </span><br><span class="line">&#x2F;&#x2F;下图是第二种方法创建索引演示后的所有索引</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;删除索引，有下面两种方式</span><br><span class="line">&#x2F;&#x2F;1.使用alter table删除索引fulltextidx</span><br><span class="line">alter table student drop index fulltextidx;</span><br><span class="line">&#x2F;&#x2F;2.使用drop index删除索引spatidx</span><br><span class="line">drop index spatidx on student;</span><br><span class="line">&#x2F;&#x2F;下图可看到删除成功</span><br></pre></td></tr></table></figure>
<h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重新建立表student</span><br><span class="line">drop table student;</span><br><span class="line">create table student(</span><br><span class="line">  id int,</span><br><span class="line">  name varchar(20) not null,</span><br><span class="line">  grade float</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;插入一条数据，也可以少某个字段的同时也少对应的数据</span><br><span class="line">insert into student(id,name,grade) values(1,&#39;howie&#39;,70);</span><br><span class="line">&#x2F;&#x2F;也可以不指定字段名，但要注意顺序</span><br><span class="line">insert into student values(2,&#39;howie&#39;,80);</span><br><span class="line">&#x2F;&#x2F;也可以这样添加数据</span><br><span class="line">insert into student set id&#x3D;3,name&#x3D;&quot;howie&quot;,grade&#x3D;90;</span><br><span class="line">&#x2F;&#x2F;同时添加多条数据</span><br><span class="line">insert into student values</span><br><span class="line">(4,&#39;howie&#39;,80),</span><br><span class="line">(5,&#39;howie&#39;,80),</span><br><span class="line">(6,&#39;howie&#39;,80);</span><br></pre></td></tr></table></figure>
<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;更新id&#x3D;1的数据</span><br><span class="line">update student set name&#x3D;&quot;howie1&quot;,grade&#x3D;60 where id&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;批量更新,如果没有where子句，会更新表中所有对应数据</span><br><span class="line">update student set grade&#x3D;100 where id&lt;4;</span><br></pre></td></tr></table></figure>
<p>删除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;删除id&#x3D;6的数据</span><br><span class="line">delete from student where id&#x3D;6;</span><br><span class="line">&#x2F;&#x2F;批量删除数据</span><br><span class="line">delete from student where id&gt;3;</span><br><span class="line">&#x2F;&#x2F;删除所有数据,DDL(数据定义语言)语句 truncate table student也可以删除表内所有数据</span><br><span class="line">delete from student;</span><br></pre></td></tr></table></figure>
<h4 id="单表查询和多表操作"><a href="#单表查询和多表操作" class="headerlink" title="单表查询和多表操作"></a>单表查询和多表操作</h4><h5 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;建立表student</span><br><span class="line">create table student(</span><br><span class="line">  id int not null auto_increment,</span><br><span class="line">  name varchar(20) not null,</span><br><span class="line">  grade float,</span><br><span class="line">  primary key(id)</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;插入数据</span><br><span class="line">insert into student (name,grade) values</span><br><span class="line">(&quot;howie1&quot;,40),</span><br><span class="line">(&quot;howie1&quot;,50),</span><br><span class="line">(&quot;howie2&quot;,50),</span><br><span class="line">(&quot;howie3&quot;,60),</span><br><span class="line">(&quot;howie4&quot;,70),</span><br><span class="line">(&quot;howie5&quot;,80),</span><br><span class="line">(&quot;howie6&quot;,null);</span><br><span class="line">&#x2F;&#x2F;查询全部</span><br><span class="line">select * from student;</span><br><span class="line">&#x2F;&#x2F;查询某个字段</span><br><span class="line">select name from student;</span><br><span class="line">&#x2F;&#x2F;条件查询,查询id&#x3D;2学生的信息</span><br><span class="line">select * from student where id&#x3D;2;</span><br><span class="line">&#x2F;&#x2F;in关键字查询,也可以使用not in</span><br><span class="line">select * from student where id IN(1,2,3);</span><br><span class="line">&#x2F;&#x2F;between and关键字查询</span><br><span class="line">select * from student where id between 2 and 5;</span><br><span class="line">&#x2F;&#x2F;空值(NULL)查询，使用IS NULL来判断</span><br><span class="line">select * from student where grade is null;</span><br><span class="line">&#x2F;&#x2F;distinct关键字查询</span><br><span class="line">select distinct name from student;</span><br><span class="line">&#x2F;&#x2F;like关键字查询,查询以h开头，e结尾的数据</span><br><span class="line">select * from student where name like &quot;h%e&quot;;</span><br><span class="line">&#x2F;&#x2F;and关键字多条件查询,or关键字的使用也是类似</span><br><span class="line">select * from student where id&gt;5 and grade&gt;60;</span><br></pre></td></tr></table></figure>
<h5 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;聚合函数</span><br><span class="line">&#x2F;&#x2F;count()函数,sum()函数,avg()函数,max()函数,min()函数</span><br><span class="line">select count(*) from student;</span><br><span class="line">select sum(grade) from student;</span><br><span class="line">select avg(grade) from student;</span><br><span class="line">select max(grade) from student;</span><br><span class="line">select min(grade) from student;</span><br><span class="line">&#x2F;&#x2F;对查询结果进行排序</span><br><span class="line">select * from student order by grade;</span><br><span class="line">&#x2F;&#x2F;分组查询</span><br><span class="line">&#x2F;&#x2F;1.单独使用group by分组</span><br><span class="line">select * from student group by grade;</span><br><span class="line">&#x2F;&#x2F;2.和聚合函数一起使用</span><br><span class="line">select count(*),grade from student group by grade;</span><br><span class="line">&#x2F;&#x2F;3.和having关键字一起使用</span><br><span class="line">select sum(grade),name from student group by grade having sum(grade) &gt;100;</span><br><span class="line">&#x2F;&#x2F;使用limit限制查询结果的数量</span><br><span class="line">select * from student limit 5;</span><br><span class="line">select * from student limit 2,2;</span><br><span class="line">select * from student order by grade desc limit 2,2;</span><br><span class="line">&#x2F;&#x2F;函数,mysql提供了许多函数</span><br><span class="line">select concat(id,&#39;:&#39;,name,&#39;:&#39;,grade) from student;</span><br><span class="line">&#x2F;&#x2F;为表取别名</span><br><span class="line">select * from student as stu where stu.name&#x3D;&quot;howie&quot;;</span><br><span class="line">&#x2F;&#x2F;为字段取别名,as关键字也可以不写</span><br><span class="line">select name as stu_name,grade stu_grade from student;</span><br></pre></td></tr></table></figure>
<h5 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h5><ul>
<li><p>外键</p>
<p>  外键指引用另一个表中的一列或者多列，被引用的列应该具有主键约束或者唯一性约束，用于建立和加强两个数据库表之间的连接。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建表class,student</span><br><span class="line">create table class(</span><br><span class="line">   id int not null primary key,</span><br><span class="line">   classname varchar(20) not null</span><br><span class="line">)ENGINE&#x3D;InnoDB;</span><br><span class="line">create table student(</span><br><span class="line">   stu_id int not null primary key,</span><br><span class="line">   stu_name varchar(20) not null,</span><br><span class="line">   cid int not null      -- 表示班级id，它就是class表的外键</span><br><span class="line">)ENGINE&#x3D;InnoDB;</span><br><span class="line">&#x2F;&#x2F;添加外键约束</span><br><span class="line">alter table student add constraint FK_ID foreign key(cid) references class(id);</span><br><span class="line">&#x2F;&#x2F;删除外键约束</span><br><span class="line">alter table student drop foreign key FK_ID;</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作关联表</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数据表有三种关联关系，多对一、多对多、一对一</span><br><span class="line">&#x2F;&#x2F;学生(student)和班级(class)是多对一关系，添加数据</span><br><span class="line">&#x2F;&#x2F;首选添加外键约束</span><br><span class="line">alter table student add constraint FK_ID foreign key(cid) references class(id);</span><br><span class="line">&#x2F;&#x2F;添加数据,这两个表便有了关联若插入中文在终端显示空白，可设置set names &#39;gbk&#39;;</span><br><span class="line">insert into class values(1,&quot;软件一班&quot;),(2,&quot;软件二班&quot;);</span><br><span class="line">insert into student values(1,&quot;howie&quot;,1),(2,&quot;howie1&quot;,2),(3,&quot;howie2&quot;,1),(4,&quot;howie3&quot;,2);</span><br><span class="line">&#x2F;&#x2F;交叉连接</span><br><span class="line">select * from student cross join class;</span><br><span class="line">&#x2F;&#x2F;内连接，该功能也可以使用where语句实现</span><br><span class="line">select student.stu_name,class.classname from student join class on class.id&#x3D;student.cid;</span><br><span class="line">&#x2F;&#x2F;外连接</span><br><span class="line">&#x2F;&#x2F;首先在student,class表中插入数据</span><br><span class="line">insert into class values(3,&quot;软件三班&quot;);</span><br><span class="line">&#x2F;&#x2F;左连接，右连接</span><br><span class="line">select s.stu_id,s.stu_name,c.classname from student s left join class c on c.id&#x3D;s.cid;</span><br><span class="line">select s.stu_id,s.stu_name,c.classname from student s right join class c on c.id&#x3D;s.cid;</span><br><span class="line">&#x2F;&#x2F;复合条件连接查询就是添加过滤条件</span><br><span class="line">&#x2F;&#x2F;子查询</span><br><span class="line">&#x2F;&#x2F;in关键字子查询跟上面的in关键字查询类似</span><br><span class="line">select * from student where cid in(select id from class where id&#x3D;2);</span><br><span class="line">&#x2F;&#x2F;exists关键字查询,相当于测试，不产生数据，只返回true或者false，只有返回true，外层才会执行，具体看下图</span><br><span class="line">select * from student where exists(select id from class where id&#x3D;12);   -- 外层不会执行</span><br><span class="line">select * from student where exists(select id from class where id&#x3D;1);    -- 外层会执行</span><br><span class="line">&#x2F;&#x2F;any关键字查询</span><br><span class="line"> select * from student where cid&gt;any(select id from class);</span><br><span class="line">&#x2F;&#x2F;all关键字查询</span><br><span class="line"> select * from student where cid&#x3D;any(select id from class);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="事务和存储过程"><a href="#事务和存储过程" class="headerlink" title="事务和存储过程"></a>事务和存储过程</h4><blockquote>
<p>事务的概念，会开启、提交和回滚事务<br>事务的四种隔离级别<br>创建存储过程<br>调用、查看、修改和删除存储过程</p>
</blockquote>
<h5 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction;  -- 开启事务</span><br><span class="line">commit;             -- 提交事务</span><br><span class="line">rollback;           -- 取消事务(回滚)</span><br><span class="line">&#x2F;&#x2F;创建表account，插入数据</span><br><span class="line">create table account(</span><br><span class="line">  id int primary key auto_increment,</span><br><span class="line">  name varchar(40),</span><br><span class="line">  money float</span><br><span class="line">);</span><br><span class="line">insert into account(name,money) values(&#39;a&#39;,1000),(&#39;b&#39;,2000),(&#39;c&#39;,3000);</span><br><span class="line">&#x2F;&#x2F;利用事务实现转账功能，首先开启事务，然后执行语句，提交事务</span><br><span class="line">start transaction;</span><br><span class="line">update account set money&#x3D;money-100 where name&#x3D;&#39;a&#39;;</span><br><span class="line">update account set money&#x3D;money+100 where name&#x3D;&#39;b&#39;;</span><br><span class="line">commit;</span><br><span class="line">&#x2F;&#x2F;事务的提交，通过这个命令查看mysql提交方式</span><br><span class="line">select @@autocommit; -- 若为1，表示自动提交，为0，就要手动提交</span><br><span class="line">&#x2F;&#x2F;若事务的提交方式为手动提交</span><br><span class="line">set @@autocommit &#x3D; 0; -- 设置为手动提交</span><br><span class="line">start transaction;</span><br><span class="line">update account set money&#x3D;money+100 where name&#x3D;&#39;a&#39;;</span><br><span class="line">update account set money&#x3D;money-100 where name&#x3D;&#39;b&#39;;</span><br><span class="line">&#x2F;&#x2F;现在执行select * from account 可以看到转账成功，若此时退出数据库重新登录，会看到各账户余额没有改变，所以一定要用commit语句提交事务，否则会失败</span><br><span class="line">&#x2F;&#x2F;事务的回滚，别忘记设置为手动提交的模式</span><br><span class="line">start transaction;</span><br><span class="line">update account set money&#x3D;money-100 where name&#x3D;&#39;a&#39;;</span><br><span class="line">update account set money&#x3D;money+100 where name&#x3D;&#39;b&#39;;</span><br><span class="line">&#x2F;&#x2F;若此时a不想转账给b，可以使用事务的回滚</span><br><span class="line">rollback;</span><br><span class="line">&#x2F;&#x2F;事务的隔离级别</span><br><span class="line">read uncommitted;</span><br><span class="line">read committed;</span><br><span class="line">repeatable read;</span><br><span class="line">serializable;</span><br></pre></td></tr></table></figure>
<h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建查看student表的存储过程</span><br><span class="line">&#x2F;&#x2F;创建student表</span><br><span class="line">create table student( </span><br><span class="line">  id int not null primary key auto_increment, </span><br><span class="line">  name varchar(4), </span><br><span class="line">  grade float </span><br><span class="line">)ENGINE&#x3D;InnoDB default character set utf8;</span><br><span class="line">delimiter &#x2F;&#x2F;  -- 将mysql的结束符设置为&#x2F;&#x2F;</span><br><span class="line">create procedure Proc()</span><br><span class="line">  begin</span><br><span class="line">  select * from student;</span><br><span class="line">  end &#x2F;&#x2F;</span><br><span class="line">delimiter ;   -- 将mysql的结束符设置为;</span><br><span class="line">call Proc();  -- 这样就可以调用该存储过程</span><br><span class="line">&#x2F;&#x2F;变量的使用,mysql中变量不用事前申明，在用的时候直接用“@变量名”使用就可以</span><br><span class="line">set @number&#x3D;100; -- 或set @num:&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;定义条件和处理程序</span><br><span class="line">&#x2F;&#x2F;光标的使用</span><br><span class="line">&#x2F;&#x2F;1.声明光标</span><br><span class="line">DECLARE * cursor_name* CURSOR FOR select_statement</span><br><span class="line">2. 光标OPEN语句</span><br><span class="line">OPEN cursor_name</span><br><span class="line">3. 光标FETCH语句</span><br><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br><span class="line">4. 光标CLOSE语句</span><br><span class="line">CLOSE cursor_name</span><br><span class="line">&#x2F;&#x2F;流程控制的使用  不做介绍</span><br></pre></td></tr></table></figure>
<h5 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义存储过程</span><br><span class="line">delimiter &#x2F;&#x2F;</span><br><span class="line">create procedure proc1(in name varchar(4),out num int)</span><br><span class="line">begin</span><br><span class="line">select count(*) into num from student where name&#x3D;name;</span><br><span class="line">end&#x2F;&#x2F;</span><br><span class="line">delimiter ;</span><br><span class="line">&#x2F;&#x2F;调用存储过程</span><br><span class="line">call proc1(&quot;tom&quot;,@num) -- 查找名为tom学生人数</span><br><span class="line">&#x2F;&#x2F;查看结果</span><br><span class="line">select @num;  -- 看下图</span><br></pre></td></tr></table></figure>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><blockquote>
<p>如何创建视图<br>查看、修改、更新、删除视图</p>
</blockquote>
<h5 id="视图的基本操作"><a href="#视图的基本操作" class="headerlink" title="视图的基本操作"></a>视图的基本操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在单表上创建视图,重新创建student表，插入数据</span><br><span class="line">create table student(</span><br><span class="line">  id int not null primary key auto_increment,</span><br><span class="line">  name varchar(10) not null,</span><br><span class="line">  math float,</span><br><span class="line">  chinese float</span><br><span class="line">);</span><br><span class="line">insert into student(name,math,chinese) values</span><br><span class="line">(&#39;howie1&#39;,66,77),</span><br><span class="line">(&#39;howie2&#39;,66,77),</span><br><span class="line">(&#39;howie3&#39;,66,77);</span><br><span class="line">&#x2F;&#x2F;开始创建视图</span><br><span class="line">create view stu_view as select math,chinese,math+chinese from student;  -- 下图可看出创建成功</span><br><span class="line">&#x2F;&#x2F;也可以创建自定义字段名称的视图</span><br><span class="line">create view stu_view2(math,chin,sum) as select math,chinese,math+chinese from student;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在多表上创建视图，创建表stu_info，插入数据</span><br><span class="line">create table stu_info(</span><br><span class="line">  id int not null primary key auto_increment,</span><br><span class="line">  class varchar(10) not null,</span><br><span class="line">  addr varchar(100)</span><br><span class="line">);</span><br><span class="line">insert into stu_info(class,addr) values</span><br><span class="line">(&#39;1&#39;,&#39;anhui&#39;),</span><br><span class="line">(&#39;2&#39;,&#39;fujian&#39;),</span><br><span class="line">(&#39;3&#39;,&#39;guangdong&#39;);</span><br><span class="line">&#x2F;&#x2F;创建视图stu_class</span><br><span class="line">create view stu_class(id,name,class) as </span><br><span class="line">select student.id,student.name,stu_info.class from </span><br><span class="line">student,stu_info where student.id&#x3D;stu_info.id;</span><br><span class="line">&#x2F;&#x2F;查看视图</span><br><span class="line">desc stu_class;</span><br><span class="line">show table status like &#39;stu_class&#39;\G</span><br><span class="line">show create view stu_class\G</span><br><span class="line">&#x2F;&#x2F;修改视图</span><br><span class="line">create or replace view stu_view as select * from student;</span><br><span class="line">alter view stu_view as select chinese from student;</span><br><span class="line">&#x2F;&#x2F;更新视图</span><br><span class="line">update stu_view set chinese&#x3D;100;</span><br><span class="line">insert into student values(null,&#39;haha&#39;,100,100);</span><br><span class="line">delete from stu_view2 where math&#x3D;100;</span><br><span class="line">&#x2F;&#x2F;删除视图</span><br><span class="line">drop view if exists stu_view2;</span><br></pre></td></tr></table></figure>
<h4 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h4><ul>
<li><p>将 lamp138 库导出</p>
<p>  <code>mysqldump -u root -p lamp138 &gt; lamp138.sql</code></p>
</li>
<li><p>将 lamp138 库中的 stu 表导出</p>
<p>  <code>mysqldump -u root -p lamp138 stu &gt; lamp138_stu.sql</code></p>
</li>
<li><p>将 lamp138 库导入</p>
<p>  <code>mysql -u root -p lamp138 &lt; lamp138.sql</code></p>
</li>
<li><p>将 lamp138 库中的 stu 表导入</p>
<p>  <code>mysql -u root -p lamp138 &lt; lamp138_stu.sql</code></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>nacos基础教程</title>
    <url>/2020/07/21/nacos%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="什么是Nacos"><a href="#什么是Nacos" class="headerlink" title="什么是Nacos"></a>什么是Nacos</h4><p>Nacos致力于帮助您发现、配置和管理微服务。</p>
<p>Nacos提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>是Spring Cloud A中的服务注册发现组件，类似于Consul、Eureka，同时它又提供了分布式配置中心的功能，这点和Consul的config类似，支持热加载。</p>
<h5 id="Nacos的关键特性包括："><a href="#Nacos的关键特性包括：" class="headerlink" title="Nacos的关键特性包括："></a>Nacos的关键特性包括：</h5><ul>
<li>服务发现和服务健康监测</li>
<li>动态配置服务，带管理界面，支持丰富的配置维度</li>
<li>动态DNS服务</li>
<li>服务及其元数据管理</li>
</ul>
<h4 id="使用Nacos服务注册和发现"><a href="#使用Nacos服务注册和发现" class="headerlink" title="使用Nacos服务注册和发现"></a>使用Nacos服务注册和发现</h4><p>服务注册和发现是微服务治理的根基，服务注册和发现组件是整个微服务系统的 <strong>灵魂</strong>，选择合适的服务注册和发现组件至关重要，目前主流的服务注册和发现组件有<code>Consul,Eureka,Etcd</code>等。</p>
<p>随着Euraka的闭源，Spring Cloud netflix-oss组件大规模的进入到了维护期，不再提供新功能，spring cloud alibaba受到开源社区的大力拥护。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx入门指南</title>
    <url>/2020/07/13/nginx%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h4 id="windows下启动nginx"><a href="#windows下启动nginx" class="headerlink" title="windows下启动nginx"></a>windows下启动nginx</h4><p><strong>注意不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程</strong></p>
<blockquote>
<p>cmd 进入Nginx解压目录 执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">![22](/22.png)start nginx : 启动nginx服务</span><br><span class="line">nginx -s reload  ：修改配置后重新加载生效</span><br><span class="line">nginx -s reopen  ：重新打开日志文件</span><br><span class="line">nginx -t -c /path/to/nginx.conf 测试nginx配置文件是否正确</span><br></pre></td></tr></table></figure>
</blockquote>
<p>window下检查nginx服务是否启动</p>
<blockquote>
<p><code>tasklist /fi &quot;imagename eq nginx.exe&quot;</code>,在cmd窗口输入前面的命令，若如下图所示，表示已经启动了。</p>
<p><img src="http://wrr123.github.io/2020/07/13/nginx%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/22.png" alt></p>
</blockquote>
<h4 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h4><blockquote>
<p>验证配置是否正确: nginx -t</p>
<p>查看Nginx的版本号：nginx -V</p>
<p>启动Nginx：start nginx</p>
<p>快速停止或关闭Nginx：nginx -s stop</p>
<p>正常停止或关闭Nginx：nginx -s quit</p>
<p>配置文件修改重装载命令：nginx -s reload</p>
</blockquote>
<h4 id="nginx反向代理的作用"><a href="#nginx反向代理的作用" class="headerlink" title="nginx反向代理的作用"></a>nginx反向代理的作用</h4><blockquote>
<p>项目部署在多个tomcat上，即使其中一个tomcat不能访问了也能访问其他的tomcat服务，</p>
</blockquote>
<p><img src="http://wrr123.github.io/2020/07/13/nginx%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/11.png" alt></p>
<h4 id="nginx配置并部署-案例1"><a href="#nginx配置并部署-案例1" class="headerlink" title="nginx配置并部署(案例1)"></a>nginx配置并部署(案例1)</h4><blockquote>
<p>配置两个Tomcat服务指向 localhost:8070 和 localhost:8071他们的权重都是5（权重越大就越容易被访问）</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">upstream localhost &#123;  </span><br><span class="line">     #根据ip计算将请求分配各那个后端tomcat，许多人误认为可以解决session问题，其实并不能。  </span><br><span class="line">     #同一机器在多网情况下，路由切换，ip可能不同  </span><br><span class="line">     #ip_hash;   </span><br><span class="line">     server localhost:8070 weight=5;  </span><br><span class="line">     server localhost:8071 weight=5;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>
<h4 id="Nginx-部署-vue-项目"><a href="#Nginx-部署-vue-项目" class="headerlink" title="Nginx 部署 vue 项目"></a>Nginx 部署 vue 项目</h4><p>在 vue 项目根目录中使用命令 <code>npm run build</code>  创建输出文件，将 dist 文件夹下的所有内容复制到 nginx 目录下的 <code>webapp</code> 内（没有的话，自行创建）</p>
<p>修改 nignx 目录中的 <code>conf/nginx.conf</code> 文件，在 <code>http -&gt; server</code> 节点中，修改 location 节点的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    root   webapp;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在nginx根目录使用命令<code>nginx -s reload</code>即可在浏览器中通过<code>http://localhost</code>访问项目。</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>node和node-sass的版本兼容问题</title>
    <url>/2020/07/31/node%E5%92%8Cnode-sass%E7%9A%84%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p><img src="http://wrr123.github.io/2020/07/31/node%E5%92%8Cnode-sass%E7%9A%84%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/001.png" alt="npm编译出错日志"></p>
<h5 id="node-sass和node版本的对应关系"><a href="#node-sass和node版本的对应关系" class="headerlink" title="node-sass和node版本的对应关系"></a>node-sass和node版本的对应关系</h5><p>Supported Node.js versions vary by release, please consult the <a href="https://github.com/sass/node-sass/releases">releases page</a>. Below is a quick guide for minimun support:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">NodeJS</th>
<th style="text-align:left">Minimum node-sass version</th>
<th style="text-align:left">Node Module</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Node 14</td>
<td style="text-align:left">4.14+</td>
<td style="text-align:left">83</td>
</tr>
<tr>
<td style="text-align:left">Node 13</td>
<td style="text-align:left">4.13+</td>
<td style="text-align:left">79</td>
</tr>
<tr>
<td style="text-align:left">Node 12</td>
<td style="text-align:left">4.12+</td>
<td style="text-align:left">72</td>
</tr>
<tr>
<td style="text-align:left">Node 11</td>
<td style="text-align:left">4.10+</td>
<td style="text-align:left">67</td>
</tr>
<tr>
<td style="text-align:left">Node 10</td>
<td style="text-align:left">4.9+</td>
<td style="text-align:left">64</td>
</tr>
<tr>
<td style="text-align:left">Node 8</td>
<td style="text-align:left">4.5.3+</td>
<td style="text-align:left">57</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-ideas</title>
    <url>/2020/08/16/notebook-IDEs/</url>
    <content><![CDATA[<h1 id="Mon-Oct-28-15-09-06-CST-2019"><a href="#Mon-Oct-28-15-09-06-CST-2019" class="headerlink" title="Mon Oct 28 15:09:06 CST 2019"></a>Mon Oct 28 15:09:06 CST 2019</h1><h2 id="idea-编译项目时，出现错误非法字符-65279"><a href="#idea-编译项目时，出现错误非法字符-65279" class="headerlink" title="idea 编译项目时，出现错误非法字符 \65279?"></a>idea 编译项目时，出现错误<code>非法字符 \65279</code>?</h2><ul>
<li>IDEA导入项目出现\65279非法字符</li>
<li>这个问题也是由于带BOM的UTF-8格式引起的，至少我遇到都是这样，一般在linux上和macos上导入项目会发生，可能是由于在windows上用一些软件编辑过文件导致的。解决办法也很简单，下面就说一下解决办法。</li>
<li>比如说我将一个项目导入到idea发现报错了，可以使用命令行，首先进入src目录的同级目录：</li>
<li>输入：vi</li>
<li>输入：:args ./src/<strong> 这里的</strong>表示循环src下的所有文件夹</li>
<li>输入：:ar 这一步可选，目的是查看当前添加了哪些目标文件</li>
<li>输入：:argdo set nobomb | update! 这句意思是对args列表中的文件分别执行 set nobomb 然后强制保存</li>
<li>以上就是步骤，这样就可以了。</li>
</ul>
<h1 id="Thu-Oct-31-10-11-40-CST-2019"><a href="#Thu-Oct-31-10-11-40-CST-2019" class="headerlink" title="Thu Oct 31 10:11:40 CST 2019"></a>Thu Oct 31 10:11:40 CST 2019</h1><h2 id="idea2019-2版本激活报错error-1653219"><a href="#idea2019-2版本激活报错error-1653219" class="headerlink" title="idea2019-2版本激活报错error 1653219?"></a>idea2019-2版本激活报错<code>error 1653219</code>?</h2><ol>
<li>说法1：注释掉<code>/etc/hosts</code>文件里的<code>0.0.0.0 account.jetbrains.com</code>等信息,并添加<code>0.0.0.0 https://account.jetbrains.com:443</code>到hosts文件。</li>
</ol>
<h1 id="Thu-Nov-7-23-17-14-CST-2019"><a href="#Thu-Nov-7-23-17-14-CST-2019" class="headerlink" title="Thu Nov  7 23:17:14 CST 2019"></a>Thu Nov  7 23:17:14 CST 2019</h1><h2 id="常用的一些插件推荐"><a href="#常用的一些插件推荐" class="headerlink" title="常用的一些插件推荐"></a>常用的一些插件推荐</h2><ul>
<li>FindBugs</li>
<li>maven helper</li>
<li>Rainbow brackets</li>
<li>Key Promoter X</li>
<li>GsonFormat</li>
<li>RestfulToolkit</li>
<li>Free Mybatis</li>
</ul>
<h1 id="Tue-Nov-12-13-30-31-CST-2019"><a href="#Tue-Nov-12-13-30-31-CST-2019" class="headerlink" title="Tue Nov 12 13:30:31 CST 2019"></a>Tue Nov 12 13:30:31 CST 2019</h1><h2 id="解决idea自动重置LanguageLevel和JavaCompiler版本的问题？"><a href="#解决idea自动重置LanguageLevel和JavaCompiler版本的问题？" class="headerlink" title="解决idea自动重置LanguageLevel和JavaCompiler版本的问题？"></a>解决idea自动重置LanguageLevel和JavaCompiler版本的问题？</h2><ul>
<li>产生的原因：修改pom文件后，maven会自动修改编译器版本到maven的默认编译版本</li>
<li>解决办法：修改pom文件，增加如下一段：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-bootstrap</title>
    <url>/2020/08/16/notebook-bootstrap/</url>
    <content><![CDATA[<h3 id="2020-03-25-09-45-49-星期三"><a href="#2020-03-25-09-45-49-星期三" class="headerlink" title="2020-03-25 09:45:49 星期三"></a>2020-03-25 09:45:49 星期三</h3><h3 id="form表单的基本样式"><a href="#form表单的基本样式" class="headerlink" title="form表单的基本样式"></a>form表单的基本样式</h3><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ul>
<li>“行（row）”必须包含在 <code>.container</code>(固定宽度)或 <code>.container-fluid</code>(100%宽度)中，以便为其赋予合适的排列(aligment)和内部(padding)。</li>
<li>通过”行（row）”在水平方向创建一组”列（column）”。</li>
<li>你的内容应当放置于”列（column）”内，并且，只有”列（column）”可以作为”行（row）”的直接子元素。</li>
<li>类似 <code>.row</code> 和 <code>.col-xs-4</code>这种预定义的类，可以用来快速创建栅格布局。Bootstrap源码中定义的 <strong>mixin</strong> 也可以用来创建语义化的布局。</li>
<li>…… .etc</li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-charge</title>
    <url>/2020/08/16/notebook-charge/</url>
    <content><![CDATA[<h1 id="Wed-Dec-18-16-32-19-CST-2019"><a href="#Wed-Dec-18-16-32-19-CST-2019" class="headerlink" title="Wed Dec 18 16:32:19 CST 2019"></a>Wed Dec 18 16:32:19 CST 2019</h1><h2 id="找出无重复的最长字符串"><a href="#找出无重复的最长字符串" class="headerlink" title="找出无重复的最长字符串"></a>找出无重复的最长字符串</h2><ul>
<li>analyze<ol>
<li>输入: 字符串; 输出: 字符串</li>
<li>将字符串转成字符数组，判断当前字符在前一个子字符串中是否出现过，若没出现，找下一个字符；若出现过，则重置子字符串，然后重复之前的操作。</li>
<li></li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-demandAnalysis</title>
    <url>/2020/08/16/notebook-demandAnalysis/</url>
    <content><![CDATA[<h1 id="2020年-1月-2日-星期四-19时12分10秒-CST"><a href="#2020年-1月-2日-星期四-19时12分10秒-CST" class="headerlink" title="2020年 1月 2日 星期四 19时12分10秒 CST"></a>2020年 1月 2日 星期四 19时12分10秒 CST</h1><h2 id="通用的socket客户端服务"><a href="#通用的socket客户端服务" class="headerlink" title="通用的socket客户端服务"></a>通用的socket客户端服务</h2><ul>
<li>数据结构设计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entity</span><br><span class="line">	请求报文</span><br><span class="line">	  属性--需要的一些字段</span><br><span class="line">	返回报文</span><br><span class="line">dao</span><br><span class="line">service(interface)</span><br><span class="line">	人行客户端</span><br><span class="line">		全局变量</span><br><span class="line">		method</span><br><span class="line">			1. send message</span><br><span class="line">			2. receive message</span><br><span class="line">  impl</span><br><span class="line">controller</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-docker</title>
    <url>/2020/08/16/notebook-docker/</url>
    <content><![CDATA[<h1 id="Thu-Nov-7-12-35-57-CST-2019"><a href="#Thu-Nov-7-12-35-57-CST-2019" class="headerlink" title="Thu Nov  7 12:35:57 CST 2019"></a>Thu Nov  7 12:35:57 CST 2019</h1><h2 id="将本地的文件复制到docker容器中"><a href="#将本地的文件复制到docker容器中" class="headerlink" title="将本地的文件复制到docker容器中"></a>将本地的文件复制到docker容器中</h2><ol>
<li>查询出容器的id全称<ul>
<li><code>docker ps -a</code>查出容器的names</li>
<li><code>docker inspect -f &#39;&#123;&#123;.ID&#125;&#125;&#39; 容器names</code></li>
</ul>
</li>
<li><code>docker cp 本地路径 容器长ID:容器路径</code><h2 id="将容器中的文件复制到本地"><a href="#将容器中的文件复制到本地" class="headerlink" title="将容器中的文件复制到本地"></a>将容器中的文件复制到本地</h2></li>
</ol>
<ul>
<li><code>docker cp 容器名:容器文件路径 本地路径</code></li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-emacs</title>
    <url>/2020/08/16/notebook-emacs/</url>
    <content><![CDATA[<h1 id="Tue-Oct-22-21-07-02-CST-2019"><a href="#Tue-Oct-22-21-07-02-CST-2019" class="headerlink" title="Tue Oct 22 21:07:02 CST 2019"></a>Tue Oct 22 21:07:02 CST 2019</h1><h2 id="获取一些emacs的入门指导资料"><a href="#获取一些emacs的入门指导资料" class="headerlink" title="获取一些emacs的入门指导资料"></a>获取一些emacs的入门指导资料</h2>]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-git</title>
    <url>/2020/08/16/notebook-git/</url>
    <content><![CDATA[<h1 id="Thu-Dec-12-12-58-02-CST-2019"><a href="#Thu-Dec-12-12-58-02-CST-2019" class="headerlink" title="Thu Dec 12 12:58:02 CST 2019"></a>Thu Dec 12 12:58:02 CST 2019</h1><h2 id="git和svn相结合？-Version-Control-System"><a href="#git和svn相结合？-Version-Control-System" class="headerlink" title="git和svn相结合？(Version Control System)"></a>git和svn相结合？(Version Control System)</h2><ul>
<li>更新(git svn rebase)</li>
<li>提交(git svn dcommit)</li>
</ul>
<h1 id="Wed-Dec-18-08-47-29-CST-2019"><a href="#Wed-Dec-18-08-47-29-CST-2019" class="headerlink" title="Wed Dec 18 08:47:29 CST 2019"></a>Wed Dec 18 08:47:29 CST 2019</h1><h2 id="git-pull出现冲突时的几种解决方法？"><a href="#git-pull出现冲突时的几种解决方法？" class="headerlink" title="git pull出现冲突时的几种解决方法？"></a>git pull出现冲突时的几种解决方法？</h2><blockquote>
<p><a href="https://www.cnblogs.com/zjfjava/p/10280247.html">cnblogs</a></p>
</blockquote>
<h1 id="Thu-Dec-19-09-39-51-CST-2019"><a href="#Thu-Dec-19-09-39-51-CST-2019" class="headerlink" title="Thu Dec 19 09:39:51 CST 2019"></a>Thu Dec 19 09:39:51 CST 2019</h1><h2 id><a href="#" class="headerlink" title=" "></a> </h2><h1 id="Sat-Dec-21-16-18-56-CST-2019"><a href="#Sat-Dec-21-16-18-56-CST-2019" class="headerlink" title="Sat Dec 21 16:18:56 CST 2019"></a>Sat Dec 21 16:18:56 CST 2019</h1><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><ul>
<li>默认比较工作空间文件和未提交到缓存空间的文件；<h2 id="git-diff-—staged"><a href="#git-diff-—staged" class="headerlink" title="git diff —staged"></a>git diff —staged</h2></li>
<li>比较工作空间文件和缓存空间的文件;<h2 id="git账号设置公匙-SSH-KEY"><a href="#git账号设置公匙-SSH-KEY" class="headerlink" title="git账号设置公匙(SSH-KEY)"></a>git账号设置公匙(SSH-KEY)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 账号 -f 生成的公匙文件的全路径名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制公匙文件的代码到github的添加公匙处</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试是否添加成功</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示如下表示成功</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Hi wrr123! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Sun-Dec-22-11-22-50-CST-2019"><a href="#Sun-Dec-22-11-22-50-CST-2019" class="headerlink" title="Sun Dec 22 11:22:50 CST 2019"></a>Sun Dec 22 11:22:50 CST 2019</h1><h2 id="git打包"><a href="#git打包" class="headerlink" title="git打包"></a>git打包</h2><ul>
<li>git archive<ol>
<li>打包最后一个版本修改的文件<br><code>git archive --format=zip -o update.zip HEAD $(git diff --name-only HEAD^)</code></li>
</ol>
</li>
<li>git bundle<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2></li>
<li>合并分支</li>
<li>合并提交的记录</li>
</ul>
<h1 id="Wed-Dec-25-21-56-53-CST-2019"><a href="#Wed-Dec-25-21-56-53-CST-2019" class="headerlink" title="Wed Dec 25 21:56:53 CST 2019"></a>Wed Dec 25 21:56:53 CST 2019</h1><h2 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h2><ul>
<li>更新子模块中还存在子模块的项目<br><code>git submodule foreach git submodule update</code></li>
</ul>
<h1 id="Thu-Dec-26-10-19-19-CST-2019"><a href="#Thu-Dec-26-10-19-19-CST-2019" class="headerlink" title="Thu Dec 26 10:19:19 CST 2019"></a>Thu Dec 26 10:19:19 CST 2019</h1><h2 id="Git-遇到了-early-EOF-index-pack-failed-问题"><a href="#Git-遇到了-early-EOF-index-pack-failed-问题" class="headerlink" title="Git 遇到了 early EOF index-pack failed 问题?"></a>Git 遇到了 early EOF index-pack failed 问题?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 为 git 添加配置项，通过下面的命令可以简单完成</span><br><span class="line"># 在这之前可以执行 git config -l 命令看看已有配置项有哪些</span><br><span class="line">git config --add core.compression -1</span><br></pre></td></tr></table></figure>
<h2 id="将工作空间中的文件-已经提交过git仓库的-设置成状态为忽略的-即不需要提交到git仓库-？"><a href="#将工作空间中的文件-已经提交过git仓库的-设置成状态为忽略的-即不需要提交到git仓库-？" class="headerlink" title="将工作空间中的文件(已经提交过git仓库的)设置成状态为忽略的(即不需要提交到git仓库)？"></a>将工作空间中的文件(已经提交过git仓库的)设置成状态为忽略的(即不需要提交到git仓库)？</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git st --short|awk &#x27;&#123;print $2&#125;&#x27;|xargs git update-index --assume-unchanged</span><br></pre></td></tr></table></figure>
<h2 id="查看使用git-update-index-assume-unchanged忽略的文件-并将其状态设为正常"><a href="#查看使用git-update-index-assume-unchanged忽略的文件-并将其状态设为正常" class="headerlink" title="查看使用git update-index --assume-unchanged忽略的文件,并将其状态设为正常?"></a>查看使用<code>git update-index --assume-unchanged</code>忽略的文件,并将其状态设为正常?</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git ls-files -v |grep &#x27;^h&#x27;|awk &#x27;&#123;print $2&#125;&#x27;|xargs git update-index --no-assume-unchanged</span><br></pre></td></tr></table></figure>
<h2 id="问题-使用了git-update-index-assume-unchanged忽略的文件之后，再使用git-stash储藏工作空间变更的文件，然后使用git-stash-pop释放储藏的文件时，会将之前忽略的文件修改的内容全部还原-为啥？"><a href="#问题-使用了git-update-index-assume-unchanged忽略的文件之后，再使用git-stash储藏工作空间变更的文件，然后使用git-stash-pop释放储藏的文件时，会将之前忽略的文件修改的内容全部还原-为啥？" class="headerlink" title="问题: 使用了git update-index --assume-unchanged忽略的文件之后，再使用git stash储藏工作空间变更的文件，然后使用git stash pop释放储藏的文件时，会将之前忽略的文件修改的内容全部还原,为啥？"></a>问题: 使用了<code>git update-index --assume-unchanged</code>忽略的文件之后，再使用<code>git stash</code>储藏工作空间变更的文件，然后使用<code>git stash pop</code>释放储藏的文件时，会将之前忽略的文件修改的内容全部还原,为啥？</h2><h1 id="2020年-1月-2日-星期四-10时36分40秒-CST"><a href="#2020年-1月-2日-星期四-10时36分40秒-CST" class="headerlink" title="2020年 1月 2日 星期四 10时36分40秒 CST"></a>2020年 1月 2日 星期四 10时36分40秒 CST</h1><h2 id="NUL-termination的含义"><a href="#NUL-termination的含义" class="headerlink" title="NUL termination的含义"></a><code>NUL termination</code>的含义</h2><p>空字符串(null charactor),亦称结束符。</p>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-gradle</title>
    <url>/2020/08/16/notebook-gradle/</url>
    <content><![CDATA[<h1 id="Sun-Dec-8-14-44-05-CST-2019"><a href="#Sun-Dec-8-14-44-05-CST-2019" class="headerlink" title="Sun Dec  8 14:44:05 CST 2019"></a>Sun Dec  8 14:44:05 CST 2019</h1><h2 id="gradle中-lt-lt-操作符的含义"><a href="#gradle中-lt-lt-操作符的含义" class="headerlink" title="gradle中&lt;&lt;操作符的含义"></a>gradle中<code>&lt;&lt;</code>操作符的含义</h2><ul>
<li>相当于list.add()方法，将元素添加到一个列表中，是一种简写。</li>
</ul>
<h1 id="Mon-Dec-9-09-29-52-CST-2019"><a href="#Mon-Dec-9-09-29-52-CST-2019" class="headerlink" title="Mon Dec  9 09:29:52 CST 2019"></a>Mon Dec  9 09:29:52 CST 2019</h1><h2 id="将maven项目转换成gradle项目"><a href="#将maven项目转换成gradle项目" class="headerlink" title="将maven项目转换成gradle项目"></a>将maven项目转换成gradle项目</h2><p><code>gradle init --type pom</code></p>
<h2 id="dependencies下的implementation和api的区别？"><a href="#dependencies下的implementation和api的区别？" class="headerlink" title="dependencies下的implementation和api的区别？"></a>dependencies下的implementation和api的区别？</h2><ul>
<li>implementation只对当前模块有用，对于传递的依赖不可进行获取</li>
<li>api适用于当前依赖和传递依赖</li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-html</title>
    <url>/2020/08/16/notebook-html/</url>
    <content><![CDATA[<h3 id="2020-03-23-13-19-50-星期一"><a href="#2020-03-23-13-19-50-星期一" class="headerlink" title="2020-03-23 13:19:50 星期一"></a>2020-03-23 13:19:50 星期一</h3><h5 id="html中有用的字符实体"><a href="#html中有用的字符实体" class="headerlink" title="html中有用的字符实体"></a>html中有用的字符实体</h5><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>空格</th>
<th><code>&amp;nbsp;</code></th>
<th><code>&amp;#160;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td><code>&amp;lt;</code></td>
<td><code>&amp;#60;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td><code>&amp;gt;</code></td>
<td><code>&amp;#62;</code></td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td><code>&amp;amp;</code></td>
<td><code>&amp;#38;</code></td>
</tr>
<tr>
<td>“</td>
<td>引号</td>
<td><code>&amp;quot;</code></td>
<td><code>&amp;#34;</code></td>
</tr>
<tr>
<td>‘</td>
<td>撇号</td>
<td><code>&amp;apos;</code>(IE不支持)</td>
<td><code>&amp;#39;</code></td>
</tr>
<tr>
<td>¢</td>
<td>分（cent）</td>
<td><code>&amp;cent;</code></td>
<td><code>&amp;#162;</code></td>
</tr>
<tr>
<td>£</td>
<td>镑（pound）</td>
<td><code>&amp;pound;</code></td>
<td><code>&amp;#163;</code></td>
</tr>
<tr>
<td>￥</td>
<td>元（yen）</td>
<td><code>&amp;yen;</code></td>
<td><code>&amp;#165;</code></td>
</tr>
<tr>
<td>€</td>
<td>欧元（euro）</td>
<td><code>&amp;euro;</code></td>
<td><code>&amp;#8364;</code></td>
</tr>
<tr>
<td>§</td>
<td>小节</td>
<td><code>&amp;sect;</code></td>
<td><code>&amp;#167;</code></td>
</tr>
<tr>
<td>©</td>
<td>版权（copyright）</td>
<td><code>&amp;copy;</code></td>
<td><code>&amp;#169;</code></td>
</tr>
<tr>
<td>™</td>
<td>商标</td>
<td><code>&amp;trade;</code></td>
<td><code>&amp;#8482;</code></td>
</tr>
<tr>
<td>x</td>
<td>乘号</td>
<td><code>&amp;times;</code></td>
<td><code>&amp;#215;</code></td>
</tr>
<tr>
<td>➗</td>
<td>除号</td>
<td><code>&amp;divide;</code></td>
<td><code>&amp;#247;</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="2020-03-27-10-31-31-星期五"><a href="#2020-03-27-10-31-31-星期五" class="headerlink" title="2020-03-27 10:31:31 星期五"></a>2020-03-27 10:31:31 星期五</h3><h5 id="css文字如何垂直居中"><a href="#css文字如何垂直居中" class="headerlink" title="css文字如何垂直居中"></a>css文字如何垂直居中</h5><p>三种方式</p>
<ol>
<li>使用 <code>line-height</code>属性</li>
<li>将外部块格式化为表格单元格</li>
<li>使用css3的flex布局</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">                <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">                <span class="attribute">background</span>: <span class="number">#ddd</span>;</span><br><span class="line">                <span class="attribute">line-height</span>:<span class="number">300px</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">                <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">                <span class="attribute">background</span>: <span class="number">#ddd</span>;</span><br><span class="line">								<span class="attribute">display</span>: table-cell;</span><br><span class="line">								<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">            &#125;</span><br><span class="line"> <span class="selector-class">.box</span>&#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">                <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">                <span class="attribute">background</span>: <span class="number">#ddd</span>;</span><br><span class="line">                 <span class="comment">/*设置为伸缩容器*/</span></span><br><span class="line">                <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">                <span class="attribute">display</span>: -moz-box;</span><br><span class="line">                <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">                <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">                <span class="attribute">display</span>: flex;</span><br><span class="line">                <span class="comment">/*垂直居中*/</span></span><br><span class="line">                -webkit-box-align: center;<span class="comment">/*旧版本*/</span></span><br><span class="line">                -moz-box-align: center;<span class="comment">/*旧版本*/</span></span><br><span class="line">                -ms-<span class="attribute">flex</span>-align: center;<span class="comment">/*混合版本*/</span></span><br><span class="line">                -webkit-<span class="attribute">align-items</span>: center;<span class="comment">/*新版本*/</span></span><br><span class="line">                <span class="attribute">align-items</span>: center;<span class="comment">/*新版本*/</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="css圆角"><a href="#css圆角" class="headerlink" title="css圆角"></a>css圆角</h5><ul>
<li>border-radius</li>
</ul>
<h4 id="html分割线"><a href="#html分割线" class="headerlink" title="html分割线"></a>html分割线</h4><h6 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h6><ol>
<li><p><code>&lt;hr&gt;</code></p>
</li>
<li><p><code>&lt;HR align=center width=300 color=#987cb9 SIZE=1&gt;</code></p>
<p> align线条位置（left、right、center）</p>
<p> width 线条宽度</p>
<p> color 颜色</p>
<p> size 厚度</p>
</li>
</ol>
<h6 id="特效（特效不是孤立的，可相互组合）"><a href="#特效（特效不是孤立的，可相互组合）" class="headerlink" title="特效（特效不是孤立的，可相互组合）"></a>特效（特效不是孤立的，可相互组合）</h6><ul>
<li><p>两头渐变透明</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HR</span> <span class="attr">style</span>=<span class="string">&quot;FILTER: alpha(opacity=100,finishopacity=0,style=3)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">color</span>=<span class="string">#987cb9</span> <span class="attr">SIZE</span>=<span class="string">3</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>纺锤形</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HR</span> <span class="attr">style</span>=<span class="string">&quot;FILTER: alpha(opacity=100,finishopacity=0,style=2)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">color</span>=<span class="string">#987cb9</span> <span class="attr">SIZE</span>=<span class="string">10</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>右边渐变透明</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HR</span> <span class="attr">style</span>=<span class="string">&quot;FILTER: alpha(opacity=100,finishopacity=0,style=1)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">color</span>=<span class="string">#987cb9</span> <span class="attr">SIZE</span>=<span class="string">3</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>左边渐变透明</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HR</span> <span class="attr">style</span>=<span class="string">&quot;FILTER: alpha(opacity=0,finishopacity=100,style=1)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">color</span>=<span class="string">#987cb9</span> <span class="attr">SIZE</span>=<span class="string">3</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚线</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HR</span> <span class="attr">style</span>=<span class="string">&quot;border:1 dashed #987cb9&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">color</span>=<span class="string">#987cb9</span> <span class="attr">SIZE</span>=<span class="string">1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双线</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HR</span> <span class="attr">style</span>=<span class="string">&quot;border:3 double #987cb9&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">color</span>=<span class="string">#987cb9</span> <span class="attr">SIZE</span>=<span class="string">3</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>立体效果</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HR</span> <span class="attr">style</span>=<span class="string">&quot;FILTER: progid:DXImageTransform.Microsoft.Shadow</span></span></span><br><span class="line"><span class="tag"><span class="string">(color:#987cb9,direction:145,strength:15)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">color</span>=<span class="string">#987cb9</span> <span class="attr">SIZE</span>=<span class="string">1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>钢针效果</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HR</span> <span class="attr">style</span>=<span class="string">&quot;FILTER: progid:DXImageTransform.Microsoft.Glow(color=#987cb9,strength=10)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">color</span>=<span class="string">#987cb9</span> <span class="attr">SIZE</span>=<span class="string">1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>垂直分割线</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:265px;border-left</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-java</title>
    <url>/2020/08/16/notebook-java/</url>
    <content><![CDATA[<h1 id="Tue-Oct-22-21-00-30-CST-2019"><a href="#Tue-Oct-22-21-00-30-CST-2019" class="headerlink" title="Tue Oct 22 21:00:30 CST 2019"></a>Tue Oct 22 21:00:30 CST 2019</h1><h2 id="将服务器端的文件下载到浏览器本地？"><a href="#将服务器端的文件下载到浏览器本地？" class="headerlink" title="将服务器端的文件下载到浏览器本地？"></a>将服务器端的文件下载到浏览器本地？</h2><h1 id="Thu-Oct-24-20-48-45-CST-2019"><a href="#Thu-Oct-24-20-48-45-CST-2019" class="headerlink" title="Thu Oct 24 20:48:45 CST 2019"></a>Thu Oct 24 20:48:45 CST 2019</h1><h2 id="类SimpleDateFormat-中-kk表示什么？"><a href="#类SimpleDateFormat-中-kk表示什么？" class="headerlink" title="类SimpleDateFormat,中 kk表示什么？"></a>类SimpleDateFormat,中 kk表示什么？</h2><ol>
<li>一天中的小时数 01~24</li>
</ol>
<h1 id="Mon-Oct-28-15-53-43-CST-2019"><a href="#Mon-Oct-28-15-53-43-CST-2019" class="headerlink" title="Mon Oct 28 15:53:43 CST 2019"></a>Mon Oct 28 15:53:43 CST 2019</h1><h2 id="java项目运行时，报错内存溢出、PermGen-space"><a href="#java项目运行时，报错内存溢出、PermGen-space" class="headerlink" title="java项目运行时，报错内存溢出、PermGen space?"></a>java项目运行时，报错<code>内存溢出</code>、<code>PermGen space</code>?</h2><ol>
<li><code>-Xms256m -Xmx768m -XX:MaxNewSize=256m -XX:MaxPermSize=512m</code></li>
</ol>
<h2 id="tomcat启动的项目乱码？"><a href="#tomcat启动的项目乱码？" class="headerlink" title="tomcat启动的项目乱码？"></a>tomcat启动的项目乱码？</h2><ol>
<li>修改conf文件夹下的server.xml文件，在connector标签添加元素<code>URLEncoding=&quot;UTF-8&quot;</code></li>
<li>在Tomcat的VM options中添加<code>-Dfile.encoding=UTF-8</code></li>
</ol>
<h1 id="Tue-Oct-29-09-51-25-CST-2019"><a href="#Tue-Oct-29-09-51-25-CST-2019" class="headerlink" title="Tue Oct 29 09:51:25 CST 2019"></a>Tue Oct 29 09:51:25 CST 2019</h1><h2 id="unsupported-major-minor-version-51-0"><a href="#unsupported-major-minor-version-51-0" class="headerlink" title="unsupported major.minor version 51.0?"></a><code>unsupported major.minor version 51.0</code>?</h2><ul>
<li>项目使用的jdk版本和编译器的jdk版本不一致</li>
</ul>
<h2 id="Users-wd-Documents-java-tool-jdk-jdk1-7-0-80-bin-java-cannot-execute-binary-file"><a href="#Users-wd-Documents-java-tool-jdk-jdk1-7-0-80-bin-java-cannot-execute-binary-file" class="headerlink" title="/Users/wd/Documents/java-tool/jdk/jdk1.7.0_80/bin/java: cannot execute binary file?"></a><code>/Users/wd/Documents/java-tool/jdk/jdk1.7.0_80/bin/java: cannot execute binary file</code>?</h2><ul>
<li>本地机器的位数和下载的jdk版本的位数不一致导致的(可能一个64位，一个是32位的)</li>
</ul>
<h1 id="Wed-Oct-30-11-37-46-CST-2019"><a href="#Wed-Oct-30-11-37-46-CST-2019" class="headerlink" title="Wed Oct 30 11:37:46 CST 2019"></a>Wed Oct 30 11:37:46 CST 2019</h1><h2 id="流程开源软件activity，其中的表act-id-membership中的值是如何赋值的？"><a href="#流程开源软件activity，其中的表act-id-membership中的值是如何赋值的？" class="headerlink" title="流程开源软件activity，其中的表act_id_membership中的值是如何赋值的？"></a>流程开源软件activity，其中的表act_id_membership中的值是如何赋值的？</h2><h2 id="API-org-apache-httpclient的基本使用？"><a href="#API-org-apache-httpclient的基本使用？" class="headerlink" title="API:org.apache.httpclient的基本使用？"></a>API:<code>org.apache.httpclient</code>的基本使用？</h2><h1 id="Fri-Nov-1-11-25-16-CST-2019"><a href="#Fri-Nov-1-11-25-16-CST-2019" class="headerlink" title="Fri Nov  1 11:25:16 CST 2019"></a>Fri Nov  1 11:25:16 CST 2019</h1><h2 id="事务注解-Transactional的使用？rollbakFor指向的是什么类？"><a href="#事务注解-Transactional的使用？rollbakFor指向的是什么类？" class="headerlink" title="事务注解@Transactional的使用？rollbakFor指向的是什么类？"></a>事务注解<code>@Transactional</code>的使用？<code>rollbakFor</code>指向的是什么类？</h2><ul>
<li><code>rollbakFor</code>一般指向异常类，即只要发生异常，就回滚事务。</li>
</ul>
<h2 id="实现多个excel文件合并成一个excel文件？"><a href="#实现多个excel文件合并成一个excel文件？" class="headerlink" title="实现多个excel文件合并成一个excel文件？"></a>实现多个excel文件合并成一个excel文件？</h2><h1 id="Sun-Nov-3-13-35-58-CST-2019"><a href="#Sun-Nov-3-13-35-58-CST-2019" class="headerlink" title="Sun Nov  3 13:35:58 CST 2019"></a>Sun Nov  3 13:35:58 CST 2019</h1><h2 id="编程的思想，不是拿到一个需求，就直接去写代码，我们还是需要先去分析一下，怎么去分析呢？"><a href="#编程的思想，不是拿到一个需求，就直接去写代码，我们还是需要先去分析一下，怎么去分析呢？" class="headerlink" title="编程的思想，不是拿到一个需求，就直接去写代码，我们还是需要先去分析一下，怎么去分析呢？"></a>编程的思想，不是拿到一个需求，就直接去写代码，我们还是需要先去分析一下，怎么去分析呢？</h2><ul>
<li>发现问题、分析问题、解决问题（X）</li>
<li>分析这个需求，需要哪些数据结构，可以构建成哪些类，适用于什么样的算法、什么样的设计思想等等</li>
</ul>
<h1 id="Mon-Nov-4-16-54-56-CST-2019"><a href="#Mon-Nov-4-16-54-56-CST-2019" class="headerlink" title="Mon Nov  4 16:54:56 CST 2019"></a>Mon Nov  4 16:54:56 CST 2019</h1><h2 id="打开excel文件报错：Invalid-header-signature-read-0x3164754201000000-expected-0xE11AB1A1E011CFD0"><a href="#打开excel文件报错：Invalid-header-signature-read-0x3164754201000000-expected-0xE11AB1A1E011CFD0" class="headerlink" title="打开excel文件报错：Invalid header signature; read 0x3164754201000000, expected 0xE11AB1A1E011CFD0"></a>打开excel文件报错：<code>Invalid header signature; read 0x3164754201000000, expected 0xE11AB1A1E011CFD0</code></h2><ul>
<li>产生原因：打开的excel文件不是标准的excel文件，用excel手动打开后，另存下。再次使用POI读取的话，就不会报错了。</li>
</ul>
<h2 id="报错Error-parsing-HTTP-request-header"><a href="#报错Error-parsing-HTTP-request-header" class="headerlink" title="报错Error parsing HTTP request header"></a>报错<code>Error parsing HTTP request header</code></h2><ul>
<li>可修改tomcat的配置文件，在connector标签中添加属性,<code>maxHttpHeaderSize=&quot;81920&quot;</code></li>
</ul>
<h1 id="Tue-Nov-5-14-37-01-CST-2019"><a href="#Tue-Nov-5-14-37-01-CST-2019" class="headerlink" title="Tue Nov  5 14:37:01 CST 2019"></a>Tue Nov  5 14:37:01 CST 2019</h1><h3 id="java-httl模板引擎基本使用"><a href="#java-httl模板引擎基本使用" class="headerlink" title="java httl模板引擎基本使用"></a>java httl模板引擎基本使用</h3><ul>
<li>六个基本指令</li>
</ul>
<ol>
<li><h1 id="macro"><a href="#macro" class="headerlink" title="macro"></a>macro</h1></li>
<li><h1 id="if"><a href="#if" class="headerlink" title="if"></a>if</h1></li>
<li><h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1></li>
<li><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1></li>
<li></li>
<li></li>
</ol>
<ul>
<li>httl文件修改了，需要重新启动项目吗？</li>
</ul>
<h1 id="Sun-Nov-10-11-45-41-CST-2019"><a href="#Sun-Nov-10-11-45-41-CST-2019" class="headerlink" title="Sun Nov 10 11:45:41 CST 2019"></a>Sun Nov 10 11:45:41 CST 2019</h1><h2 id="JSONObject实现了Map接口，本身就是一个map"><a href="#JSONObject实现了Map接口，本身就是一个map" class="headerlink" title="JSONObject实现了Map接口，本身就是一个map."></a>JSONObject实现了Map接口，本身就是一个map.</h2><h1 id="Tue-Nov-12-16-39-24-CST-2019"><a href="#Tue-Nov-12-16-39-24-CST-2019" class="headerlink" title="Tue Nov 12 16:39:24 CST 2019"></a>Tue Nov 12 16:39:24 CST 2019</h1><h2 id="activity流程引擎的基础"><a href="#activity流程引擎的基础" class="headerlink" title="activity流程引擎的基础"></a>activity流程引擎的基础</h2><ul>
<li><a href="https://blog.csdn.net/hj7jay/article/details/51302829">各张表的说明</a></li>
</ul>
<h1 id="Thu-Nov-14-14-45-45-CST-2019"><a href="#Thu-Nov-14-14-45-45-CST-2019" class="headerlink" title="Thu Nov 14 14:45:45 CST 2019"></a>Thu Nov 14 14:45:45 CST 2019</h1><h2 id="注解-Transactional在sql语句插入出错时，没有回滚？"><a href="#注解-Transactional在sql语句插入出错时，没有回滚？" class="headerlink" title="注解@Transactional在sql语句插入出错时，没有回滚？"></a>注解@Transactional在sql语句插入出错时，没有回滚？</h2><h1 id="Sat-Nov-16-07-57-33-CST-2019"><a href="#Sat-Nov-16-07-57-33-CST-2019" class="headerlink" title="Sat Nov 16 07:57:33 CST 2019"></a>Sat Nov 16 07:57:33 CST 2019</h1><h2 id="运行时，报错NoClassDefFoundError-但是这个类的class文件在jar包中明明是存在的？"><a href="#运行时，报错NoClassDefFoundError-但是这个类的class文件在jar包中明明是存在的？" class="headerlink" title="运行时，报错NoClassDefFoundError,但是这个类的class文件在jar包中明明是存在的？"></a>运行时，报错<code>NoClassDefFoundError</code>,但是这个类的class文件在jar包中明明是存在的？</h2><ul>
<li>产生原因：java虚拟机在编译的时候可以找到这个类，但是在运行的时候找不到合适的类导致的错误。</li>
<li><blockquote>
<p>Java编译期：将java源文件编程字节码文件的过程(.java —&gt; .class)<br>Java运行期：程序运行的过程</p>
</blockquote>
</li>
</ul>
<h1 id="Tue-Nov-19-14-45-02-CST-2019"><a href="#Tue-Nov-19-14-45-02-CST-2019" class="headerlink" title="Tue Nov 19 14:45:02 CST 2019"></a>Tue Nov 19 14:45:02 CST 2019</h1><h2 id="mybatis使用selectKey"><a href="#mybatis使用selectKey" class="headerlink" title="mybatis使用selectKey"></a>mybatis使用selectKey</h2><p>可解决oracle数据库中没有自增主键的情况<br><a href="./resource/java/mybatis-selectKey.png">selectKey</a></p>
<h1 id="Tue-Nov-26-17-32-20-CST-2019"><a href="#Tue-Nov-26-17-32-20-CST-2019" class="headerlink" title="Tue Nov 26 17:32:20 CST 2019"></a>Tue Nov 26 17:32:20 CST 2019</h1><h2 id="主线程等待子线程执行完毕"><a href="#主线程等待子线程执行完毕" class="headerlink" title="主线程等待子线程执行完毕"></a>主线程等待子线程执行完毕</h2><blockquote>
<p><a href="https://blog.csdn.net/xiao__gui/article/details/9213413">Java主线程等待子线程、线程池</a></p>
<ul>
<li>主线程等待一个子线程 <code>join()</code></li>
<li>主线程等待多个子线程 <code>先start(),后join()</code></li>
<li>主线程等待多个子线程 <code>CountDownLatch实现</code></li>
<li>主线程等待多个子线程(线程池) <code>while (!executor.awaitTermination(10, TimeUnit.SECONDS)</code> <code>while(!executor.isTerminated())</code></li>
</ul>
</blockquote>
<h1 id="Wed-Nov-27-18-22-53-CST-2019"><a href="#Wed-Nov-27-18-22-53-CST-2019" class="headerlink" title="Wed Nov 27 18:22:53 CST 2019"></a>Wed Nov 27 18:22:53 CST 2019</h1><h2 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h2><ul>
<li><util:properties>标签的作用？</util:properties></li>
<li><code>&lt;bean&gt;</code>标签下的<code>init-method</code>属性和注解<code>@PostConstruct</code>有区别吗？</li>
<li>若没区别，为什么使用注解<code>@PostConstruct</code>初始化方法，创建一个<code>ServerSocket</code>服务端，会报端口被占用的错误？</li>
</ul>
<h1 id="Thu-Dec-5-18-23-44-CST-2019"><a href="#Thu-Dec-5-18-23-44-CST-2019" class="headerlink" title="Thu Dec  5 18:23:44 CST 2019"></a>Thu Dec  5 18:23:44 CST 2019</h1><h2 id="springboot注解"><a href="#springboot注解" class="headerlink" title="springboot注解"></a>springboot注解</h2><ol>
<li><code>@Configuration</code><blockquote>
<p>@Configuration注解可以达到在Spring中使用xml配置文件的作用 </p>
</blockquote>
</li>
<li><code>@Bean</code><blockquote>
<p>‘@Bean就等同于xml配置文件中的<bean>‘, 只能修改方法，方法的返回值表示POJO，@Bean的value值为bean的名称，若没有，则方法的名称默认为bean的名称.</bean></p>
</blockquote>
</li>
</ol>
<h2 id="springboot集成druid"><a href="#springboot集成druid" class="headerlink" title="springboot集成druid"></a>springboot集成druid</h2><blockquote>
<p>ProcessEngineConfiguration:流程引擎配置。<br>ProcessEngine:流程引擎<br>核心七大接口<br>RepositoryService：提供一系列管理流程部署和流程定义的API。<br>RuntimeService：在流程运行时对流程实例进行管理与控制。<br>TaskService：对流程任务进行管理，例如任务提醒、任务完成和创建任务等。<br>IdentityService：提供对流程角色数据进行管理的API，这些角色数据包括用户组、用户及它们之间的关系。<br>ManagementService：提供对流程引擎进行管理和维护的服务，提供对activiti数据库的直接访问【一般不用】<br>HistoryService：对流程的历史数据进行操作，包括查询、删除这些历史数据。FormService：表单服务</p>
<h1 id="Mon-Dec-9-09-19-11-CST-2019"><a href="#Mon-Dec-9-09-19-11-CST-2019" class="headerlink" title="Mon Dec  9 09:19:11 CST 2019"></a>Mon Dec  9 09:19:11 CST 2019</h1><h2 id="JMX-Java-Management-Extensions"><a href="#JMX-Java-Management-Extensions" class="headerlink" title="JMX(Java Management Extensions)"></a>JMX(Java Management Extensions)</h2><p>一个为应用程序植入管理功能的框架</p>
<p>对于一些参数的修改，网上有一段描述还是比较形象的：<br>1、程序初哥一般是写死在程序中，到要改变的时候就去修改代码，然后重新编译发布。<br>2、程序熟手则配置在文件中（JAVA一般都是properties文件），到要改变的时候只要修改配置文件，但还是必须重启系统，以便读取配置文件里最新的值。<br>3、程序好手则会写一段代码，把配置值缓存起来，系统在获取的时候，先看看配置文件有没有改动，如有改动则重新从配置里读取，否则从缓存里读取。<br>4、程序高手则懂得物为我所用，用JMX把需要配置的属性集中在一个类中，然后写一个MBean，再进行相关配置。另外JMX还提供了一个工具页，以方便我们对参数值进行修改。</p>
</blockquote>
<h2 id="AOP-Aspect-Oriented-Programming-面向切面编程"><a href="#AOP-Aspect-Oriented-Programming-面向切面编程" class="headerlink" title="AOP(Aspect-Oriented Programming) 面向切面编程"></a>AOP(Aspect-Oriented Programming) 面向切面编程</h2><ul>
<li>@Aspect, @Pointcut, @Around</li>
<li><code>ProceedingJoinPoint</code>执行<code>proceed()</code> 表示切面包围的方法执行了。</li>
</ul>
<h1 id="Thu-Dec-12-20-53-08-CST-2019"><a href="#Thu-Dec-12-20-53-08-CST-2019" class="headerlink" title="Thu Dec 12 20:53:08 CST 2019"></a>Thu Dec 12 20:53:08 CST 2019</h1><h2 id="java使用spring框架，加载yaml文件时，一直加载以前的版本，不进行更新？"><a href="#java使用spring框架，加载yaml文件时，一直加载以前的版本，不进行更新？" class="headerlink" title="java使用spring框架，加载yaml文件时，一直加载以前的版本，不进行更新？"></a>java使用spring框架，加载yaml文件时，一直加载以前的版本，不进行更新？</h2><h1 id="Fri-Dec-13-09-18-14-CST-2019"><a href="#Fri-Dec-13-09-18-14-CST-2019" class="headerlink" title="Fri Dec 13 09:18:14 CST 2019"></a>Fri Dec 13 09:18:14 CST 2019</h1><h2 id="tomcat启动异常：-Invalid-byte-tag-in-constant-pool-18？？"><a href="#tomcat启动异常：-Invalid-byte-tag-in-constant-pool-18？？" class="headerlink" title="tomcat启动异常： Invalid byte tag in constant pool: 18？？"></a>tomcat启动异常： Invalid byte tag in constant pool: 18？？</h2><ul>
<li>jdk版本过高。</li>
</ul>
<h2 id="tomcat启动报错-PermGen-space"><a href="#tomcat启动报错-PermGen-space" class="headerlink" title="tomcat启动报错: PermGen space?"></a>tomcat启动报错: PermGen space?</h2><ul>
<li>在bin文件夹下，新建文件setenv.sh,插入语句<code>JAVA_OPTS=&quot;$JAVA_OPTS -server -XX:PermSize=128M -XX:MaxPermSize=512m&quot;</code></li>
</ul>
<h1 id="Tue-Dec-17-17-44-13-CST-2019"><a href="#Tue-Dec-17-17-44-13-CST-2019" class="headerlink" title="Tue Dec 17 17:44:13 CST 2019"></a>Tue Dec 17 17:44:13 CST 2019</h1><h2 id="字符串转成字符数组或者字符串数组"><a href="#字符串转成字符数组或者字符串数组" class="headerlink" title="字符串转成字符数组或者字符串数组?"></a>字符串转成字符数组或者字符串数组?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">char</span>[] charArr = str.toCharArray();</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">String[] strArr = str.split(<span class="string">&quot;separator&quot;</span>);</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">String[] strArr = StringUtils.split(str, <span class="string">&quot;separator&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Thu-Dec-19-14-37-55-CST-2019"><a href="#Thu-Dec-19-14-37-55-CST-2019" class="headerlink" title="Thu Dec 19 14:37:55 CST 2019"></a>Thu Dec 19 14:37:55 CST 2019</h1><h1 id="Fri-Dec-20-09-22-45-CST-2019"><a href="#Fri-Dec-20-09-22-45-CST-2019" class="headerlink" title="Fri Dec 20 09:22:45 CST 2019"></a>Fri Dec 20 09:22:45 CST 2019</h1><h2 id="注解-Transactional添加readonly-true的作用"><a href="#注解-Transactional添加readonly-true的作用" class="headerlink" title="注解@Transactional添加readonly=true的作用"></a>注解<code>@Transactional</code>添加<code>readonly=true</code>的作用</h2><ul>
<li>在该注解的类下，执行数据库的写操作会抛出异常。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>将相同或者相似类型的代码的异常处理成自定义的一个异常;</li>
</ul>
<h1 id="Mon-Dec-23-09-58-01-CST-2019"><a href="#Mon-Dec-23-09-58-01-CST-2019" class="headerlink" title="Mon Dec 23 09:58:01 CST 2019"></a>Mon Dec 23 09:58:01 CST 2019</h1><h2 id="字符串组合排列"><a href="#字符串组合排列" class="headerlink" title="字符串组合排列"></a>字符串组合排列</h2><ul>
<li>方法迭代<ol>
<li>若迭代的次数太多，如何提高效率?</li>
</ol>
</li>
</ul>
<h2 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h2><ul>
<li>对<code>ArrayList,Set</code>等进行遍历操作时，不能执行删除操作。</li>
</ul>
<h1 id="Tue-Dec-24-09-20-26-CST-2019"><a href="#Tue-Dec-24-09-20-26-CST-2019" class="headerlink" title="Tue Dec 24 09:20:26 CST 2019"></a>Tue Dec 24 09:20:26 CST 2019</h1><h2 id="Map遍历的几种方法"><a href="#Map遍历的几种方法" class="headerlink" title="Map遍历的几种方法"></a>Map遍历的几种方法</h2><ol>
<li>for(Map.Entry<String, object> entry: map.entrySet())</String,></li>
<li>for(Object key: map.keySet())</li>
<li>for(Object value: map.values())</li>
<li>使用iterator<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> </span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line"> </span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法递归和数学归纳法"><a href="#方法递归和数学归纳法" class="headerlink" title="方法递归和数学归纳法?"></a>方法递归和数学归纳法?</h2></li>
</ol>
<h2 id="堆、栈、方法区"><a href="#堆、栈、方法区" class="headerlink" title="堆、栈、方法区"></a>堆、栈、方法区</h2><ul>
<li>堆：基本类型的值和引用类型对象的引用</li>
<li>栈：引用类型对象</li>
<li>方法区：class文件和成员方法</li>
</ul>
<h1 id="Thu-Dec-26-15-51-41-CST-2019"><a href="#Thu-Dec-26-15-51-41-CST-2019" class="headerlink" title="Thu Dec 26 15:51:41 CST 2019"></a>Thu Dec 26 15:51:41 CST 2019</h1><h2 id="算法-回溯算法"><a href="#算法-回溯算法" class="headerlink" title="算法: 回溯算法"></a>算法: 回溯算法</h2><p>简介 </p>
<blockquote>
<p>回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。用回溯算法解决问题的一般步骤为：<br>1)、定义一个解空间，它包含问题的解。<br>2)、利用适于搜索的方法组织解空间。<br>3)、利用深度优先法搜索解空间。<br>4)、利用限界函数避免移动到不可能产生解的子空间。<br>问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性。<br>经典案例</p>
<ul>
<li>N皇后问题</li>
</ul>
</blockquote>
<h1 id="Sat-Dec-28-10-26-28-CST-2019"><a href="#Sat-Dec-28-10-26-28-CST-2019" class="headerlink" title="Sat Dec 28 10:26:28 CST 2019"></a>Sat Dec 28 10:26:28 CST 2019</h1><h2 id="java中的各种算法？"><a href="#java中的各种算法？" class="headerlink" title="java中的各种算法？"></a>java中的各种算法？</h2><h1 id="2019年12月30日-星期一-14时42分16秒-CST"><a href="#2019年12月30日-星期一-14时42分16秒-CST" class="headerlink" title="2019年12月30日 星期一 14时42分16秒 CST"></a>2019年12月30日 星期一 14时42分16秒 CST</h1><h2 id="前台上传多个文件到后台？"><a href="#前台上传多个文件到后台？" class="headerlink" title="前台上传多个文件到后台？"></a>前台上传多个文件到后台？</h2><h1 id="2020年-1月-2日-星期四-13时32分29秒-CST"><a href="#2020年-1月-2日-星期四-13时32分29秒-CST" class="headerlink" title="2020年 1月 2日 星期四 13时32分29秒 CST"></a>2020年 1月 2日 星期四 13时32分29秒 CST</h1><h2 id><a href="#" class="headerlink" title=" "></a> </h2><h1 id="2020年-1月-3日-星期五-08时44分41秒-CST"><a href="#2020年-1月-3日-星期五-08时44分41秒-CST" class="headerlink" title="2020年 1月 3日 星期五 08时44分41秒 CST"></a>2020年 1月 3日 星期五 08时44分41秒 CST</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>红黑树算法<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2>集合框架<br>  Collection<pre><code>  Set
  List
      ArrayList
      LinkedList
  Queue
</code></pre>  Map<pre><code>  HashMap
  TreeMap
  HashTable
</code></pre></li>
</ul>
<p>常用的数据结构<br>Array 数组<br>Stack 栈，也称堆栈或堆叠，按照<strong>先进后出</strong>的原则存储数据.<br>Queue 队列，按照<strong>先进先出</strong>的原则存储数据.<br>    单向队列<br>    双向队列<br>LinkedList 链表，由节点组成的线性集合<br>    单向链表<br>    双向链表<br>    循环链表<br>BinaryTree 二叉树，由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树组成，二叉树即是每个节点最多包含左子节点和右子节点的树形数据结构。<br>    满二叉树：即每个节点仅包含0或2个节点。<br>    完美二叉树(Perfect Binary Tree): 二叉树中的每个叶节点都拥有二个子节点，且具有相同的高度。<br>    完全二叉树：除最后一层外，每一层上节点数均达到最大值；在最后一层上只缺少右边的若干节点。<br>    红黑树：<br>Heap 堆，也称优先队列(队列+排序规则)<br>    最大堆：父节点的键值永远大于或等于子节点的值，且最大值位于根节点。<br>    最小堆：父节点的键值永远小于或等于子节点的值，且最小值位于根节点。<br>Hashing<br>    HashMap<br>Graph 图，一种数据元素为多对多关系的数据结构。<br>    无向图(Undirected Graph):无向图具有对称的邻接矩阵，因此如果存在某条从节点u到节点v的边，则一定存在一条从节点v到节点u的边。<br>    有向图(Directed Graph):有向图的邻接矩阵不是对称的，即存在某条从节点u到节点v的边，不一定意味着存在某条从节点v到节点u的边。</p>
<p>常用的算法<br>排序<br>    快速排序<br>    归并排序<br>    桶排序<br>    基数排序<br>    图算法<br>        深度优先搜索<br>        广度优先搜索<br>    拓扑排序<br>    Dijkstra算法<br>    Bellman-Ford算法<br>    Floyd-Warshall算法<br>    Prim算法<br>    Kruskal算法<br>    位运算<br>java基本算法<br>    二分查找算法<br>    递归算法<br>    八大排序算法<br>        一、直接插入排序（Insertion Sort）<br>        二、希尔排序（Shell Sort）<br>        三、选择排序（Selection Sort）<br>        四、堆排序（Heap Sort）<br>        五、冒泡排序（Bubble Sort）<br>        六、快速排序（Quick Sort）<br>        七、归并排序（Merging Sort）<br>        八、基数排序（Radix Sort)</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符</li>
<li>布尔运算符</li>
<li>关系运算符</li>
<li>三元运算符</li>
<li>按位运算符</li>
</ul>
<h2 id="谚语"><a href="#谚语" class="headerlink" title="谚语"></a>谚语</h2><ol>
<li>数据结构 + 算法 = 程序</li>
<li>程序的运行效率—时间复杂度</li>
<li>程序的存储效率—空间复杂度<h2 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h2></li>
</ol>
<h1 id="2020年-1月-6日-星期一-08时44分48秒-CST"><a href="#2020年-1月-6日-星期一-08时44分48秒-CST" class="headerlink" title="2020年 1月 6日 星期一 08时44分48秒 CST"></a>2020年 1月 6日 星期一 08时44分48秒 CST</h1><h2 id="java日志框架"><a href="#java日志框架" class="headerlink" title="java日志框架"></a>java日志框架</h2><p>org.slf4j:slf4j-api:version 这个jar包不提供日志的具体实现，只是规范一个接口。<br>要打印出日志信息，需要引入具体的日志实现包，如logback、log4j、slf4j-simple等。</p>
<h1 id="2020年-1月-7日-星期二-09时42分17秒-CST"><a href="#2020年-1月-7日-星期二-09时42分17秒-CST" class="headerlink" title="2020年 1月 7日 星期二 09时42分17秒 CST"></a>2020年 1月 7日 星期二 09时42分17秒 CST</h1><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="2020-03-22-15-25-14-星期日"><a href="#2020-03-22-15-25-14-星期日" class="headerlink" title="2020-03-22 15:25:14 星期日"></a>2020-03-22 15:25:14 星期日</h2><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配输入字符开始的位置</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符结尾的位置</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格、标点间的位置</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配</td>
</tr>
</tbody>
</table>
</div>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>用圆括号<code>()</code>将所有选择项括起来，相邻的选择项之间用<code>|</code>分隔符来分隔。如<code>h(e|is)</code>匹配<code>he,his</code>.</p>
<p>用圆括号的另外一个作用，使相关的匹配会被缓存，此时可以用<code>:?</code>放在第一个选项之前来消除这种缓存。</p>
<p>其中<code>?:</code>是非捕获元之一，还有另外两个捕获元<code>?=</code>和<code>?!</code>,前者为正向预查，后者为负向预查。</p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>以下是从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(),(?:),(?=),[ ]</td>
<td>圆括号与方括号</td>
</tr>
<tr>
<td>*,+,?,{n},{n,},{n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^,$,\任何元字符、任何字符</td>
<td>定位符和序列</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>替换，</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-javaScript</title>
    <url>/2020/08/16/notebook-javaScript/</url>
    <content><![CDATA[<h2 id="在前端界面获取file元素的本地真实路径？"><a href="#在前端界面获取file元素的本地真实路径？" class="headerlink" title="在前端界面获取file元素的本地真实路径？"></a>在前端界面获取file元素的本地真实路径？</h2><ol>
<li>背景：浏览器端出于对用户的安全考虑，是不会显示上传文件的真实路径的。</li>
<li>解决方案：</li>
</ol>
<h1 id="Wed-Oct-30-09-30-15-CST-2019"><a href="#Wed-Oct-30-09-30-15-CST-2019" class="headerlink" title="Wed Oct 30 09:30:15 CST 2019"></a>Wed Oct 30 09:30:15 CST 2019</h1><h2 id="数组的sort-是按照什么进行排序的？"><a href="#数组的sort-是按照什么进行排序的？" class="headerlink" title="数组的sort(),是按照什么进行排序的？"></a>数组的sort(),是按照什么进行排序的？</h2><h1 id="Fri-Nov-8-17-07-49-CST-2019"><a href="#Fri-Nov-8-17-07-49-CST-2019" class="headerlink" title="Fri Nov  8 17:07:49 CST 2019"></a>Fri Nov  8 17:07:49 CST 2019</h1><h2 id="FormData一般用来传递文件流的，它可以传递数组或者json格式的数据吗？"><a href="#FormData一般用来传递文件流的，它可以传递数组或者json格式的数据吗？" class="headerlink" title="FormData一般用来传递文件流的，它可以传递数组或者json格式的数据吗？"></a>FormData一般用来传递文件流的，它可以传递数组或者json格式的数据吗？</h2><h1 id="Tue-Nov-5-17-31-13-CST-2019"><a href="#Tue-Nov-5-17-31-13-CST-2019" class="headerlink" title="Tue Nov  5 17:31:13 CST 2019"></a>Tue Nov  5 17:31:13 CST 2019</h1><h2 id="js中函数名称一样，参数个数不一样的话，算是不一样的函数吗？"><a href="#js中函数名称一样，参数个数不一样的话，算是不一样的函数吗？" class="headerlink" title="js中函数名称一样，参数个数不一样的话，算是不一样的函数吗？"></a>js中函数名称一样，参数个数不一样的话，算是不一样的函数吗？</h2><h2 id="在html文件中，两个js文件中，存在同名的函数，若先加载a-js，后加载b-js-那么哪个js文件中的函数起作用？"><a href="#在html文件中，两个js文件中，存在同名的函数，若先加载a-js，后加载b-js-那么哪个js文件中的函数起作用？" class="headerlink" title="在html文件中，两个js文件中，存在同名的函数，若先加载a.js，后加载b.js,那么哪个js文件中的函数起作用？"></a>在html文件中，两个js文件中，存在同名的函数，若先加载a.js，后加载b.js,那么哪个js文件中的函数起作用？</h2><h1 id="Thu-Nov-21-15-40-34-CST-2019"><a href="#Thu-Nov-21-15-40-34-CST-2019" class="headerlink" title="Thu Nov 21 15:40:34 CST 2019"></a>Thu Nov 21 15:40:34 CST 2019</h1><h2 id="jqgrid设置冻结列"><a href="#jqgrid设置冻结列" class="headerlink" title="jqgrid设置冻结列"></a>jqgrid设置冻结列</h2><ol>
<li>colModel中的列，添加<code>frozen属性为true</code></li>
<li>jqGrid中添加属性<code>shrinkToFit为false和autoScroll为true</code></li>
<li>jqgrid设置方法，<code>$jqGrid.jqGrid(&quot;setFrozenColumns&quot;)</code></li>
</ol>
<h3 id="2020-03-25-18-04-57-星期三"><a href="#2020-03-25-18-04-57-星期三" class="headerlink" title="2020-03-25 18:04:57 星期三"></a>2020-03-25 18:04:57 星期三</h3><h5 id="jQuery中trigger的使用"><a href="#jQuery中trigger的使用" class="headerlink" title="jQuery中trigger的使用"></a>jQuery中trigger的使用</h5><ul>
<li>trigger不可以直接触发 <strong>input(file)</strong> 、 <strong>select</strong> 的原生事件；</li>
<li>可以触发给元素添加的事件；</li>
<li>但是如果trigger外面包了一层 <strong>on（”click”）</strong> ,则可以触发  <strong>input(file)</strong> 、 <strong>select</strong> 的原生事件。</li>
<li>trugger触发某个元素的某个事件，首先得让那个元素把那个事件添加的函数提前执行；比如可以使用trigger做进入页面自动定位的功能，但是在触发trigger之前，必须确保触发元素的事件已经绑定上。</li>
<li><strong>fastclick.js</strong>会影响trigger的使用，出现第一次点击没有出现响应，第二次才起效果。</li>
</ul>
<h3 id="2020-03-26-13-37-45-星期四"><a href="#2020-03-26-13-37-45-星期四" class="headerlink" title="2020-03-26 13:37:45 星期四"></a>2020-03-26 13:37:45 星期四</h3><h5 id="jQuery-extend-target-object1-objectN"><a href="#jQuery-extend-target-object1-objectN" class="headerlink" title="jQuery.extend(target[, object1][, objectN])"></a><code>jQuery.extend(target[, object1][, objectN])</code></h5><p>描述：将两个或更多对象的内容合并到第一个对象。</p>
<h5 id="jQuery-css-propertyName-propertyValue"><a href="#jQuery-css-propertyName-propertyValue" class="headerlink" title="jQuery.css(propertyName[, propertyValue])"></a><code>jQuery.css(propertyName[, propertyValue])</code></h5><p>描述：获取匹配元素集合中的第一个元素的样式属性的值  或  设置每个匹配元素的一个CSS属性。</p>
<h5 id="jQuery-css-quot-propertyname-quot-quot-value-quot-quot-propertyname-quot-quot-value-quot"><a href="#jQuery-css-quot-propertyname-quot-quot-value-quot-quot-propertyname-quot-quot-value-quot" class="headerlink" title="jQuery.css({&quot;propertyname&quot;:&quot;value&quot;,&quot;propertyname&quot;:&quot;value&quot;,...})"></a><code>jQuery.css(&#123;&quot;propertyname&quot;:&quot;value&quot;,&quot;propertyname&quot;:&quot;value&quot;,...&#125;)</code></h5><p>描述：设置一个或多个css属性，使用json</p>
<h5 id="jQuery-addClass-className"><a href="#jQuery-addClass-className" class="headerlink" title="jQuery.addClass(className)"></a><code>jQuery.addClass(className)</code></h5><p>描述：为每个匹配的元素添加指定的样式类名</p>
<ul>
<li>对所有匹配的元素可以一次添加多个用空格隔开的样式类名 </li>
<li><code>$(&quot;p&quot;).addClass(&quot;myClass yourClass&quot;);</code></li>
</ul>
<h5 id="jQuery-attr"><a href="#jQuery-attr" class="headerlink" title="jQuery.attr()"></a><code>jQuery.attr()</code></h5><p>描述：设置元素的属性，使用方式类似于<code>.css()</code></p>
<h5 id="jQuery-each-function-index-Element"><a href="#jQuery-each-function-index-Element" class="headerlink" title="jQuery.each(function(index, Element))"></a><code>jQuery.each(function(index, Element))</code></h5><p>描述：遍历一个jQuery对象，为每个匹配元素执行一个函数。</p>
<h2 id="2020-03-27-14-55-29-星期五"><a href="#2020-03-27-14-55-29-星期五" class="headerlink" title="2020-03-27 14:55:29 星期五"></a>2020-03-27 14:55:29 星期五</h2><h4 id="jquery获取焦点和失去焦点事件"><a href="#jquery获取焦点和失去焦点事件" class="headerlink" title="jquery获取焦点和失去焦点事件"></a>jquery获取焦点和失去焦点事件</h4><h6 id="获得焦点事件-focus"><a href="#获得焦点事件-focus" class="headerlink" title="获得焦点事件 focus()"></a>获得焦点事件 <code>focus()</code></h6><p>当通过鼠标点击选中元素或通过tab键定位到元素时，该元素就会获得焦点。</p>
<ol>
<li><p>语法： <code>$(selector).focus()</code></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mochu&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#mochu&#x27;</span>).focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="built_in">this</span>).css(<span class="string">&#x27;border-color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="失去焦点事件-blur"><a href="#失去焦点事件-blur" class="headerlink" title="失去焦点事件 blur()"></a>失去焦点事件 <code>blur()</code></h6><p>当元素失去焦点时，发生blur事件。</p>
<ol>
<li><p>语法: <code>$(selector).blur()</code></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mochu&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#mochu&#x27;</span>).focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="built_in">this</span>).css(<span class="string">&#x27;border-color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2020-04-02-14-26-07-星期四"><a href="#2020-04-02-14-26-07-星期四" class="headerlink" title="2020-04-02 14:26:07 星期四"></a>2020-04-02 14:26:07 星期四</h3><h4 id="select2使下拉选带有搜索功能"><a href="#select2使下拉选带有搜索功能" class="headerlink" title="select2使下拉选带有搜索功能"></a>select2使下拉选带有搜索功能</h4><h4 id="json对象按照key值进行排序"><a href="#json对象按照key值进行排序" class="headerlink" title="json对象按照key值进行排序"></a>json对象按照key值进行排序</h4><ul>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-jqGrid</title>
    <url>/2020/08/16/notebook-jqGrid/</url>
    <content><![CDATA[<h1 id="Tue-Dec-24-16-38-48-CST-2019"><a href="#Tue-Dec-24-16-38-48-CST-2019" class="headerlink" title="Tue Dec 24 16:38:48 CST 2019"></a>Tue Dec 24 16:38:48 CST 2019</h1><h2 id="表格加载完成后，可对某些字段执行隐藏和可见操作"><a href="#表格加载完成后，可对某些字段执行隐藏和可见操作" class="headerlink" title="表格加载完成后，可对某些字段执行隐藏和可见操作?"></a>表格加载完成后，可对某些字段执行隐藏和可见操作?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在实际生产中，经常会遇到这样的情况，当jqgrid加载完成对应的数据列之后，点击某操作需要减少或增加一列。针对这种情况如何处理呢？</span><br><span class="line"></span><br><span class="line">这里提供一种方法，就是基于jqgrid提供的hideCol方法。具体使用方式：</span><br><span class="line"></span><br><span class="line">$(&quot;#jqGrid&quot;).jqGrid(&#39;hideCol&#39;, [&quot;column&quot;]).trigger(&quot;reloadGrid&quot;);</span><br><span class="line">通过上的方法即可将不需要显示的列进行隐藏操作。如果参数为一个列名则隐藏此列，如果给定的是数组则隐藏指定的所有列。格式： [“name1”,”name2”]</span><br><span class="line"></span><br><span class="line">对应的肯定有显示showCol方法了，具体使用方式与上面相同：</span><br><span class="line"></span><br><span class="line">$(&quot;#jqGrid&quot;).jqGrid(&#39;showCol&#39;, [&quot;column&quot;]).trigger(&quot;reloadGrid&quot;);</span><br><span class="line">显示列。column可以是数组[“name1”,”name2”],但是name1或者name2必须是colModel中的name。</span><br><span class="line"></span><br><span class="line">当然，上面只是通过隐藏和显示来达到动态修改列表的，如果需要动态新增内容可通过setColProp方法来操作。</span><br><span class="line"></span><br><span class="line">setColProp设置新的属性，对于动态改变列属性是非常有用的，但是有些属性的修改并不会起效。用法：</span><br><span class="line"></span><br><span class="line">$(&quot;#jqGrid&quot;).setColProp(&#39;colname&#39;,&#123;editoptions:&#123;value:“True:False”&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2020-03-23-16-58-10-星期一"><a href="#2020-03-23-16-58-10-星期一" class="headerlink" title="2020-03-23 16:58:10 星期一"></a>2020-03-23 16:58:10 星期一</h3><h5 id="单元格自动换行"><a href="#单元格自动换行" class="headerlink" title="单元格自动换行"></a>单元格自动换行</h5><p>添加如下样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ui-jqgrid</span> <span class="selector-tag">tr</span><span class="selector-class">.jqgrow</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line"><span class="attribute">white-space</span>: normal <span class="meta">!important</span>;</span><br><span class="line"><span class="attribute">height</span>:auto;</span><br><span class="line"><span class="attribute">vertical-align</span>:text-top;</span><br><span class="line"><span class="attribute">padding-top</span>:<span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-linux</title>
    <url>/2020/08/16/notebook-linux/</url>
    <content><![CDATA[<h1 id="Tue-Oct-29-14-43-17-CST-2019"><a href="#Tue-Oct-29-14-43-17-CST-2019" class="headerlink" title="Tue Oct 29 14:43:17 CST 2019"></a>Tue Oct 29 14:43:17 CST 2019</h1><h2 id="rm-删除文件时，通配符的使用？"><a href="#rm-删除文件时，通配符的使用？" class="headerlink" title="rm 删除文件时，通配符的使用？"></a>rm 删除文件时，通配符的使用？</h2><ul>
<li><code>*</code> 匹配任意多个字符</li>
<li><code>?</code> 匹配任意单个字符</li>
<li><code>[]</code> 匹配之间的任意一个字符</li>
<li><code>^</code> 表示匹配结果取反的意思，注意这个通配符必须要在[]中使用</li>
<li><code>&#123;&#125;</code> 表示符合括号内包含的多个文件, 如 <code>ls &#123;*.log,*.txt&#125; 查询‘.log’和“.txt”结尾的文件</code></li>
</ul>
<h2 id="rm删除多级目录下的文件？"><a href="#rm删除多级目录下的文件？" class="headerlink" title="rm删除多级目录下的文件？"></a><code>rm</code>删除多级目录下的文件？</h2><ul>
<li><code>find . -name &quot;*.log&quot;|xargs rm -f</code></li>
</ul>
<h1 id="Wed-Nov-13-09-50-50-CST-2019"><a href="#Wed-Nov-13-09-50-50-CST-2019" class="headerlink" title="Wed Nov 13 09:50:50 CST 2019"></a>Wed Nov 13 09:50:50 CST 2019</h1><h2 id="如何写一个sh脚本，并可以向其中传递参数？"><a href="#如何写一个sh脚本，并可以向其中传递参数？" class="headerlink" title="如何写一个sh脚本，并可以向其中传递参数？"></a>如何写一个sh脚本，并可以向其中传递参数？</h2><h1 id="Fri-Dec-13-08-38-08-CST-2019"><a href="#Fri-Dec-13-08-38-08-CST-2019" class="headerlink" title="Fri Dec 13 08:38:08 CST 2019"></a>Fri Dec 13 08:38:08 CST 2019</h1><h2 id="查询使用端口的命令"><a href="#查询使用端口的命令" class="headerlink" title="查询使用端口的命令"></a>查询使用端口的命令</h2><p><code>netstat -anp|grep 8080</code></p>
<h2 id="mac下查询某个端口是否被占用"><a href="#mac下查询某个端口是否被占用" class="headerlink" title="mac下查询某个端口是否被占用"></a>mac下查询某个端口是否被占用</h2><blockquote>
<p>方法一：<br>//查看80口是否被占用<br>sudo lsof -i :80<br>方法二：<br>netstat -anp tcp | grep 80</p>
</blockquote>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-macOS</title>
    <url>/2020/08/16/notebook-macOS/</url>
    <content><![CDATA[<h1 id="Tue-Oct-29-10-35-33-CST-2019"><a href="#Tue-Oct-29-10-35-33-CST-2019" class="headerlink" title="Tue Oct 29 10:35:33 CST 2019"></a>Tue Oct 29 10:35:33 CST 2019</h1><h2 id="在macOS-X及以上下载jdk1-6和卸载jdk1-6？"><a href="#在macOS-X及以上下载jdk1-6和卸载jdk1-6？" class="headerlink" title="在macOS X及以上下载jdk1.6和卸载jdk1.6？"></a>在macOS X及以上下载jdk1.6和卸载jdk1.6？</h2><ul>
<li><a href="https://gitissue.com/issues/5a8c7e633a40eb3c8f293346">Mac系统下安装及卸载JDK</a></li>
</ul>
<h1 id="Fri-Dec-13-13-29-04-CST-2019"><a href="#Fri-Dec-13-13-29-04-CST-2019" class="headerlink" title="Fri Dec 13 13:29:04 CST 2019"></a>Fri Dec 13 13:29:04 CST 2019</h1><h2 id="文件编码的转换？"><a href="#文件编码的转换？" class="headerlink" title="文件编码的转换？"></a>文件编码的转换？</h2><ul>
<li><code>iconv</code> <code>iconv -c -f gbk -t utf8 test.txt &gt; test.txt.utf8</code></li>
<li><code>enca</code></li>
</ul>
<h2 id="MacOS系统Docker默认存储路径迁移方法"><a href="#MacOS系统Docker默认存储路径迁移方法" class="headerlink" title="MacOS系统Docker默认存储路径迁移方法?"></a>MacOS系统Docker默认存储路径迁移方法?</h2><p><a href="https://juejin.im/post/5c3884ad6fb9a049d05df4a9">掘金blog</a></p>
<h1 id="Sat-Dec-14-21-00-37-CST-2019"><a href="#Sat-Dec-14-21-00-37-CST-2019" class="headerlink" title="Sat Dec 14 21:00:37 CST 2019"></a>Sat Dec 14 21:00:37 CST 2019</h1><h2 id="文件传输命令"><a href="#文件传输命令" class="headerlink" title="文件传输命令"></a>文件传输命令</h2><ul>
<li><code>rsync</code> 远程文件同步工具</li>
</ul>
<h1 id="Fri-Dec-27-10-56-23-CST-2019"><a href="#Fri-Dec-27-10-56-23-CST-2019" class="headerlink" title="Fri Dec 27 10:56:23 CST 2019"></a>Fri Dec 27 10:56:23 CST 2019</h1><h2 id="zsh下的docker插件无效的原因？"><a href="#zsh下的docker插件无效的原因？" class="headerlink" title="zsh下的docker插件无效的原因？"></a>zsh下的docker插件无效的原因？</h2><ul>
<li>用户目录下的缓存文件问题<br>需清除<code>rm ~/.zcompdump*</code></li>
</ul>
<h1 id="2019年12月28日-星期六-20时38分53秒-CST"><a href="#2019年12月28日-星期六-20时38分53秒-CST" class="headerlink" title="2019年12月28日 星期六 20时38分53秒 CST"></a>2019年12月28日 星期六 20时38分53秒 CST</h1><h2 id="mac-java开发-推荐的一些软件"><a href="#mac-java开发-推荐的一些软件" class="headerlink" title="mac java开发 推荐的一些软件"></a>mac java开发 推荐的一些软件</h2><ul>
<li>alfred <em>分普通版和加强版</em></li>
<li>dash 查看文档</li>
<li>iterm 源生的终端工具，可配合zsh使用，最好安装<code>oh my zsh</code></li>
<li>sublime-text 编辑器 <em>付费的</em></li>
<li>JetBrains系列的产品，如idea、pycharm等等</li>
<li>homebrew</li>
<li>source tree 最好用的git GUI客户端</li>
<li>beyond-compare 文件比较工具</li>
<li>kaleidoscope Mac下的文件比较工具</li>
<li>codeRunner 一款编程软件</li>
<li>Mweb 专业的markdown生成软件 <em>付费的</em></li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-maven</title>
    <url>/2020/08/16/notebook-maven/</url>
    <content><![CDATA[<h1 id="Tue-Oct-29-09-46-47-CST-2019"><a href="#Tue-Oct-29-09-46-47-CST-2019" class="headerlink" title="Tue Oct 29 09:46:47 CST 2019"></a>Tue Oct 29 09:46:47 CST 2019</h1><h2 id="使用maven导入项目需要依赖的jar包时，明明在本地仓库存在需要的jar包，但是jar包导入不到项目中？"><a href="#使用maven导入项目需要依赖的jar包时，明明在本地仓库存在需要的jar包，但是jar包导入不到项目中？" class="headerlink" title="使用maven导入项目需要依赖的jar包时，明明在本地仓库存在需要的jar包，但是jar包导入不到项目中？"></a>使用maven导入项目需要依赖的jar包时，明明在本地仓库存在需要的jar包，但是jar包导入不到项目中？</h2><ol>
<li>一种可能性：pom文件中有一些jar在本地仓库没有，导致所有的jar包都引入不了。</li>
</ol>
<h2 id="pom文件中标签下的标签内容的含义？"><a href="#pom文件中标签下的标签内容的含义？" class="headerlink" title="pom文件中标签下的标签内容的含义？"></a>pom文件中<dependency>标签下的<scope>标签内容的含义？</scope></dependency></h2><ul>
<li>compile<blockquote>
<p>默认的scope。任何定义在compile scope下的依赖将会在所有的class paths下可用。maven工程会将其打包到最终的artifact中。如果你构建一个WAR类型的artifact，那么在compile scope下引用的JAR文件将会被集成到WAR文件内。</p>
</blockquote>
</li>
<li>provided<blockquote>
<p>这个scope假定对应的依赖会由运行这个应用的JDK或者容器来提供。最好的例子就是servlet API。任何在provided scope下定义的依赖在构建时的类路径里是可用的，但是不会被打包到最终的artifact中。如果是一个WAR的文件，servlet API在构建时的类路径里是可用的，但是并不会被打包到WAR文件中</p>
</blockquote>
</li>
<li>rumtime<blockquote>
<p>在runtime scope下定义的依赖只会在运行期可用，而在构建期的类路径下不可用。这些依赖将会被打包到最终的artifact中。比如你有一个基于web的应用需要在运行时访问MySQL数据库。你的代码没有任何MySQL数据库驱动的硬依赖。你的代码仅仅是基于JDBC API来编写，在构建期并不需要MySQL数据库驱动。然而，在运行期，就需要相应的驱动来操作MySQL数据库了。因此，这个驱动应该被打包到最终的artifact中。</p>
</blockquote>
</li>
<li>test<blockquote>
<p>只用于测试变异的依赖（比如JUnit），execution必须定义在test scope下。这些依赖不会被打包到最终的artifact中。</p>
</blockquote>
</li>
<li>system<blockquote>
<p>于provided scope很像。唯一的区别在于，在system scope中，你需要告诉Maven如何去找到这个依赖。如果你要引用的依赖在Maven仓库中不存在时，就可以用这个scope。不推荐使用system依赖。</p>
</blockquote>
</li>
</ul>
<h2 id="maven配置镜像仓库和伺服仓库"><a href="#maven配置镜像仓库和伺服仓库" class="headerlink" title="maven配置镜像仓库和伺服仓库"></a>maven配置镜像仓库和伺服仓库</h2><ul>
<li>一般镜像仓库只配置一个， 伺服仓库可以配置多个。</li>
</ul>
<h2 id="maven项目编译报错，error-reading-file-error-in-opening-zip-file"><a href="#maven项目编译报错，error-reading-file-error-in-opening-zip-file" class="headerlink" title="maven项目编译报错，error reading file:.. error in opening zip file?"></a>maven项目编译报错，<code>error reading file:.. error in opening zip file</code>?</h2><ul>
<li>在本地仓库删除报错的jar包，将其删除掉，然后从远程仓库重新下载。</li>
</ul>
<h1 id="Tue-Nov-12-13-56-49-CST-2019"><a href="#Tue-Nov-12-13-56-49-CST-2019" class="headerlink" title="Tue Nov 12 13:56:49 CST 2019"></a>Tue Nov 12 13:56:49 CST 2019</h1><h2 id="maven打包时，跳过测试用例"><a href="#maven打包时，跳过测试用例" class="headerlink" title="maven打包时，跳过测试用例"></a>maven打包时，跳过测试用例</h2><blockquote>
<p>-DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。<br>-Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。</p>
</blockquote>
<h2 id="maven将class文件打包成一个单独的jar包？"><a href="#maven将class文件打包成一个单独的jar包？" class="headerlink" title="maven将class文件打包成一个单独的jar包？"></a>maven将class文件打包成一个单独的jar包？</h2><blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<!--将class文件打成jar-->
<p><plugin><br>    <groupId>org.apache.maven.plugins</groupId><br>    <artifactId>maven-jar-plugin</artifactId><br>    <version>2.6</version><br>    <configuration><br>        <encoding>UTF-8</encoding>
    </configuration><br>    <executions><br>        <execution><br>            <phase>package</phase><br>            <goals><br>                <goal>jar</goal>
            </goals><br>            <configuration><br>                <classesDirectory>${project.build.directory}/${project.build.finalName}/WEB-INF/classes</classesDirectory><br>                <finalName>my_jar</finalName><br>                <outputDirectory>${project.build.directory}/${project.build.finalName}/WEB-INF/lib</outputDirectory><br>                <includes><br>                    <include>com/**</include>
                </includes>
            </configuration>
        </execution>
    </executions>
</plugin><br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Thu Nov 14 10:41:39 CST 2019</span><br><span class="line">## archetype plugin的学习</span><br><span class="line">1. 创建一个项目的骨架，可以从已存在的archetype库中，也可以从存在的项目中。</span><br><span class="line">2. goals</span><br><span class="line">  - archetype:generate</span><br><span class="line">  - archetype:create-from-project</span><br><span class="line">  - archetype:crawl</span><br><span class="line"></span><br><span class="line"># Mon Nov 18 17:52:09 CST 2019</span><br><span class="line">## 导入本地jar包到本地maven仓库</span><br><span class="line">&#96;mvn install:install-file -Dfile&#x3D;lombok-1.18.8.jar -DgroupId&#x3D;org.projectlombok -DartifactId&#x3D;lombok -Dversion&#x3D;1.18.8 -Dpackaging&#x3D;jar&#96;</span><br><span class="line"></span><br><span class="line"># Tue Nov 19 13:55:50 CST 2019</span><br><span class="line">## 通过pom文件来生成一个基础的maven项目</span><br><span class="line"></span><br><span class="line"># Sat Dec  7 20:26:11 CST 2019</span><br><span class="line">## 常见maven命令的使用和含义</span><br><span class="line">1. &#96;mvn dependency:tree &#96; 展示项目的jar包之间的依赖关系,可解决jar包冲突等问题。</span><br><span class="line">  - 参数 -Dverbose&#x3D;true 展示详细信息</span><br><span class="line">  - 参数 -Dincludes&#x3D;&#96;groupId:artifactId:version&#96; 只展示你需要的jar包信息</span><br><span class="line">  - 参数 -Dexcludes&#x3D;&#96;groupId:artifactId:version&#96; 只展示你不需要的jar包信息</span><br><span class="line"></span><br><span class="line">## Fatal error compiling: 无效的标记</span><br><span class="line">  可能是项目使用的jdk版本和maven的jdk版本不一致导致的。</span><br><span class="line"></span><br><span class="line"># Sun Dec  8 21:39:09 CST 2019</span><br><span class="line">## maven中phase，plugin，goal之间的区别是什么？</span><br><span class="line">- goal是maven中执行的最小单元；</span><br><span class="line">- 一个phase或者plugin包含一个或者多个goal；</span><br><span class="line"># Tue Dec 10 10:32:05 CST 2019</span><br><span class="line">## &#96;mvn install&#96;产生的错误</span><br><span class="line">1. compailation failure: 名称冲突，类A的方法和类B的方法，具有相同的疑符，但两者均不隐藏对方？</span><br><span class="line">2. 子模块和父模块中存在同一个jar包依赖，以哪个为准？</span><br><span class="line">3. compailation failure: 找不到合适的方法？</span><br><span class="line">  jdk版本引入错误，可能使用了高版本的jdk</span><br><span class="line">4. compailation failure: 错误(非法字符 &#96;\ufeff&#96;),错误(需要class,interface,enum)?</span><br><span class="line">  编码为UTF-8，应为UTF-8 无 BOM。</span><br><span class="line">5. compailation failure: 错误(编码UTF-8的不可映射字符)?</span><br><span class="line">  编码应该UTF-8，实际上不是。</span><br><span class="line">6. exceptions: File: &#39;java.lang.CharSequence&#39;: Invalid byte tag in constant pool: 15 ?</span><br><span class="line"></span><br><span class="line">## 文件编码&#96;UTF-8&#96;和&#96;UTF-8 无 BOM&#96;的区别？</span><br><span class="line"></span><br><span class="line"># Wed Dec 11 13:32:54 CST 2019</span><br><span class="line">## ant(ivy),maven,gradle之间的区别和联系？</span><br><span class="line">- 时间排序(从小到大): ant&lt;maven&lt;gradle</span><br><span class="line">- 最小单元</span><br><span class="line">  ant(target), maven(goal), gradle(task)</span><br><span class="line">- 都是项目构建工具</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-oracle</title>
    <url>/2020/08/16/notebook-oracle/</url>
    <content><![CDATA[<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ol>
<li>取余函数 mod</li>
<li>对时间格式或数字格式进行截取 trunc</li>
<li>对数字进行四舍五入 round(a1, a2)<br>a1: 进行四舍五入的数字<br>a2: 从小数点的左边还是右边几位数进行四舍五入（0表示四舍五入到整数位，正数1表示四舍五入到小数点右边1位，负数1表示四舍五入到小数点左边1位）</li>
</ol>
<h1 id="Tue-Oct-29-11-23-05-CST-2019"><a href="#Tue-Oct-29-11-23-05-CST-2019" class="headerlink" title="Tue Oct 29 11:23:05 CST 2019"></a>Tue Oct 29 11:23:05 CST 2019</h1><h2 id="查询数据库的表空间？"><a href="#查询数据库的表空间？" class="headerlink" title="查询数据库的表空间？"></a>查询数据库的表空间？</h2><ul>
<li><code>select * from dba_tablespaces t;</code></li>
</ul>
<h2 id="修改表字段信息"><a href="#修改表字段信息" class="headerlink" title="修改表字段信息"></a>修改表字段信息</h2><ul>
<li><code>alter table $tableName modify $columnName varchar2(20)</code></li>
</ul>
<h1 id="Thu-Oct-31-13-57-58-CST-2019"><a href="#Thu-Oct-31-13-57-58-CST-2019" class="headerlink" title="Thu Oct 31 13:57:58 CST 2019"></a>Thu Oct 31 13:57:58 CST 2019</h1><h2 id="oracle表的唯一性隐藏字段rowid"><a href="#oracle表的唯一性隐藏字段rowid" class="headerlink" title="oracle表的唯一性隐藏字段rowid"></a>oracle表的唯一性隐藏字段rowid</h2><h1 id="Fri-Nov-1-18-07-51-CST-2019"><a href="#Fri-Nov-1-18-07-51-CST-2019" class="headerlink" title="Fri Nov  1 18:07:51 CST 2019"></a>Fri Nov  1 18:07:51 CST 2019</h1><h2 id="ora-01847-月份中日的值必须介于1和当月最后一日之间？"><a href="#ora-01847-月份中日的值必须介于1和当月最后一日之间？" class="headerlink" title="ora-01847:月份中日的值必须介于1和当月最后一日之间？"></a>ora-01847:月份中日的值必须介于1和当月最后一日之间？</h2><h1 id="Sun-Nov-3-12-30-27-CST-2019"><a href="#Sun-Nov-3-12-30-27-CST-2019" class="headerlink" title="Sun Nov  3 12:30:27 CST 2019"></a>Sun Nov  3 12:30:27 CST 2019</h1><h2 id="以后给别人导表数据的时候，最好是表结构和表数据一起导，防止数据的类型出现各种带下不一致的问题。"><a href="#以后给别人导表数据的时候，最好是表结构和表数据一起导，防止数据的类型出现各种带下不一致的问题。" class="headerlink" title="以后给别人导表数据的时候，最好是表结构和表数据一起导，防止数据的类型出现各种带下不一致的问题。"></a>以后给别人导表数据的时候，最好是表结构和表数据一起导，防止数据的类型出现各种带下不一致的问题。</h2><h1 id="Mon-Nov-4-12-29-24-CST-2019"><a href="#Mon-Nov-4-12-29-24-CST-2019" class="headerlink" title="Mon Nov  4 12:29:24 CST 2019"></a>Mon Nov  4 12:29:24 CST 2019</h1><h2 id="oracle数据库的监听问题，描述查看监听的状态-lsnrctl-status-时，执行的很慢-查看1521端口时，显示监听已经启动了，但是查看监听的状态时，显示监听是没有启动的-有报错信息如下：-64-bit-Windows-Error-61-Unkonwn-error"><a href="#oracle数据库的监听问题，描述查看监听的状态-lsnrctl-status-时，执行的很慢-查看1521端口时，显示监听已经启动了，但是查看监听的状态时，显示监听是没有启动的-有报错信息如下：-64-bit-Windows-Error-61-Unkonwn-error" class="headerlink" title="oracle数据库的监听问题，描述查看监听的状态(lsnrctl status)时，执行的很慢;查看1521端口时，显示监听已经启动了，但是查看监听的状态时，显示监听是没有启动的;有报错信息如下：[64-bit Windows Error:61:Unkonwn error]"></a>oracle数据库的监听问题，描述<code>查看监听的状态(lsnrctl status)时，执行的很慢;查看1521端口时，显示监听已经启动了，但是查看监听的状态时，显示监听是没有启动的;有报错信息如下：[64-bit Windows Error:61:Unkonwn error]</code></h2><ul>
<li>检查监听的日志文件是不是太大了（如达到了4G），若是，需删除此日志文件</li>
<li>查看日志文件所在位置的sql<code>select name, value from v$diag_info;</code></li>
</ul>
<h1 id="Wed-Nov-6-11-04-41-CST-2019"><a href="#Wed-Nov-6-11-04-41-CST-2019" class="headerlink" title="Wed Nov  6 11:04:41 CST 2019"></a>Wed Nov  6 11:04:41 CST 2019</h1><h2 id="exp命令"><a href="#exp命令" class="headerlink" title="exp命令"></a>exp命令</h2><ul>
<li>导出指定数量的表数据文件<blockquote>
<p><code>exp cboms/cboms@32.202.32.21/cboms file=cboms.dmp log=cboms.log query=&quot;&#39;where rownum&lt;10001&#39;&quot; tables=&#39;%%&#39;</code></p>
</blockquote>
</li>
<li>导出数据库表结构<blockquote>
<p><code>exp cboms/cboms file=cboms_jiegou.dmp tables=%% rows=n</code></p>
</blockquote>
</li>
</ul>
<h2 id="新建数据库的表空间"><a href="#新建数据库的表空间" class="headerlink" title="新建数据库的表空间"></a>新建数据库的表空间</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--oracle创建用户并授权</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--创建用户临时表空间 </span></span><br><span class="line"><span class="keyword">create</span> temporary tablespace cboms_index tempfile <span class="string">&#x27;/home/oracle/oraData/cboms_index01.dbf&#x27;</span> size <span class="number">50</span>m autoextend <span class="keyword">on</span> next <span class="number">50</span>m maxsize <span class="number">20480</span>m extent management <span class="keyword">local</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--创建用户表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space cboms datafile <span class="string">&#x27;/home/oracle/oraData/cboms01.dbf&#x27;</span> size <span class="number">50</span>m autoextend <span class="keyword">on</span> next <span class="number">100</span>m maxsize unlimited(<span class="number">20480</span>m extent management <span class="keyword">local</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> cboms identified <span class="keyword">by</span> cboms <span class="keyword">default</span> tablespace cboms temporary tablespace cboms_index;</span><br><span class="line"><span class="comment">--授予权限</span></span><br><span class="line"><span class="keyword">grant</span> unlimited tablespace <span class="keyword">to</span> cboms;<span class="comment">--授予cboms用户使用表空间的权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> session <span class="keyword">to</span> cboms;<span class="comment">--授予cboms用户创建session的权限，即登陆权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">ALL</span> privileges <span class="keyword">to</span> cboms;<span class="comment">--这条比较重要，授予所有权限(all)给用户(cboms)</span></span><br><span class="line"><span class="keyword">GRANT</span> DBA <span class="keyword">TO</span> cboms;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看权限</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_sys_privs;<span class="comment">--查看当前用户所有权限</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> DBA_SYS_PRIVS <span class="keyword">WHERE</span> GRANTEE <span class="keyword">IN</span> (<span class="string">&#x27;cboms&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="查看表空间"><a href="#查看表空间" class="headerlink" title="查看表空间"></a>查看表空间</h2><p><code>SELECT tablespace_name, file_id, file_name, round(bytes / (1024 * 1024), 0) total_space FROM dba_data_files ORDER BY tablespace_name;</code></p>
<h2 id="新增表空间"><a href="#新增表空间" class="headerlink" title="新增表空间"></a>新增表空间</h2><p><code>alter tablespace cboms add datafile  &#39;/home/oracle/oraData/cboms02.dbf&#39; size 50m autoextend on next 100m maxsize 20480m;</code></p>
<h2 id="删除用户和表空间"><a href="#删除用户和表空间" class="headerlink" title="删除用户和表空间"></a>删除用户和表空间</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">删除用户和表空间,对于单个<span class="keyword">user</span>和tablespace 来说， 可以使用如下命令来完成。</span><br><span class="line">步骤一： 删除<span class="keyword">user</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> ×× cascade</span><br><span class="line">如：<span class="keyword">drop</span> <span class="keyword">user</span> SMCHANNEL CASCADE</span><br><span class="line">说明： 删除了<span class="keyword">user</span>，只是删除了该<span class="keyword">user</span>下的schema objects，是不会删除相应的tablespace的。</span><br><span class="line">步骤二： 删除tablespace</span><br><span class="line"><span class="keyword">DROP</span> TABLESPACE tablespace_name INCLUDING CONTENTS <span class="keyword">AND</span> DATAFILES;</span><br></pre></td></tr></table></figure>
<h2 id="imp"><a href="#imp" class="headerlink" title="imp"></a>imp</h2><h3 id="IMP-00015-following-statement-failed-because-the-object-already-exists"><a href="#IMP-00015-following-statement-failed-because-the-object-already-exists" class="headerlink" title="IMP-00015: following statement failed because the object already exists"></a>IMP-00015: following statement failed because the object already exists</h3><ul>
<li>设置参数<code>ignore=y</code>(忽略创建错误)<h3 id="导入指定表的数据"><a href="#导入指定表的数据" class="headerlink" title="导入指定表的数据"></a>导入指定表的数据</h3><code>imp userid=cboms/cboms file=wxrcb_data/cboms_data.dmp tables=&#39;sys_data_dict,sys_data_dict_type&#39; log=imp.log data_only=y</code></li>
</ul>
<h2 id="可以判断一个字段以数字结尾吗？"><a href="#可以判断一个字段以数字结尾吗？" class="headerlink" title="可以判断一个字段以数字结尾吗？"></a>可以判断一个字段以数字结尾吗？</h2><ul>
<li>正则表达式的like <code>regexp_like</code></li>
</ul>
<h2 id="函数：将不同行的字段合并到同一列上的？"><a href="#函数：将不同行的字段合并到同一列上的？" class="headerlink" title="函数：将不同行的字段合并到同一列上的？"></a>函数：将不同行的字段合并到同一列上的？</h2><ul>
<li>wm_concat(column) <code>默认以逗号分隔</code></li>
<li>listagg(cloumnA, ‘,’) within group(rder by columnB)</li>
</ul>
<h1 id="Thu-Nov-7-10-03-32-CST-2019"><a href="#Thu-Nov-7-10-03-32-CST-2019" class="headerlink" title="Thu Nov  7 10:03:32 CST 2019"></a>Thu Nov  7 10:03:32 CST 2019</h1><h2 id="新增序列"><a href="#新增序列" class="headerlink" title="新增序列"></a>新增序列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence seq_arc_efile_zskwj</span><br><span class="line">minvalue <span class="number">1</span></span><br><span class="line">maxvalue <span class="number">999999999999999999</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">621</span></span><br><span class="line">increment <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line">nocache;</span><br></pre></td></tr></table></figure>
<h1 id="Fri-Nov-8-09-33-32-CST-2019"><a href="#Fri-Nov-8-09-33-32-CST-2019" class="headerlink" title="Fri Nov  8 09:33:32 CST 2019"></a>Fri Nov  8 09:33:32 CST 2019</h1><h2 id="在不同的表中插入语句或者在同一张表中插入多条数据？"><a href="#在不同的表中插入语句或者在同一张表中插入多条数据？" class="headerlink" title="在不同的表中插入语句或者在同一张表中插入多条数据？"></a>在不同的表中插入语句或者在同一张表中插入多条数据？</h2><h1 id="Sun-Nov-10-11-10-58-CST-2019"><a href="#Sun-Nov-10-11-10-58-CST-2019" class="headerlink" title="Sun Nov 10 11:10:58 CST 2019"></a>Sun Nov 10 11:10:58 CST 2019</h1><h2 id="给表或者字段添加注释"><a href="#给表或者字段添加注释" class="headerlink" title="给表或者字段添加注释"></a>给表或者字段添加注释</h2><ol>
<li><code>comment on table tableName is &#39;&#39;</code></li>
<li><code>comment on column tableName.columnName is &#39;&#39;</code></li>
</ol>
<h1 id="Mon-Nov-11-10-36-34-CST-2019"><a href="#Mon-Nov-11-10-36-34-CST-2019" class="headerlink" title="Mon Nov 11 10:36:34 CST 2019"></a>Mon Nov 11 10:36:34 CST 2019</h1><h2 id="del格式文件导入到oracle数据库中"><a href="#del格式文件导入到oracle数据库中" class="headerlink" title="del格式文件导入到oracle数据库中"></a>del格式文件导入到oracle数据库中</h2><h1 id="Wed-Nov-20-12-53-12-CST-2019"><a href="#Wed-Nov-20-12-53-12-CST-2019" class="headerlink" title="Wed Nov 20 12:53:12 CST 2019"></a>Wed Nov 20 12:53:12 CST 2019</h1><h2 id="换行符表示"><a href="#换行符表示" class="headerlink" title="换行符表示"></a>换行符表示</h2><blockquote>
<p>chr(13) 回车符<br>chr(10) 换行符<br>chr(9) 制表符</p>
<ul>
<li><h1 id="Thu-Dec-5-09-53-50-CST-2019"><a href="#Thu-Dec-5-09-53-50-CST-2019" class="headerlink" title="Thu Dec  5 09:53:50 CST 2019"></a>Thu Dec  5 09:53:50 CST 2019</h1></li>
</ul>
<ol>
<li>判断字符串中是否含有某个字符的函数？<br><code>instr(str, search_str, [, start_position][, nth_appearance]) instr(源字符串， 目标字符串[, 开始位置][, 匹配序号])</code></li>
<li>IF判断的多重分支？<br>一、单个IF<br>1、<br>if a=…  then<br>………<br>end if;<br>2、<br>if a=… then<br>……<br>else<br>….<br>end if;<br>二、多个IF<br>if a=..  then<br>……<br>elsif a=..  then<br>….<br>end if;</li>
</ol>
</blockquote>
<h1 id="Thu-Dec-12-10-09-08-CST-2019"><a href="#Thu-Dec-12-10-09-08-CST-2019" class="headerlink" title="Thu Dec 12 10:09:08 CST 2019"></a>Thu Dec 12 10:09:08 CST 2019</h1><h2 id="IMP-00002-failed-to-open-ers1-dmp-for-read"><a href="#IMP-00002-failed-to-open-ers1-dmp-for-read" class="headerlink" title="IMP-00002: failed to open ers1.dmp for read ??"></a>IMP-00002: failed to open ers1.dmp for read ??</h2><h2 id="ORA-12705-Cannot-access-NLS-data-files-or-invalid-environment-specified"><a href="#ORA-12705-Cannot-access-NLS-data-files-or-invalid-environment-specified" class="headerlink" title="ORA-12705: Cannot access NLS data files or invalid environment specified ??"></a>ORA-12705: Cannot access NLS data files or invalid environment specified ??</h2><h2 id="oracle数据库，sqlplus连接乱码问题？"><a href="#oracle数据库，sqlplus连接乱码问题？" class="headerlink" title="oracle数据库，sqlplus连接乱码问题？"></a>oracle数据库，sqlplus连接乱码问题？</h2><ul>
<li>linux：设置环境变量<code>NLS_LANG</code>,等于<code>AMERICAN_AMERICA.AL32UTF8</code></li>
<li>windows: 设置环境变量<code>NLS_LANG</code>,等于<code>SIMPLIFIED CHINESE_CHINA.ZHS16GBK</code></li>
</ul>
<h2 id="start-with-connect-by-prior-用法？"><a href="#start-with-connect-by-prior-用法？" class="headerlink" title="start with... connect by prior...用法？"></a><code>start with... connect by prior...</code>用法？</h2><p>  以哪条数据开始，以父数据(prior)的字段作为子数据的另一个字段,依次递归查询，为一个树形结构。</p>
<h1 id="Sat-Dec-14-19-55-06-CST-2019"><a href="#Sat-Dec-14-19-55-06-CST-2019" class="headerlink" title="Sat Dec 14 19:55:06 CST 2019"></a>Sat Dec 14 19:55:06 CST 2019</h1><h2 id="ORA-01033-ORACLE-initialization-or-shutdown"><a href="#ORA-01033-ORACLE-initialization-or-shutdown" class="headerlink" title="ORA-01033:ORACLE initialization or shutdown ??"></a>ORA-01033:ORACLE initialization or shutdown ??</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown normal;</span><br><span class="line">startup mount;</span><br><span class="line">alter database open;</span><br><span class="line"></span><br><span class="line"># Mon Dec 16 09:03:54 CST 2019</span><br><span class="line">## ORA-03113: end-of-file on communication channel??</span><br><span class="line">[](https:&#x2F;&#x2F;blog.51cto.com&#x2F;mister&#x2F;1740508)</span><br><span class="line">​&#96;&#96;&#96;sqlplus</span><br><span class="line">startup mount;</span><br><span class="line">startup nomount;</span><br><span class="line">exit;</span><br><span class="line">sqlplus &#x2F; as sysdba</span><br><span class="line">startup mount;</span><br><span class="line">alter database open;</span><br></pre></td></tr></table></figure>
<h1 id="Mon-Dec-16-18-40-39-CST-2019"><a href="#Mon-Dec-16-18-40-39-CST-2019" class="headerlink" title="Mon Dec 16 18:40:39 CST 2019"></a>Mon Dec 16 18:40:39 CST 2019</h1><h2 id="命令行查看函数或者存储过程的源代码？"><a href="#命令行查看函数或者存储过程的源代码？" class="headerlink" title="命令行查看函数或者存储过程的源代码？"></a>命令行查看函数或者存储过程的源代码？</h2><ul>
<li><code>select text from (all_source)user_source where name=upper(&#39;swap_drb&#39;) order by line;</code></li>
<li><a href="https://www.cnblogs.com/saptechnique/archive/2013/03/19/2969906.html">oralce-sqlplus命令详解</a></li>
</ul>
<h2 id="ORA-06575-程序包或函数-FUN-GET-SFZHM-BY-CZY-处于无效状态"><a href="#ORA-06575-程序包或函数-FUN-GET-SFZHM-BY-CZY-处于无效状态" class="headerlink" title="ORA-06575: 程序包或函数 FUN_GET_SFZHM_BY_CZY 处于无效状态?"></a>ORA-06575: 程序包或函数 FUN_GET_SFZHM_BY_CZY 处于无效状态?</h2><ul>
<li>错误原因<br>程序包或者函数编译不通过。</li>
</ul>
<h2 id="函数创建的基本格式？"><a href="#函数创建的基本格式？" class="headerlink" title="函数创建的基本格式？"></a>函数创建的基本格式？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建函数的基本格式 create or replace function 函数名称(参数1 ，参数2) return 参数类型 is </span><br><span class="line">begin</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建函数语法</span><br><span class="line">create [or replace] function [schema.]function_name</span><br><span class="line">(函数参数列表) --参数有IN、OUT、IN OUT三种类型；IN代表需要输入的参数，OUT代表要返回的参数，IN OUT代表即是输入参数也是返回参数。</span><br><span class="line">return datetype--返回类型</span><br><span class="line">[is | as ]---任选一个，后面跟pLSQL代码块</span><br><span class="line">[declare]--有参数时使用关键字</span><br><span class="line">begin</span><br><span class="line">  --执行的SQL</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h1 id="2019年12月31日-星期二-14时05分21秒-CST"><a href="#2019年12月31日-星期二-14时05分21秒-CST" class="headerlink" title="2019年12月31日 星期二 14时05分21秒 CST"></a>2019年12月31日 星期二 14时05分21秒 CST</h1><h2 id="for-in-loop-statement"><a href="#for-in-loop-statement" class="headerlink" title="for in loop statement"></a>for in loop statement</h2><p>oracle常见的三种循环结构</p>
<ul>
<li>loop statement end loop</li>
<li>while boolean expression loop statement end loop</li>
<li>for indexname in () loop statement end loop<br>examples<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">    v_num int;</span><br><span class="line">begin</span><br><span class="line">    for v_num in (reverse) 1..10 loop</span><br><span class="line">        dbms_output.PUT_LINE(&#39;num:&#39;||v_num);</span><br><span class="line">        end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h2 id="oracle打印日志输出"><a href="#oracle打印日志输出" class="headerlink" title="oracle打印日志输出"></a>oracle打印日志输出</h2><code>dbms_output.put_line()</code></li>
</ul>
<h2 id="oracle中join连接的几种方式"><a href="#oracle中join连接的几种方式" class="headerlink" title="oracle中join连接的几种方式"></a>oracle中join连接的几种方式</h2><ul>
<li>内连接(inner join),其中inner可以省略</li>
<li>外连接(left outer join,right outer join)，其中outer可以省略</li>
<li>…</li>
</ul>
<h2 id="table-函数的用法"><a href="#table-函数的用法" class="headerlink" title="table()函数的用法"></a>table()函数的用法</h2><ul>
<li>结合数组</li>
<li>结合pipelined函数</li>
<li>结合系统包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--1.</span><br><span class="line">explain plan for select * from usr_users t;</span><br><span class="line">select * from table(dbms_xplan.display);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="plan-table-is-old-version的处理方法"><a href="#plan-table-is-old-version的处理方法" class="headerlink" title="plan_table is old version的处理方法"></a>plan_table is old version的处理方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table plan_table;</span><br><span class="line">@?&#x2F;rdbms&#x2F;admin&#x2F;utlxplan.sql;</span><br></pre></td></tr></table></figure>
<h2 id="使用执行计划进行sql优化"><a href="#使用执行计划进行sql优化" class="headerlink" title="使用执行计划进行sql优化"></a>使用执行计划进行sql优化</h2><ul>
<li>查看总COST，获得资源耗费的总体印象 </li>
<li>按照从左至右，从上至下的方法，了解执行计划的执行步骤 </li>
<li>分析表的访问方式<br>全表扫描（TABLE ACCESS FULL）和索引扫描(INDEX SCAN)</li>
<li>分析表的连接方式和连接顺序<br>嵌套循环（NESTED LOOPS）、哈希连接（HASH JOIN）和排序-合并连接（SORT MERGE JOIN）</li>
</ul>
<h1 id="2020年-1月-2日-星期四-09时01分39秒-CST"><a href="#2020年-1月-2日-星期四-09时01分39秒-CST" class="headerlink" title="2020年 1月 2日 星期四 09时01分39秒 CST"></a>2020年 1月 2日 星期四 09时01分39秒 CST</h1><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-plantUML</title>
    <url>/2020/08/16/notebook-plantUML/</url>
    <content><![CDATA[<h1 id="Thu-Nov-7-13-01-51-CST-2019"><a href="#Thu-Nov-7-13-01-51-CST-2019" class="headerlink" title="Thu Nov  7 13:01:51 CST 2019"></a>Thu Nov  7 13:01:51 CST 2019</h1><h2 id="活动图-activity"><a href="#活动图-activity" class="headerlink" title="活动图(activity)"></a>活动图(activity)</h2><h2 id="甘特图-gantt"><a href="#甘特图-gantt" class="headerlink" title="甘特图(gantt)"></a>甘特图(gantt)</h2><h2 id="思维导图-mindmap"><a href="#思维导图-mindmap" class="headerlink" title="思维导图(mindmap)"></a>思维导图(mindmap)</h2><h2 id="工作分解结构-work-breakdwork-structure"><a href="#工作分解结构-work-breakdwork-structure" class="headerlink" title="工作分解结构(work breakdwork structure)"></a>工作分解结构(work breakdwork structure)</h2>]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-python3</title>
    <url>/2020/08/16/notebook-python3/</url>
    <content><![CDATA[<h1 id="2020年-1月27日-星期一-14时00分08秒-CST"><a href="#2020年-1月27日-星期一-14时00分08秒-CST" class="headerlink" title="2020年 1月27日 星期一 14时00分08秒 CST"></a>2020年 1月27日 星期一 14时00分08秒 CST</h1><ol>
<li>分支结构</li>
</ol>
<p>结构存在顺序结构、选择(分支)结构、循环结构三种。</p>
<ul>
<li>选择结构<br><code>if...elif..else..</code>,``</li>
</ul>
]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>notebook-vim</title>
    <url>/2020/08/16/notebook-vim/</url>
    <content><![CDATA[<h1 id="Tue-Oct-29-09-44-54-CST-2019"><a href="#Tue-Oct-29-09-44-54-CST-2019" class="headerlink" title="Tue Oct 29 09:44:54 CST 2019"></a>Tue Oct 29 09:44:54 CST 2019</h1><h2 id="将时间表达式-read-date格式化成符合中国人识别的格式？"><a href="#将时间表达式-read-date格式化成符合中国人识别的格式？" class="headerlink" title="将时间表达式:read !date格式化成符合中国人识别的格式？"></a>将时间表达式<code>:read !date</code>格式化成符合中国人识别的格式？</h2><h2 id="修改文件保存的编码格式？"><a href="#修改文件保存的编码格式？" class="headerlink" title="修改文件保存的编码格式？"></a>修改文件保存的编码格式？</h2><h2 id="修改文件查看的编码格式？"><a href="#修改文件查看的编码格式？" class="headerlink" title="修改文件查看的编码格式？"></a>修改文件查看的编码格式？</h2>]]></content>
      <tags>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>oh-my-zsh</title>
    <url>/2020/09/15/oh-my-zsh/</url>
    <content><![CDATA[<h4 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h4><h5 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h5><p>功能：实现目录间的快速跳转，想去哪个目录直接 <code>j + 目录名</code>，不用频繁的 cd 了。<strong>需要以前使用 cd 访问过这个目录。</strong></p>
<p><code>history|grep &quot;git clone&quot;</code> 这个命令就能找到近期 clone 了哪些库，省却了写一堆代码的功能。</p>
<p><code>autojump</code> 就是通过记录你在 <code>history</code> 中的行为把你访问过的文件夹路径都 cache 下来，当你输入路径名的时候会模糊匹配你之前 cd 过的目录路径，配合后面的自动提示插件，无敌了！</p>
<p>先 cd 到一些目录，然后可以 j 快速切换，用 jo 快速在 finder 里面打开文件夹。</p>
<h5 id="zsh-autosuggestion"><a href="#zsh-autosuggestion" class="headerlink" title="zsh-autosuggestion"></a>zsh-autosuggestion</h5><p>输入命令时可以提示自动补全（灰色部分），然后按键 ➡ (上下左右的右键，不是 tab 键)，即可补全。</p>
<h5 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h5><p>日常的命令会高亮显示，命令错误显示红色。</p>
<span id="more"></span>
]]></content>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle</title>
    <url>/2021/01/04/oracle/</url>
    <content><![CDATA[<h4 id="oracle树操作-select-…-start-with-…-connect-by-…-prior"><a href="#oracle树操作-select-…-start-with-…-connect-by-…-prior" class="headerlink" title="oracle树操作(select … start with … connect by … prior)"></a>oracle树操作(select … start with … connect by … prior)</h4><h5 id="树操作"><a href="#树操作" class="headerlink" title="树操作"></a>树操作</h5><ol>
<li><p>查找一个节点的所有直属子节点（所有后代）</p>
<p><code>select * from tb_menu m start with m.id = 1 connect by m.parent = prior m.id</code></p>
</li>
<li><p>查找一个节点的所有直属父节点（祖宗）</p>
<p><code>select * from tb_menu m start with m.id = 38 connect by prior m.parent = m.id</code></p>
</li>
<li><p>查询与一个节点同级的节点（族兄弟）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tmp as (</span><br><span class="line">	  select a.*, level leaf</span><br><span class="line">	  from tb_menu a</span><br><span class="line">	  start with a.parent is null</span><br><span class="line">	  connect by a.parent &#x3D; prior a.id</span><br><span class="line">	)</span><br><span class="line">select * from temp</span><br><span class="line">where leaf &#x3D; (select leaf from tmp where id &#x3D; 50)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle分组函数</title>
    <url>/2020/10/12/oracle%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="常用的分组函数"><a href="#常用的分组函数" class="headerlink" title="常用的分组函数"></a>常用的分组函数</h4><ul>
<li>count</li>
<li>avg</li>
<li>sum</li>
<li>max</li>
<li>min</li>
</ul>
<span id="more"></span>
<h4 id="group-by-字句"><a href="#group-by-字句" class="headerlink" title="group by 字句"></a>group by 字句</h4><h5 id="rollup-函数"><a href="#rollup-函数" class="headerlink" title="rollup 函数"></a>rollup 函数</h5><blockquote>
<p>（1）不带rollup的group by 分组情况</p>
<p>例：Group by A ,B</p>
<p>产生的分组种数：1种；</p>
<p>即group by A,B</p>
<p>返回结果集：也就是这一种分组的结果集</p>
<p>(2)带rollup 但 group by 与 rollup 之间没有任何内容</p>
<p>a)Group by rollup(A ,B)</p>
<p>产生的分组种数：3 种；</p>
<p>第一种：group by A,B</p>
<p>第二种：group by A</p>
<p>第三种：group by NULL</p>
<p>b)Group by rollup(A ,B,C)</p>
<p>产生的分组种数：4 种；</p>
<p>第一种：group by A,B,C</p>
<p>第二种：group by A,B</p>
<p>第三种：group by A</p>
<p>第四种：group by NULL</p>
<p>(3)带rollup 但 group by 与 rollup 之间还包含有列信息</p>
<p>a)Group by A , rollup(A ,B)</p>
<p>产生的分组种数：3 种；</p>
<p>第一种：group by A,A,B   等价于 group by A,B</p>
<p>第二种：group by A,A    等价于 group by A</p>
<p>第三种：group by A,NULL  等价于 group by A</p>
<p>b)Group by C , rollup(A ,B)</p>
<p>产生的分组种数：3 种；</p>
<p>第一种：group by C,A,B  </p>
<p>第二种：group by C,A   </p>
<p>第三种：group by C,NULL  等价于 group by C</p>
<p>(4)带rollup 且rollup子句括号内又使用括号对列进行组合(此为第一种情况的演变)<br>a)Group by rollup((A ,B))——（调账报表采用的此种分组方式）</p>
<p>产生的分组种数：2 种；</p>
<p>第一种：group by A,B</p>
<p>第二种：group by NULL<br>b)Group by rollup(A ,(B,C))</p>
<p>产生的分组种数：3 种；</p>
<p>第一种：group by A,B,C</p>
<p>第二种：group by A</p>
<p>第三种：group by NULL</p>
</blockquote>
<p>与 rollup 组合使用的几个辅助函数</p>
<blockquote>
<p>(1)grouping()函数<br>必须接受一列且只能接受一列做为其参数。参数列值为空返回1，参数列值非空返回0。<br>(2)grouping_id()函数</p>
<p>必须接受一列或多列做为其参数。</p>
<p>返回值为按参数排列顺序，依次对各个参数使用grouping()函数，并将结果值依次串成一串二进制数然后再转化为十进制所得到的值。</p>
<p>例：grouping(A) = 0 ; grouping(B) = 1;</p>
<p>​    则：grouping_id(A,B) = (01)2 = 1;</p>
<p>​        grouping_id(B,A) = (10)2 =2;<br>(3)group_id()函数</p>
<p>调用时不需要且不能传入任何参数。</p>
<p>返回值为某个特定的分组出现的重复次数(第一大点中的第3种情况中往往会产生重复的分组)。重复次数从0开始，例如某个分组第一次出现则返回值为0，第二次出现时返回值为1，……，第n次出现返回值为n-1<br>注：使用以上3个函数往往是为了过滤掉一部分统计数据</p>
</blockquote>
<h5 id="cube-函数"><a href="#cube-函数" class="headerlink" title="cube 函数"></a>cube 函数</h5><blockquote>
<p>rollup是cube的一种特殊情况，和rollup一样，cube也是根据维度在分组的结果集中进行聚合操作。但是rollup只在层次上对数据进行聚合，而cube对所有的维度进行聚合。具有N个维度的列，cube需要2的N次方次分组操作，而rollup只需要N次分组操作。</p>
<p>带cube子句的group by会产生更多的分组统计数据。cube后的列有多少种组合（注意组合是与顺序无关的）就会有多少种分组。</p>
<ol>
<li>假设有n个维度，rollup会有n个聚合：<br> rollup(a,b) 统计列包含：(a,b)、(a)、()<br> rollup(a,b,c) 统计列包含：(a,b,c)、(a,b)、(a)、()<br> ……以此类推ing……</li>
<li>假设有n个纬度，cube会有2的n次方个聚合：<br> cube(a,b) 统计列包含：(a,b)、(a)、(b)、()<br> cube(a,b,c) 统计列包含：(a,b,c)、(a,b)、(a,c)、(b,c)、(a)、(b)、(c)、()<br> ……以此类推ing……</li>
</ol>
</blockquote>
<h5 id="Grouping-sets-…-介绍"><a href="#Grouping-sets-…-介绍" class="headerlink" title="Grouping sets(…) 介绍"></a>Grouping sets(…) 介绍</h5><blockquote>
<p>oracle中，允许在group by后面使用 grouping sets(…) 语句。通过该语句可以实现rollup、cube同样的功能。</p>
<ol>
<li>Group by grouping sets(A ,B) 产生的分组种数：2种；<ul>
<li>第一种：group by A</li>
<li>第二种：group by B</li>
</ul>
</li>
</ol>
<p>返回结果集：为以上两种分组统计结果集的并集且未去掉重复数据。</p>
<ol>
<li>Group by grouping sets (（A ,B）,A) 产生的分组种数：2种；<ul>
<li>第一种：group by A,B,A 等价于group by A,B</li>
<li>第二种：group by A,NULL 等价于group by A</li>
</ul>
</li>
</ol>
<p>返回结果集：为以上二种分组统计结果集的并集且未去掉重复数据。</p>
</blockquote>
]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle存储过程</title>
    <url>/2020/12/03/oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace produce 存储过程名</span><br><span class="line">is</span><br><span class="line">begin</span><br><span class="line">null;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h5 id="oracle中的三种循环结构"><a href="#oracle中的三种循环结构" class="headerlink" title="oracle中的三种循环结构"></a>oracle中的三种循环结构</h5><ol>
<li><p>for循环</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 变量i in  下限..上限(条件判断语句)</span><br><span class="line">loop</span><br><span class="line">  执行语句</span><br><span class="line">end loop;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while循环</p>
<p> <img src="http://wrr123.github.io/2020/12/03/oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/while循环.png" alt></p>
</li>
<li><p>do..while循环</p>
<p> <img src="http://wrr123.github.io/2020/12/03/oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/do-while循环.png" alt></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle新建表空间和用户</title>
    <url>/2020/09/07/oracle%E6%96%B0%E5%BB%BA%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建表空间</span><br><span class="line">create database $&#123;tableSpace&#125;</span><br><span class="line">&#x2F;&#x2F; 指定表空间物理文件位置</span><br><span class="line">datafile &#39;$&#123;path&#x2F;dataFileName&#125;&#39;</span><br><span class="line">&#x2F;&#x2F; 大小</span><br><span class="line">size 50M autoextend on next 5M maxsize unlimited;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user $&#123;user&#125;</span><br><span class="line">identified by $&#123;password&#125;</span><br><span class="line">default tablespace $&#123;tableSpace&#125;</span><br><span class="line">temporary tablespace $&#123;tempSpace&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant connect,resource,dba to $&#123;user&#125;;</span><br><span class="line">grant dba to $&#123;user&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter tablespace $&#123;tableSpace&#125; offline;</span><br><span class="line">drop tablespace $&#123;tableSpace&#125; including contents and datafiles;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle表2java实体类</title>
    <url>/2020/08/04/oracle%E8%A1%A82java%E5%AE%9E%E4%BD%93%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="将oracle中的表转为java实体类"><a href="#将oracle中的表转为java实体类" class="headerlink" title="将oracle中的表转为java实体类"></a>将oracle中的表转为java实体类</h4><ul>
<li>swagger实体类注解<code>@ApiModelProperty</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="built_in">listagg</span>(<span class="string">&#x27;@ApiModelProperty(&quot;&#x27;</span><span class="operator">||</span>t.COMMENTS<span class="operator">||</span><span class="string">&#x27;&quot;)&#x27;</span><span class="operator">||</span>chr(<span class="number">13</span>)<span class="operator">||</span><span class="string">&#x27;private String &#x27;</span><span class="operator">||</span><span class="built_in">lower</span>(t.COLUMN_NAME)<span class="operator">||</span><span class="string">&#x27;;&#x27;</span><span class="operator">||</span>chr(<span class="number">13</span>)<span class="operator">||</span>chr(<span class="number">13</span>), <span class="string">&#x27;&#x27;</span>) <span class="keyword">within</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> t.COLUMN_NAME)</span><br><span class="line"><span class="keyword">from</span> all_col_comments t <span class="keyword">where</span> t.TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;TEMP01&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>​    <u><em>listagg函数可以使用wm_concat函数来替换</em></u></p>
<h4 id="oracle中一些特殊符号的转换"><a href="#oracle中一些特殊符号的转换" class="headerlink" title="oracle中一些特殊符号的转换"></a>oracle中一些特殊符号的转换</h4><div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th>转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>制表符</td>
<td>chr(9)</td>
</tr>
<tr>
<td>换行符</td>
<td>chr(10)</td>
</tr>
<tr>
<td>回车符</td>
<td>chr(13)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="oracle和java的数据类型对应关系"><a href="#oracle和java的数据类型对应关系" class="headerlink" title="oracle和java的数据类型对应关系"></a>oracle和java的数据类型对应关系</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">SQL数据类型</th>
<th style="text-align:left">JDBC类型代码</th>
<th style="text-align:left">标准的Java类型</th>
<th style="text-align:left">Oracle扩展的Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1.0标准的JDBC类型:</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>CHAR</code></td>
<td style="text-align:left"><code>java.sql.Types.CHAR</code></td>
<td style="text-align:left"><code>java.lang.String</code></td>
<td style="text-align:left"><code>oracle.sql.CHAR</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VARCHAR2</code></td>
<td style="text-align:left"><code>java.sql.Types.VARCHAR</code></td>
<td style="text-align:left"><code>java.lang.String</code></td>
<td style="text-align:left"><code>oracle.sql.CHAR</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LONG</code></td>
<td style="text-align:left"><code>java.sql.Types.LONGVARCHAR</code></td>
<td style="text-align:left"><code>java.lang.String</code></td>
<td style="text-align:left"><code>oracle.sql.CHAR</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.NUMERIC</code></td>
<td style="text-align:left"><code>java.math.BigDecimal</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.DECIMAL</code></td>
<td style="text-align:left"><code>java.math.BigDecimal</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.BIT</code></td>
<td style="text-align:left"><code>boolean</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.TINYINT</code></td>
<td style="text-align:left"><code>byte</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.SMALLINT</code></td>
<td style="text-align:left"><code>short</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.INTEGER</code></td>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.BIGINT</code></td>
<td style="text-align:left"><code>long</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.REAL</code></td>
<td style="text-align:left"><code>float</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.FLOAT</code></td>
<td style="text-align:left"><code>double</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NUMBER</code></td>
<td style="text-align:left"><code>java.sql.Types.DOUBLE</code></td>
<td style="text-align:left"><code>double</code></td>
<td style="text-align:left"><code>oracle.sql.NUMBER</code></td>
</tr>
<tr>
<td style="text-align:left"><code>RAW</code></td>
<td style="text-align:left"><code>java.sql.Types.BINARY</code></td>
<td style="text-align:left"><code>byte[]</code></td>
<td style="text-align:left"><code>oracle.sql.RAW</code></td>
</tr>
<tr>
<td style="text-align:left"><code>RAW</code></td>
<td style="text-align:left"><code>java.sql.Types.VARBINARY</code></td>
<td style="text-align:left"><code>byte[]</code></td>
<td style="text-align:left"><code>oracle.sql.RAW</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LONGRAW</code></td>
<td style="text-align:left"><code>java.sql.Types.LONGVARBINARY</code></td>
<td style="text-align:left"><code>byte[]</code></td>
<td style="text-align:left"><code>oracle.sql.RAW</code></td>
</tr>
<tr>
<td style="text-align:left"><code>DATE</code></td>
<td style="text-align:left"><code>java.sql.Types.DATE</code></td>
<td style="text-align:left"><code>java.sql.Date</code></td>
<td style="text-align:left"><code>oracle.sql.DATE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>DATE</code></td>
<td style="text-align:left"><code>java.sql.Types.TIME</code></td>
<td style="text-align:left"><code>java.sql.Time</code></td>
<td style="text-align:left"><code>oracle.sql.DATE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>TIMESTAMP</code></td>
<td style="text-align:left"><code>java.sql.Types.TIMESTAMP</code></td>
<td style="text-align:left"><code>javal.sql.Timestamp</code></td>
<td style="text-align:left"><code>oracle.sql.TIMESTAMP</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">2.0标准的JDBC类型:</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>BLOB</code></td>
<td style="text-align:left"><code>java.sql.Types.BLOB</code></td>
<td style="text-align:left"><code>java.sql.Blob</code></td>
<td style="text-align:left"><code>oracle.sql.BLOB</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CLOB</code></td>
<td style="text-align:left"><code>java.sql.Types.CLOB</code></td>
<td style="text-align:left"><code>java.sql.Clob</code></td>
<td style="text-align:left"><code>oracle.sql.CLOB</code></td>
</tr>
<tr>
<td style="text-align:left">用户定义的对象</td>
<td style="text-align:left"><code>java.sql.Types.STRUCT</code></td>
<td style="text-align:left"><code>java.sql.Struct</code></td>
<td style="text-align:left"><code>oracle.sql.STRUCT</code></td>
</tr>
<tr>
<td style="text-align:left">用户定义的参考</td>
<td style="text-align:left"><code>java.sql.Types.REF</code></td>
<td style="text-align:left"><code>java.sql.Ref</code></td>
<td style="text-align:left"><code>oracle.sql.REF</code></td>
</tr>
<tr>
<td style="text-align:left">用户定义的集合</td>
<td style="text-align:left"><code>java.sql.Types.ARRAY</code></td>
<td style="text-align:left"><code>java.sql.Array</code></td>
<td style="text-align:left"><code>oracle.sql.ARRAY</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">Oracle扩展:</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>BFILE</code></td>
<td style="text-align:left"><code>oracle.jdbc.OracleTypes.BFILE</code></td>
<td style="text-align:left">N/A</td>
<td style="text-align:left"><code>oracle.sql.BFILE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ROWID</code></td>
<td style="text-align:left"><code>oracle.jdbc.OracleTypes.ROWID</code></td>
<td style="text-align:left">N/A</td>
<td style="text-align:left"><code>oracle.sql.ROWID</code></td>
</tr>
<tr>
<td style="text-align:left"><code>REF CURSOR</code></td>
<td style="text-align:left"><code>oracle.jdbc.OracleTypes.CURSOR</code></td>
<td style="text-align:left"><code>java.sql.ResultSet</code></td>
<td style="text-align:left"><code>oracle.jdbc.OracleResultSet</code></td>
</tr>
<tr>
<td style="text-align:left"><code>TIMESTAMP</code></td>
<td style="text-align:left"><code>oracle.jdbc.OracleTypes.TIMESTAMP</code></td>
<td style="text-align:left"><code>java.sql.Timestamp</code></td>
<td style="text-align:left"><code>oracle.sql.TIMESTAMP</code></td>
</tr>
<tr>
<td style="text-align:left"><code>TIMESTAMP WITH TIME ZONE</code></td>
<td style="text-align:left"><code>oracle.jdbc.OracleTypes.TIMESTAMPTZ</code></td>
<td style="text-align:left"><code>java.sql.Timestamp</code></td>
<td style="text-align:left"><code>oracle.sql.TIMESTAMPTZ</code></td>
</tr>
<tr>
<td style="text-align:left"><code>TIMESTAMP WITH LOCAL TIME ZONE</code></td>
<td style="text-align:left"><code>oracle.jdbc.OracleTypes.TIMESTAMPLTZ</code></td>
<td style="text-align:left"><code>java.sql.Timestamp</code></td>
<td style="text-align:left"><code>oracle.sql.TIMESTAMPLTZ</code></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle表字段转成jqGrid的colModel</title>
    <url>/2020/08/04/oracle%E8%A1%A8%E5%AD%97%E6%AE%B5%E8%BD%AC%E6%88%90jqGrid%E7%9A%84colModel/</url>
    <content><![CDATA[<h5 id="利用sql将表中的字段一次性转换成jqGrid的colModel"><a href="#利用sql将表中的字段一次性转换成jqGrid的colModel" class="headerlink" title="利用sql将表中的字段一次性转换成jqGrid的colModel"></a>利用sql将表中的字段一次性转换成jqGrid的colModel</h5><p><u>一个例子</u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="built_in">listagg</span>(<span class="string">&#x27;&#123; label: &#x27;&#x27;&#x27;</span><span class="operator">||</span>t.COMMENTS<span class="operator">||</span><span class="string">&#x27;&#x27;&#x27;, name: &#x27;&#x27;&#x27;</span><span class="operator">||</span><span class="built_in">lower</span>(t.COLUMN_NAME)<span class="operator">||</span><span class="string">&#x27;&#x27;&#x27;, index: &#x27;&#x27;&#x27;</span><span class="operator">||</span><span class="built_in">lower</span>(t.COLUMN_NAME)<span class="operator">||</span><span class="string">&#x27;&#x27;&#x27;, width: 10, align: &#x27;&#x27;center&#x27;&#x27; &#125;,&#x27;</span><span class="operator">||</span>chr(<span class="number">13</span>), <span class="string">&#x27;&#x27;</span>) <span class="keyword">within</span> <span class="keyword">group</span>(<span class="keyword">order</span> <span class="keyword">by</span> t.COLUMN_NAME <span class="keyword">desc</span>)</span><br><span class="line"><span class="keyword">from</span> all_col_comments t <span class="keyword">where</span> t.TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;TEMP01&#x27;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>oracle</tag>
        <tag>jqGrid</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle表连接操作符</title>
    <url>/2020/10/13/oracle%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="多表关联查询"><a href="#多表关联查询" class="headerlink" title="多表关联查询"></a>多表关联查询</h4><h5 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h5><p>交叉连接又称为 “笛卡尔积连接”，是两个或多个表之间的 <strong>无条件连接。</strong> 一个表中的所有记录与其他表的所有的记录进行连接。</p>
<blockquote>
<p>如果进行连接的表中的数据行数分别为“n1，n2、n3”,那么交叉连接后结果集中有n1xn2xn3条记录。</p>
</blockquote>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>内连接是种常用的关联查询方式，使用 <code>inner join</code> 来实现，<strong>其中 inner 是可以省略的</strong></p>
<p>内连接的标准语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> colums_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> table_name1 [<span class="keyword">inner</span>] <span class="keyword">join</span> table_name2</span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> join_codition</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>Oracle 扩展的连接方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column,talbe2.column[,…]</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> table1,table2[,…]</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接分为 <code>左外连接、右外连接和全外连接。</code></p>
<p>左外连接的标准语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column[,…]</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> [<span class="keyword">outer</span>] <span class="keyword">JOIN</span> table2[,]</span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> table1.column <span class="operator">&lt;</span>operator<span class="operator">&gt;</span> table2.column[,…];</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>oracle 扩展的左外连接方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column[,…]</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> table1, table2[,…]</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> table1.column <span class="operator">&lt;</span>operator<span class="operator">&gt;</span> table2.column(<span class="operator">+</span>)[…];</span><br></pre></td></tr></table></figure>
<p>右外连接的的关键字为 <code>right outer join</code>, <code>right join</code></p>
<p>全外连接的关键字为 <code>full outer join, full join</code></p>
<p>备注：</p>
<blockquote>
<ol>
<li>左外连接其实就是：将左边表中的数据全部显示出不无论在其连接表中是否有对应的数据，如果没有与之对应的连接表的值为NULL。</li>
<li>右外连接是：指在内连接的基础上，将连接操作符右侧表中不符合连接条件的记录加入结果集中，与之对应的连接操作符左侧表列用NULL填充。</li>
<li>完全连接是：全外连接：指在内连接的基础上，将连接操作符两侧表中不符合连接条件的记录全部加入结果集中。</li>
</ol>
</blockquote>
<p>
对于（+）操作符：
<ol style="color: red;">
    <li>当使用(+)操作符执行外连接时，应当将该操作符放在显示较少行(完全满足连接条件行)一端。</li>
  <li>(+)操作符只能出现在where子句中，并且不能与outer join语法同时使用。</li>
  <li>当使用(+)操作符执行外连接时，如果在where语句中包含多个条件，则必须在所有的条件中都包含(+)操作符。</li>
  <li>(+)操作符只能适用于列，而不能适用于表达式。</li>
  <li>(+)操作符不能与or和in操作符一起使用。</li>
  <li>(+)操作符只能用于左外连接和右外连接，不能用于实现完全连接。</li>
  <li>(+)所在位置的另一则为连接方向，而且如果后面有条件都要注意(+)位置</li>
</ol>  
</p>

<h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>在应用开发中，用户可能拥有 “自引用式” 的外键，”自引用式” 外键是指表中的一个列可以是该表主键的一个外键。</p>
]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>package.json中包的版本号符号详解</title>
    <url>/2020/07/31/package-json%E4%B8%AD%E5%8C%85%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AC%A6%E5%8F%B7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="在node-js的文件package-json中，版本号前面的符号-和-的含义"><a href="#在node-js的文件package-json中，版本号前面的符号-和-的含义" class="headerlink" title="在node.js的文件package.json中，版本号前面的符号^和~的含义"></a>在node.js的文件package.json中，版本号前面的符号<code>^</code>和<code>~</code>的含义</h4><p>当我们使用最新版的node运行<code>npm install --save XXX</code>时，它会优先考虑使用插入符号(<code>^</code>),而不是使用波浪符号了(<code>~</code>)。</p>
<p>波浪符号(<code>~</code>): 它会更新到当前minor version(也就是中间的那个数据)中最新的版本，</p>
<p>插入符号(<code>^</code>): 它会更新到当前major version(也就是第一个数字)中最新的版本。</p>
<blockquote>
<p>最后解释下之前提到的minor verision和major version：</p>
<p>1.15.2对应就是MAJOR,MINOR.PATCH：1是marjor version；15是minor version；2是patch version。</p>
<p>MAJOR：这个版本号变化了表示有了一个不可以和上个版本兼容的大更改。</p>
<p>MINOR：这个版本号变化了表示有了增加了新的功能，并且可以向后兼容。</p>
<p>PATCH：这个版本号变化了表示修复了bug，并且可以向后兼容。</p>
</blockquote>
<h4 id="添加-package-json-文件中不存在的依赖包"><a href="#添加-package-json-文件中不存在的依赖包" class="headerlink" title="添加 package.json 文件中不存在的依赖包"></a>添加 package.json 文件中不存在的依赖包</h4><h4 id="package-json-和-package-lock-json-两个的区别"><a href="#package-json-和-package-lock-json-两个的区别" class="headerlink" title="package.json 和 package-lock.json 两个的区别"></a>package.json 和 package-lock.json 两个的区别</h4><blockquote>
<p><code>package-lock.json</code> 的作用就是用来保证我们的应用程序依赖之间的关系是一致的，兼容的；适合多人协作开发时保证每个人的依赖版本是一致的。</p>
</blockquote>
<p>当项目中不存在 <code>package-lock.json</code> 文件时，使用 <code>npm install</code> 时会自动生成这个文件。当 <code>package-lock.json</code> 存在时，则会安装文件中指定版本的依赖，并且安装速度会比不存在此文件时块很多。因为 <code>package-lock.json</code> 中已经存在依赖的版本，下载地址和整个 <code>node_modules</code> 的文件结构等信息。</p>
<blockquote>
<p>使用yarn同样也会自动生成package-lock.json文件，但是cnpm不会自动生成，并且也不会读取package-lock.json文件，只根据package.json下载依赖。</p>
</blockquote>
]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>pdman简单使用教程</title>
    <url>/2020/10/09/pdman%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>PDMan 是一款数据库建模工具，国产开源易用。支持常用的 MySql、Oracle 等数据库。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>永远免费使用（<strong> <em> 敲黑板，重点</em> </strong>）（由于一些特殊情况，暂时还不能开源）。</li>
<li>功能简洁，去除晦涩难懂的设置，化繁为简，实用为上，上手非常容易。</li>
<li>Windows，Mac，Linux三个平台均可以使用（<strong> 敲黑板，重点 </strong>）。</li>
<li>自带参考案例，学习容易。新建一个项目，完全不需要做任何配置。</li>
<li>对开发极其友好，可生成各种数据库以及编程语言的模型类。</li>
<li>目前系统默认实现了MySQL,Oracle,Java的代码自动生成，并且带注释。其他类型的数据库或语言，只需要添加相应的“数据库”并设置好相应的doT模板就可以了。</li>
<li>一键自动生成MarkDown格式的数据表结构文档，方便客户交付。</li>
</ol>
<span id="more"></span>
<h4 id="一些功能点"><a href="#一些功能点" class="headerlink" title="一些功能点"></a>一些功能点</h4><h5 id="关系图查看"><a href="#关系图查看" class="headerlink" title="关系图查看"></a>关系图查看</h5><p>如何画出两张表或多张表之间的关系？</p>
<p>直接点击字段前后的圆点来连接两张表之间的两个字段。</p>
<h5 id="属性查看和修改"><a href="#属性查看和修改" class="headerlink" title="属性查看和修改"></a>属性查看和修改</h5><h5 id="给每张表添加默认字段信息"><a href="#给每张表添加默认字段信息" class="headerlink" title="给每张表添加默认字段信息"></a>给每张表添加默认字段信息</h5><p><img src="http://wrr123.github.io/2020/10/09/pdman%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/设置默认字段.png" alt></p>
]]></content>
      <tags>
        <tag>数据库工具</tag>
      </tags>
  </entry>
  <entry>
    <title>prettier基本使用</title>
    <url>/2020/08/14/prettier%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>prettier 是一款强势武断的代码格式化工具，它几乎移除了编辑器本身所有的对代码的操作格式，然后重新显示。就是为了让所有用这套规则的人有完全相同的代码。在团队协作开发的时候，更是体现出它的优势。与 eslint，tslint 等各种格式化工具不同的是，prettier 只关心代码格式化，而不关心语法问题。</p>
<h4 id="使用的两种方式"><a href="#使用的两种方式" class="headerlink" title="使用的两种方式"></a>使用的两种方式</h4><h5 id="使用编辑器的插件"><a href="#使用编辑器的插件" class="headerlink" title="使用编辑器的插件"></a>使用编辑器的插件</h5><p>使用编辑器插件是最为方便的一种方法，编写完代码，只需要一键即可格式化编写的代码，非常的方便。</p>
<p>这是一个 vscode 的栗子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使能每一种语言默认格式化规则</span></span><br><span class="line">    <span class="attr">&quot;[html]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;[css]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;[less]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;[javascript]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  prettier的配置 */</span></span><br><span class="line">    <span class="attr">&quot;prettier.printWidth&quot;</span>: <span class="number">100</span>, <span class="comment">// 超过最大值换行</span></span><br><span class="line">    <span class="attr">&quot;prettier.tabWidth&quot;</span>: <span class="number">4</span>, <span class="comment">// 缩进字节数</span></span><br><span class="line">    <span class="attr">&quot;prettier.useTabs&quot;</span>: <span class="literal">false</span>, <span class="comment">// 缩进不使用tab，使用空格</span></span><br><span class="line">    <span class="attr">&quot;prettier.semi&quot;</span>: <span class="literal">true</span>, <span class="comment">// 句尾添加分号</span></span><br><span class="line">    <span class="attr">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>, <span class="comment">// 使用单引号代替双引号</span></span><br><span class="line">    <span class="attr">&quot;prettier.proseWrap&quot;</span>: <span class="string">&quot;preserve&quot;</span>, <span class="comment">// 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行</span></span><br><span class="line">    <span class="attr">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>, <span class="comment">//  (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号</span></span><br><span class="line">    <span class="attr">&quot;prettier.bracketSpacing&quot;</span>: <span class="literal">true</span>, <span class="comment">// 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot;</span></span><br><span class="line">    <span class="attr">&quot;prettier.disableLanguages&quot;</span>: [<span class="string">&quot;vue&quot;</span>], <span class="comment">// 不格式化vue文件，vue文件的格式化单独设置</span></span><br><span class="line">    <span class="attr">&quot;prettier.endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span>, <span class="comment">// 结尾是 \n \r \n\r auto</span></span><br><span class="line">    <span class="attr">&quot;prettier.eslintIntegration&quot;</span>: <span class="literal">false</span>, <span class="comment">//不让prettier使用eslint的代码格式进行校验</span></span><br><span class="line">    <span class="attr">&quot;prettier.htmlWhitespaceSensitivity&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;prettier.ignorePath&quot;</span>: <span class="string">&quot;.prettierignore&quot;</span>, <span class="comment">// 不使用prettier格式化的文件填写在项目的.prettierignore文件中</span></span><br><span class="line">    <span class="attr">&quot;prettier.jsxBracketSameLine&quot;</span>: <span class="literal">false</span>, <span class="comment">// 在jsx中把&#x27;&gt;&#x27; 是否单独放一行</span></span><br><span class="line">    <span class="attr">&quot;prettier.jsxSingleQuote&quot;</span>: <span class="literal">false</span>, <span class="comment">// 在jsx中使用单引号代替双引号</span></span><br><span class="line">    <span class="attr">&quot;prettier.parser&quot;</span>: <span class="string">&quot;babylon&quot;</span>, <span class="comment">// 格式化的解析器，默认是babylon</span></span><br><span class="line">    <span class="attr">&quot;prettier.requireConfig&quot;</span>: <span class="literal">false</span>, <span class="comment">// Require a &#x27;prettierconfig&#x27; to format prettier</span></span><br><span class="line">    <span class="attr">&quot;prettier.stylelintIntegration&quot;</span>: <span class="literal">false</span>, <span class="comment">//不让prettier使用stylelint的代码格式进行校验</span></span><br><span class="line">    <span class="attr">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;es5&quot;</span>, <span class="comment">// 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号）</span></span><br><span class="line">    <span class="attr">&quot;prettier.tslintIntegration&quot;</span>: <span class="literal">false</span> <span class="comment">// 不让prettier使用tslint的代码格式进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="如何使用-prettier-来格式化-vue-的代码"><a href="#如何使用-prettier-来格式化-vue-的代码" class="headerlink" title="如何使用 prettier 来格式化 vue 的代码"></a>如何使用 prettier 来格式化 vue 的代码</h6><p>在配置文件中加入下面的话，prettier 是不生效的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;[vue]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>但是可以使用 Vetur 插件，Vetur 默认是使用 prettier 进行格式化的，不过 Vetur 的默认格式配置与我们期望的是有所出入的</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vetur.format.defaultFormatter.js&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vetur.format.defaultFormatter.less&quot;</span>: <span class="string">&quot;prettier&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;printWidth&quot;</span>: <span class="number">160</span>,</span><br><span class="line">            <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span>, <span class="comment">// 使用单引号</span></span><br><span class="line">            <span class="attr">&quot;semi&quot;</span>: <span class="literal">true</span>, <span class="comment">// 末尾使用分号</span></span><br><span class="line">            <span class="attr">&quot;tabWidth&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">&quot;arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;bracketSpacing&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;proseWrap&quot;</span>: <span class="string">&quot;preserve&quot;</span> <span class="comment">// 代码超出是否要换行 preserve保留</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用脚本的方式"><a href="#使用脚本的方式" class="headerlink" title="使用脚本的方式"></a>使用脚本的方式</h5><blockquote>
<p>这种方式就是使用prettier指令在命令行窗口对单一文件进行格式化。 首先需要安装prettier全局指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g prettier</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>prettier -v</code> 检查是否安装完成。</p>
<p>安装好之后，使用下面指令对xxx.js文件进行格式化（使用的是prettier默认的配置规则）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// //prettier--write &lt;文件路劲+文件名&gt;</span><br><span class="line"></span><br><span class="line">prettier --write ./xxx.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>当然，默认的配置规则是不符合我们的需求的，我们需要自定义配置规则。 书写自定义规则的文件需要是下面几种文件和格式：</p>
<ul>
<li>.prettierrc 文件，支持yaml和json格式；或者加上 .yaml/.yml/.json 后缀名</li>
<li>.prettierrc.toml 文件（当为toml格式的时候，后缀是必须的）</li>
<li>prettier.config.js 或者 .prettierrc.js，需要返回一个对象</li>
<li>package.json文件中加上”prettier”属性</li>
</ul>
<p>每种文件的书写格式如下： <strong>JSON</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;tabWidth&quot;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>JS</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prettier.config.js or .prettierrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  trailingComma: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">  tabWidth: <span class="number">4</span>,</span><br><span class="line">  semi: <span class="literal">false</span>,</span><br><span class="line">  singleQuote: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>YAML</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .prettierrc or .prettierrc.yaml</span></span><br><span class="line"><span class="attr">trailingComma:</span> <span class="string">&quot;es5&quot;</span></span><br><span class="line"><span class="attr">tabWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">semi:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">singleQuote:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">复制代码</span></span><br></pre></td></tr></table></figure>
<p><strong>TOML</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .prettierrc.toml</span></span><br><span class="line"><span class="attr">trailingComma</span> = <span class="string">&quot;es5&quot;</span></span><br><span class="line"><span class="attr">tabWidth</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">semi</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">singleQuote</span> = <span class="literal">true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>prettier 查找配置的方式首先会找当前目录下，使用以下指令格式化代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//prettier --config --write &lt;文件路劲+文件名&gt;</span><br><span class="line"></span><br><span class="line"> prettier --config --write ./xxx,js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如果prettier在当前目录找不到配置文件，会一直向上级目录查找，直到找到或找不到。如果我们配置文件放在别的地方，则需要手工指定配置文件的路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// prettier --config &lt;配置文件路径+文件名&gt; --write &lt;文件路劲+文件名&gt;</span><br><span class="line"></span><br><span class="line">prettier --config ./prettier/.prettierrc --write ./xxx.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如果觉得每次格式化一个文件比较麻烦，可以使用下面的指令，一次格式化所有文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">prettier --config ./prettier/.prettierrc --write <span class="string">&#x27;./*.&#123;ts,js,css,json&#125;&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>我们一般使用这种方式的时候，就把这个配置文件写在项目根路径下，然后使用命令行一次性格式化项目下的所有文件。</p>
</blockquote>
<h5 id="上述两种方式的对比"><a href="#上述两种方式的对比" class="headerlink" title="上述两种方式的对比"></a>上述两种方式的对比</h5><blockquote>
<p>上面两种方式各有优劣，我们来分析一下各自的使用场景和一些问题：</p>
<p><strong>第一种方式其实适合个人开发，第二种方式适合团队开发。</strong></p>
<p>至于为什么这么说，就要考虑到二者的优先级问题了。上面两种方式如果同时存在的话，会有优先级的问题。 <strong>.prettierrc 的优先级会高于在vscode全局配置settings.json中格式化配置的优先级</strong></p>
<p>也就是说，如果你在一个项目中有 .prettierrc 配置文件，然后你又在settings.json也配置了格式化规则，那么当你在vscode编辑器中对一个文件点击鼠标右键[格式化文档]的时候，格式化规则会以 .prettierrc 为准。</p>
<p>所以，由于编辑器settings.json每个人的设置可能都不一样，要求每个人统一设置也不方便操作，而嵌入在项目中的配置文件则可以随着项目到达各个开发者，而且会覆盖每个开发者的不同代码喜好，真正做到团队代码统一的效果。</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>格式化工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2020/10/30/python/</url>
    <content><![CDATA[<h4 id="guide"><a href="#guide" class="headerlink" title="guide"></a>guide</h4><h4 id="语言进阶"><a href="#语言进阶" class="headerlink" title="语言进阶"></a>语言进阶</h4><h5 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h5><ul>
<li>算法：解决问题的方法和步骤</li>
<li>评价算法的好坏：渐进时间复杂度和渐进空间复杂度</li>
<li>排序算法（冒泡、选择和归并(分治法)）和查找算法（顺序和折半）</li>
</ul>
<p><strong>lambda函数</strong></p>
<p>匿名函数lambda：是指一类无需定义标识符（函数名）的函数或子程序。所谓匿名函数，通俗的说就是没有名字的函数，lambda函数没有名字，是一种 <strong>简单、在同一行中定义函数的</strong> 方式。</p>
<p>lambda函数可以接收任意多个参数（包括可选参数）并且返回单个表达式的值。</p>
<p><strong>lambda函数只允许包含一个表达式，不能包含复杂语句，该表示式的运算结果就是函数的返回结果。</strong></p>
<p>lambda函数基本的基本语法：<strong>lambda args1, args2, args3,…..: &lt;表达式&gt;</strong></p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lambda x, y: x + y</span><br><span class="line">lambda:None # 函数没有输入参数，输出为 None</span><br><span class="line">lambda *args: sum(args) # 输入任意多个参数，输出是它们的和</span><br><span class="line">lambda **kargs: 1 # 输入任意多个键值对参数，输出为 1</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>常用算法</strong></p>
<ul>
<li>穷举法 - 又称为暴力破解法，对所有的可能性进行验证，知道找出正确答案</li>
<li>贪婪法 - 在对问题求解时，总是做出在当前看来</li>
<li>最好的选择，不求最优解，快速找到满意解。</li>
<li>分治法 - 把一个复杂的问题分成两个或更多的相同或相似的问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</li>
<li>回溯法 - 回溯法又称为试探法，按优先条件向前搜索，当搜索到某一步发现原先选择并不优或者达不到目标时，就退回一步重新选择。</li>
<li>动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</li>
</ul>
<p><strong>self 关键字的用法</strong></p>
<p>与普通的函数不同，在类中定义的函数，<strong>第一参数永远是类的本身实例变量<code>self</code></strong>,并且调用时，不用传递该参数。除此以外，类的方法（函数）和普通函数没有什么区别，你既可以用默认参数，也可以用可变参数与关键字参数（<strong>可变参数接收的是一个元组tuple，关键字接收的是一个字典。</strong>）</p>
<p>注意点：</p>
<ul>
<li><code>self</code> 代表类的实例，而非类。</li>
<li><code>self</code> 在定义时不可以省略。</li>
<li>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了 <code>self</code> 的类的实例。</li>
<li>在描述符类中，<code>self</code> 指的是描述符类的实例。</li>
</ul>
<p><strong>推导式 生成式</strong></p>
<ol>
<li><p>三元表达式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;&#39;abc&#39;</span><br><span class="line">res&#x3D;&#39;SB&#39; if name&#x3D;&#x3D;&#39;abc&#39; else &#39;NB&#39;</span><br><span class="line">print(res)#SB</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表推导式</p>
<p> 公式：[变量（加工后的变量）for 变量i in 可迭代的数据类型]</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求10以内所有的整数（不包括0）</span></span><br><span class="line">list1=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">print(list1)<span class="comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字典推导式</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将一个字典的key和value对调</span></span><br><span class="line">dict1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">20</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">30</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">40</span>&#125;</span><br><span class="line">swapDict=&#123;dict1[k]: k <span class="keyword">for</span> k <span class="keyword">in</span> dict1&#125;</span><br><span class="line">print(swapDict)<span class="comment">#&#123;10: &#x27;a&#x27;, 20: &#x27;b&#x27;, 30: &#x27;c&#x27;, 40: &#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>集合推导式</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将列表中的每个元素平方并去重</span></span><br><span class="line">squared=&#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>]&#125;</span><br><span class="line">print(squared)<span class="comment">#&#123;1,4&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器表达式</p>
<p> 把列表解析的[]换成（）得到的就是生成器表达式</p>
<p> 列表解析与生成器表达式都是一种便利的编程方式，只不过生成器表达式更节省内存</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)]</span><br><span class="line">obj=(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line">print(obj)<span class="comment">#&lt;generator object &lt;genexpr&gt; at 0x00000000021DF678&gt;</span></span><br><span class="line">print(<span class="built_in">list</span>(obj))<span class="comment">#[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="函数的使用方式"><a href="#函数的使用方式" class="headerlink" title="函数的使用方式"></a>函数的使用方式</h5><p><img src="http://wrr123.github.io/2020/10/30/python/函数的使用方式.png" alt></p>
<ul>
<li>将函数视为 “一等公民”<ul>
<li>函数可以赋值给变量</li>
<li>函数可以作为函数的参数</li>
<li>函数可以作为函数的返回值</li>
</ul>
</li>
<li>高阶函数的用法（<code>filter</code>、<code>map</code>以及它们的替代品）</li>
<li>位置参数、可变参数、关键字参数、命名关键字参数</li>
<li>参数的元信息（代码可读性问题）</li>
<li>匿名函数和内联函数的用法（<code>lambda</code>函数）</li>
<li>闭包和作用域的问题</li>
<li>装饰器函数（使用装饰器和取消装饰器）</li>
</ul>
<h6 id="with-关键字的使用"><a href="#with-关键字的使用" class="headerlink" title="with 关键字的使用"></a>with 关键字的使用</h6><p>with表达式其实就是<code>try-finally</code>的简写形式，但又不是完全相同。</p>
<p>格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">格式</span></span><br><span class="line"><span class="string">with context [as var]:</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中的context是一个表达式，返回的是一个对象，var用来保存context表达式返回的对象，可以有单个或者多个返回值。</p>
</blockquote>
<h5 id="面向对象相关知识"><a href="#面向对象相关知识" class="headerlink" title="面向对象相关知识"></a>面向对象相关知识</h5><p><img src="http://wrr123.github.io/2020/10/30/python/面向对象相关知识.png" alt></p>
<h5 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h5><h5 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h5><h4 id="Web前端概述"><a href="#Web前端概述" class="headerlink" title="Web前端概述"></a>Web前端概述</h4>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>quill富文本编辑器</title>
    <url>/2020/08/14/quill%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>Quill 是一个很流行的富文本编辑器，</p>
<p>github：<a href="https://github.com/quilljs/quill/">https://github.com/quilljs/quill/</a></p>
<p>官网：<a href="https://quilljs.com">官网</a></p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- Include stylesheet --&gt;</span><br><span class="line">&lt;link href=<span class="string">&quot;https://cdn.quilljs.com/1.3.6/quill.snow.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- Create the editor container --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;editor&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Hello World!&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Some initial &lt;strong&gt;bold&lt;<span class="regexp">/strong&gt; text&lt;/</span>p&gt;</span><br><span class="line">  &lt;p&gt;&lt;br&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- Include the Quill library --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.quilljs.com/1.3.6/quill.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- Initialize Quill editor --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> quill = <span class="keyword">new</span> Quill(<span class="string">&#x27;#editor&#x27;</span>, &#123;</span><br><span class="line">    theme: <span class="string">&#x27;snow&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>vue 中使用：</p>
<p><code>npm install quill@1.3.6</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;editor&quot;&gt;</span><br><span class="line">      &lt;p&gt;Hello World!&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;Some initial &lt;strong&gt;bold&lt;&#x2F;strong&gt; text&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;&lt;br&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Quill from &#39;quill&#39;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;QuillEditor&quot;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.initQuill()</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    this.quill &#x3D; null</span><br><span class="line">    delete this.quill</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    initQuill () &#123;</span><br><span class="line">      const quill &#x3D; new Quill(&#39;#editor&#39;, &#123;</span><br><span class="line">        theme: &#39;snow&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">      this.quill &#x3D; quill</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建Quill实例需要两个参数，container与options</p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>container可以是css选择器，也可以是DOM对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> editor = <span class="string">``</span><span class="keyword">new</span><span class="string">` `</span>Quill(<span class="string">``</span><span class="string">&#x27;#editor&#x27;</span><span class="string">``</span>)</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">``</span><span class="string">&#x27;editor&#x27;</span><span class="string">``</span>);<span class="string">``</span><span class="keyword">const</span> editor = <span class="string">``</span><span class="keyword">new</span><span class="string">` `</span>Quill(container);</span><br></pre></td></tr></table></figure>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>包括theme、formats、modules等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;<span class="string">``</span> <span class="string">``</span>debug: <span class="string">``</span><span class="string">&#x27;info&#x27;</span><span class="string">``</span>,<span class="string">``</span> <span class="string">``</span>modules: &#123;<span class="string">``</span>  <span class="string">``</span>toolbar: <span class="string">``</span><span class="string">&#x27;#toolbar&#x27;</span><span class="string">``</span> <span class="string">``</span>&#125;,<span class="string">``</span> <span class="string">``</span>placeholder: <span class="string">``</span><span class="string">&#x27;Compose an epic...&#x27;</span><span class="string">``</span>,<span class="string">``</span> <span class="string">``</span>readOnly: <span class="string">``</span><span class="literal">true</span><span class="string">``</span>,<span class="string">``</span> <span class="string">``</span>theme: <span class="string">``</span><span class="string">&#x27;snow&#x27;</span><span class="string">``</span>&#125;;<span class="string">``</span><span class="keyword">const</span> editor = <span class="string">``</span><span class="keyword">new</span><span class="string">` `</span>Quill(<span class="string">``</span><span class="string">&#x27;#editor&#x27;</span><span class="string">``</span>, options);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="获取与显示编辑内容"><a href="#获取与显示编辑内容" class="headerlink" title="获取与显示编辑内容"></a>获取与显示编辑内容</h5><p>富文本编辑器的主要作用是编辑文本、保存、显示等。</p>
<p>获取编辑完成的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="built_in">document</span>.querySelector(<span class="string">``</span><span class="string">&#x27;#editor&#x27;</span><span class="string">``</span>).children[<span class="number">0</span>].innerHTML<span class="string">``</span><span class="built_in">console</span>.log(html)</span><br></pre></td></tr></table></figure>
<p>内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Hello World!Some initial bold text </span><br></pre></td></tr></table></figure>
<p>获取内容后置于编辑器中显示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="built_in">document</span>.querySelector(<span class="string">``</span><span class="string">&#x27;#editor&#x27;</span><span class="string">``</span>).children[<span class="number">0</span>].innerHTML<span class="string">``</span><span class="built_in">this</span><span class="string">``</span>.quill.pasteHTML(<span class="string">``</span><span class="string">&#x27;add some title&#x27;</span><span class="string">` `</span>+ html)</span><br></pre></td></tr></table></figure>
<h5 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h5><p>编辑器上方一栏可以设置文本格式部分，即为modules中的toolbar，可以使用默认值，也可以定制。</p>
<p>使用数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toolbarOptions = [<span class="string">``</span><span class="string">&#x27;bold&#x27;</span><span class="string">``</span>, <span class="string">``</span><span class="string">&#x27;italic&#x27;</span><span class="string">``</span>, <span class="string">``</span><span class="string">&#x27;underline&#x27;</span><span class="string">``</span>, <span class="string">``</span><span class="string">&#x27;strike&#x27;</span><span class="string">``</span>];<span class="string">` `</span><span class="keyword">const</span> quill = <span class="string">``</span><span class="keyword">new</span><span class="string">` `</span>Quill(<span class="string">``</span><span class="string">&#x27;#editor&#x27;</span><span class="string">``</span>, &#123;<span class="string">``</span> <span class="string">``</span>modules: &#123;<span class="string">``</span>  <span class="string">``</span>toolbar: toolbarOptions<span class="string">``</span> <span class="string">``</span>&#125;<span class="string">``</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>也可以分组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toolbarOptions = [</span><br><span class="line">  [<span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;italic&#x27;</span>, <span class="string">&#x27;underline&#x27;</span>, <span class="string">&#x27;strike&#x27;</span>],        <span class="comment">// toggled buttons</span></span><br><span class="line">  [<span class="string">&#x27;blockquote&#x27;</span>, <span class="string">&#x27;code-block&#x27;</span>],</span><br><span class="line"> </span><br><span class="line">  [&#123; <span class="string">&#x27;header&#x27;</span>: <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;header&#x27;</span>: <span class="number">2</span> &#125;],               <span class="comment">// custom button values</span></span><br><span class="line">  [&#123; <span class="string">&#x27;list&#x27;</span>: <span class="string">&#x27;ordered&#x27;</span>&#125;, &#123; <span class="string">&#x27;list&#x27;</span>: <span class="string">&#x27;bullet&#x27;</span> &#125;],</span><br><span class="line">  [&#123; <span class="string">&#x27;script&#x27;</span>: <span class="string">&#x27;sub&#x27;</span>&#125;, &#123; <span class="string">&#x27;script&#x27;</span>: <span class="string">&#x27;super&#x27;</span> &#125;],      <span class="comment">// superscript/subscript</span></span><br><span class="line">  [&#123; <span class="string">&#x27;indent&#x27;</span>: <span class="string">&#x27;-1&#x27;</span>&#125;, &#123; <span class="string">&#x27;indent&#x27;</span>: <span class="string">&#x27;+1&#x27;</span> &#125;],          <span class="comment">// outdent/indent</span></span><br><span class="line">  [&#123; <span class="string">&#x27;direction&#x27;</span>: <span class="string">&#x27;rtl&#x27;</span> &#125;],                         <span class="comment">// text direction</span></span><br><span class="line"> </span><br><span class="line">  [&#123; <span class="string">&#x27;size&#x27;</span>: [<span class="string">&#x27;small&#x27;</span>, <span class="literal">false</span>, <span class="string">&#x27;large&#x27;</span>, <span class="string">&#x27;huge&#x27;</span>] &#125;],  <span class="comment">// custom dropdown</span></span><br><span class="line">  [&#123; <span class="string">&#x27;header&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="literal">false</span>] &#125;],</span><br><span class="line"> </span><br><span class="line">  [&#123; <span class="string">&#x27;color&#x27;</span>: [] &#125;, &#123; <span class="string">&#x27;background&#x27;</span>: [] &#125;],          <span class="comment">// dropdown with defaults from theme</span></span><br><span class="line">  [&#123; <span class="string">&#x27;font&#x27;</span>: [] &#125;],</span><br><span class="line">  [&#123; <span class="string">&#x27;align&#x27;</span>: [] &#125;],</span><br><span class="line"> </span><br><span class="line">  [<span class="string">&#x27;clean&#x27;</span>]                                         <span class="comment">// remove formatting button</span></span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> quill = <span class="keyword">new</span> Quill(<span class="string">&#x27;#editor&#x27;</span>, &#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    toolbar: toolbarOptions</span><br><span class="line">  &#125;,</span><br><span class="line">  theme: <span class="string">&#x27;snow&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>response响应对象详解</title>
    <url>/2020/07/03/response%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="对象介绍"><a href="#对象介绍" class="headerlink" title="对象介绍"></a>对象介绍</h4><ol>
<li><p>负责向客户端（浏览器）发送数据的相关方法</p>
<ol>
<li>getOutputStream()</li>
<li>getWriter()</li>
</ol>
</li>
<li><p>负责向客户端（浏览器）发送响应头的相关方法</p>
<p><img src="http://wrr123.github.io/2020/07/03/response%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/11.png" alt></p>
</li>
<li><p>负责向客户端（浏览器）发送响应状态码的相关方法</p>
<p><img src="http://wrr123.github.io/2020/07/03/response%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/22.png" alt></p>
</li>
<li><p>响应状态码的常量</p>
<p><img src="http://wrr123.github.io/2020/07/03/response%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/33.png" alt></p>
</li>
</ol>
<h4 id="对象常见应用"><a href="#对象常见应用" class="headerlink" title="对象常见应用"></a>对象常见应用</h4><ol>
<li><h5 id="使用OutputStream流向客户端输出中文数据"><a href="#使用OutputStream流向客户端输出中文数据" class="headerlink" title="使用OutputStream流向客户端输出中文数据"></a>使用OutputStream流向客户端输出中文数据</h5></li>
<li><h5 id="使用PrintWriter流向客户端输出中文数据"><a href="#使用PrintWriter流向客户端输出中文数据" class="headerlink" title="使用PrintWriter流向客户端输出中文数据"></a>使用PrintWriter流向客户端输出中文数据</h5></li>
<li><h5 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h5><p>基本实现思路：</p>
<ol>
<li>获取要下载的文件的绝对路径</li>
<li>获取要下载的文件名</li>
<li>设置<code>content-disposition</code>响应头控制浏览器以下载的形式打开文件</li>
<li>获取要下载的文件输入流</li>
<li>创建数据缓冲区</li>
<li>通过<code>response</code>对象获取<code>OutputStream</code>流</li>
<li>将FileInputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区的数据输出到客户端(浏览器)</li>
</ol>
<p><strong>在编写下载功能时，要使用OutputStream流，避免使用PrintWriter流，因为OutputStream流是字节流，可以处理任意类型的数据，而PrintWriter流是字符流，只能处理字符数据，如果用字符流处理字节流，会导致数据丢失。</strong></p>
</li>
</ol>
<h4 id="主要功能介绍"><a href="#主要功能介绍" class="headerlink" title="主要功能介绍"></a>主要功能介绍</h4><ol>
<li><p>设置响应头信息</p>
<p><code>addHeader(“reFresh”, “5;URL=xxxx”);</code></p>
</li>
<li><p>发送状态码</p>
<p><code>sendError(404);</code></p>
</li>
<li><p>设置响应正文</p>
<p><code>getWriter().print(“fdsfdsa”);</code></p>
</li>
<li><p>重定向</p>
<p><code>sendRedirect(“path”);</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>rrs入门</title>
    <url>/2021/03/10/rrs%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="检查一个网站是否含有rss链接"><a href="#检查一个网站是否含有rss链接" class="headerlink" title="检查一个网站是否含有rss链接"></a>检查一个网站是否含有rss链接</h4><p>在网址后面添加如下内容</p>
<ul>
<li><code>/rss</code></li>
<li><code>/feed</code></li>
<li><code>/atom.xml</code></li>
</ul>
<span id="more"></span>
]]></content>
      <tags>
        <tag>rss</tag>
      </tags>
  </entry>
  <entry>
    <title>sentinel-apollo</title>
    <url>/2021/03/29/sentinel-apollo/</url>
    <content><![CDATA[<p>Apollo是国内用的非常多的配置中心，现在我们来讨论下，Sentinel如何将限流规则存储在Apollo中。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>sentinel-nacos</title>
    <url>/2021/03/29/sentinel-nacos/</url>
    <content><![CDATA[<p>sentinel的限流规则的持久化问题。</p>
<p>实际上，现在我们在sentinel dashboard上设置的限流规则在应用重启之后就会丢失，那么我们该如何来持久化我们的限流规则呢？</p>
<span id="more"></span>
<h4 id="使用Nacos存储限流规则"><a href="#使用Nacos存储限流规则" class="headerlink" title="使用Nacos存储限流规则"></a>使用Nacos存储限流规则</h4><p>Sentinel目前本身支持了多种不同的数据源来持久化规则配置，如</p>
<ul>
<li>文件配置</li>
<li>Nacos配置</li>
<li>ZooKeeper配置</li>
<li>Apollo配置</li>
</ul>
<p>我们现在重点来看下 <strong>Nacos配置。</strong></p>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p>先启动好Nacos和Sentinel Dashboard。</p>
<h5 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h5><ol>
<li><p>引入jar包</p>
</li>
<li><p>配置信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">alibaba-sentinel-datasource-nacos</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8003</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel dashboard</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.transport.dashboard</span>=<span class="string">localhost:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel datasource nacos ：http://blog.didispace.com/spring-cloud-alibaba-sentinel-2-1/</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.server-addr</span>=<span class="string">localhost:8848</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.dataId</span>=<span class="string">$&#123;spring.application.name&#125;-sentinel</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.groupId</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.sentinel.datasource.ds.nacos.rule-type</span>=<span class="string">flow</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建主类和一个测试用的rest接口</p>
</li>
<li><p>Nacos中创建限流规则的配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;/hello&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;grade&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;count&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;strategy&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;controlBehavior&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;clusterMode&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动应用，并进行验证。</p>
</li>
</ol>
<h4 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h4><p>在经过上面的整合之后，对限流规则的修改就存在两个地方了：<code>Sentinel控制台</code>，<code>Nacos控制台</code>。</p>
<blockquote>
<ul>
<li>Sentinel控制台中修改规则：仅存在于服务的内存中，不会修改Nacos中的配置值，重启后恢复原来的值。</li>
<li>Nacos控制台中修改规则：服务的内存中规则会更新，Nacos中持久化规则也会更新，重启后依然保持。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>sentinel修改规则持久化</title>
    <url>/2021/03/29/sentinel%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>以前我们只能通过Nacos或者Apollo界面修改限流规则才能得到持久化存储，而在Sentinel Dashboard界面修改限流规则，虽然能够生效，但是不能持久化存储。</p>
<span id="more"></span>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>下图是之前实现的限流规则持久化方案的配置数据流向图：</p>
<p><img src="http://wrr123.github.io/2021/03/29/sentinel%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/001.png" alt></p>
<ul>
<li>蓝色箭头 代表了限流规则由 <strong>配置中心</strong> 发起修改的更新路径</li>
<li>橙色箭头 代表了限流规则由 <strong>Sentinel Dashboard</strong> 发起修改的更新路径</li>
</ul>
<blockquote>
<p>从图中可以很明显的看到，<code>Sentinel Dashboard</code>与业务服务之间本身是可以互通获取最新限流规则的，这在没有整合配置中心来存储限流规则的时候就已经存在这样的机制。最主要的区别是：配置中心的修改都可以实时的刷新到业务服务，从而被<code>Sentinel Dashboard</code>读取到，但是对于这些规则的更新到达各个业务服务之后，并没有一个机制去同步到配置中心，作为配置中心的客户端也不会提供这样的逆向更新方法。</p>
</blockquote>
<h4 id="Sentinel-Dashboard中修改规则同步到Apollo"><a href="#Sentinel-Dashboard中修改规则同步到Apollo" class="headerlink" title="Sentinel Dashboard中修改规则同步到Apollo"></a>Sentinel Dashboard中修改规则同步到Apollo</h4><h4 id="Sentinel-Dashboard中修改规则同步到Nacos"><a href="#Sentinel-Dashboard中修改规则同步到Nacos" class="headerlink" title="Sentinel Dashboard中修改规则同步到Nacos"></a>Sentinel Dashboard中修改规则同步到Nacos</h4><h4 id="SentinelResource注解使用详解"><a href="#SentinelResource注解使用详解" class="headerlink" title="@SentinelResource注解使用详解"></a>@SentinelResource注解使用详解</h4><p>在实际的应用中，我们可能需要限流的层面不仅限于接口，可能 <strong>对于某个方法的调用限流，对于某个外部资源的调用限流等都希望控制。</strong></p>
<h5 id="自定义资源点"><a href="#自定义资源点" class="headerlink" title="自定义资源点"></a>自定义资源点</h5><ol>
<li>在应用主类上加上注解支持的配置</li>
<li>在需要通过Sentinel来控制流量的地方使用 <code>@SentinelResource</code> 注解</li>
</ol>
<h5 id="如何实现限流和熔断降级"><a href="#如何实现限流和熔断降级" class="headerlink" title="如何实现限流和熔断降级"></a>如何实现限流和熔断降级</h5><h6 id="实现限流控制"><a href="#实现限流控制" class="headerlink" title="实现限流控制"></a>实现限流控制</h6><ol>
<li>在web层调用这个被保护的方法</li>
<li>启动应用，启动sentinel dashboard。发送几个请求到接口上，你会发现sentinel控制台上多出了你设置的资源点名称。</li>
</ol>
<h6 id="实现限流的异常处理"><a href="#实现限流的异常处理" class="headerlink" title="实现限流的异常处理"></a>实现限流的异常处理</h6><h6 id="实现熔断降级"><a href="#实现熔断降级" class="headerlink" title="实现熔断降级"></a>实现熔断降级</h6><h6 id="熔断的降级处理"><a href="#熔断的降级处理" class="headerlink" title="熔断的降级处理"></a>熔断的降级处理</h6>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet-how2j</title>
    <url>/2021/03/14/servlet-how2j/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Servlet本身不能独立运行，需要在一个web应用中运行的，而一个web应用是部署在tomcat中的。</p>
<h5 id="开发一个servlet的步骤"><a href="#开发一个servlet的步骤" class="headerlink" title="开发一个servlet的步骤"></a>开发一个servlet的步骤</h5><ol>
<li>创建web应用程序</li>
<li>编写servlet代码</li>
<li>部署到tomcat中</li>
</ol>
<span id="more"></span>
<h5 id="具体的开发一个servlet应用"><a href="#具体的开发一个servlet应用" class="headerlink" title="具体的开发一个servlet应用"></a>具体的开发一个servlet应用</h5><ol>
<li><p>创建一个java项目</p>
</li>
<li><p>导入必须的servlet-api.jar包</p>
</li>
<li><p>编写HelloServlet，使其继承类<code>javax.servlet.http.HttpServlet</code></p>
</li>
<li><p>配置web.xml文件</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在开发工具内配置tomcat或其他中间件。</p>
</li>
</ol>
<h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><h4 id="返回响应"><a href="#返回响应" class="headerlink" title="返回响应"></a>返回响应</h4><h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><p><img src="http://wrr123.github.io/2021/03/14/servlet-how2j/001.png" alt></p>
<h4 id="service"><a href="#service" class="headerlink" title="service()"></a>service()</h4><ul>
<li>doGet()</li>
<li>doPost()</li>
<li>service()</li>
</ul>
<h4 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h4><h5 id="获取中文的参数"><a href="#获取中文的参数" class="headerlink" title="获取中文的参数"></a>获取中文的参数</h5><ul>
<li><p>在html文件中加上编码</p>
<p>  <code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code></p>
</li>
<li><p>在servlet中进行编码和解码</p>
</li>
<li><p>直接使用request进行设置</p>
<p>  <code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></p>
</li>
</ul>
<p>返回中文的响应</p>
<p>在Servlet中加上，<code>response.setContentType(&quot;text/html; charset=UTF-8&quot;);</code></p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>一个servlet的生命周期：</p>
<ol>
<li>实例化</li>
<li>初始化</li>
<li>提供服务</li>
<li>销毁</li>
<li>被回收</li>
</ol>
<h4 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h4><p>页面跳转是开发一个web应用经常会发生的事情。</p>
<p>跳转的方式：</p>
<ul>
<li><p>服务端跳转</p>
<p>  <code>request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);</code></p>
</li>
<li><p>客户端跳转</p>
<p>  <code>response.sendRedirect(&quot;fail.html&quot;);</code></p>
</li>
</ul>
<h4 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h4><p>servlet的自启动，即是，伴随着tomcat的启动，自动启动初始化，在初始化方法<code>init()</code>中，就可以进行一些业务代码的工作了。</p>
<h5 id="如何自启动"><a href="#如何自启动" class="headerlink" title="如何自启动"></a>如何自启动</h5><p>在web.xml文件中，配置HelloServlet的地方加上一句：</p>
<p><code>&lt;load-on-startup&gt;10&lt;/load-on-startup&gt;</code>,取值范围为<code>1-99</code>,数字越小，启动的优先级越高。</p>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>shell命名之fg</title>
    <url>/2020/08/10/shell%E5%91%BD%E4%BB%A4%E4%B9%8Bfg/</url>
    <content><![CDATA[<h4 id="基本的几个指令"><a href="#基本的几个指令" class="headerlink" title="基本的几个指令"></a>基本的几个指令</h4><h5 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a><code>&amp;</code></h5><p>这个用在一个命令的最后，可以把这个命令放到后台执行</p>
<p><code>ctrl + z</code></p>
<p>可以将一个正在前台执行的命令放到后台，并且暂停</p>
<p><code>ctrl + d</code></p>
<p>表示结束当前输入(即用户不再给当前程序发出指令)。</p>
<p>它不是发送信号，而是表示一个特殊的二进制值，表示EOF。</p>
<span id="more"></span>
<p><code>jobs</code></p>
<p>查看当前有多少在后台运行的命令</p>
<p><code>fg</code></p>
<p>将后台中的命令调到前台继续运行</p>
<p>如果后台中有多个命令，可以用<code>fg %jobNumber</code>将选中的命令调出，<code>%jobNumber</code>是通过<code>jobs</code>命令查到的后台正在执行的命令的序号(<strong>不是pid</strong>)</p>
<p><code>bg</code></p>
<p>将一个在后台暂停的命令，变成继续执行</p>
<p>如果后台中有多个命令，可以用<code>bg %jobNumber</code>将选中的命令调出，<code>%jobNumber</code>是通过<code>jobs</code>命令查到的后台正在执行的命令的序号(<strong>不是pid</strong>)</p>
<h4 id="延申：nohup"><a href="#延申：nohup" class="headerlink" title="延申：nohup"></a>延申：<code>nohup</code></h4><h5 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nohup /root/start.sh &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 原程序的标准输出被自动改向到当前目录下的nohup.out文件，起到了<span class="built_in">log</span>的作用。</span></span><br></pre></td></tr></table></figure>
<h5 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a>nohup命令</h5><p>用途：不挂断的运行命令。</p>
<p>语法：<code>nohup Command [arg...] [&amp;]</code></p>
<blockquote>
<p>描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示”and”的符号）到命令的尾部。</p>
</blockquote>
<h5 id="nohup后面的2-gt-amp-1的含义"><a href="#nohup后面的2-gt-amp-1的含义" class="headerlink" title="nohup后面的2&gt;&amp;1的含义"></a>nohup后面的<code>2&gt;&amp;1</code>的含义</h5><h6 id="基本符号与含义"><a href="#基本符号与含义" class="headerlink" title="基本符号与含义"></a>基本符号与含义</h6><ul>
<li><code>0</code>表示stdin标准输入</li>
<li><code>1</code>表示stdout标准输出</li>
<li><code>2</code>表示stderr标准错误</li>
</ul>
<h6 id="command-gt-file"><a href="#command-gt-file" class="headerlink" title="command &gt; file"></a><code>command &gt; file</code></h6><p>这个命令其实是一个缩写，实际上是command产生的标准输出重定向到file中，也就是说相当于执行了<code>command 1 &gt; file</code>。</p>
<h6 id="2-gt-amp-1"><a href="#2-gt-amp-1" class="headerlink" title="2&gt;&amp;1"></a><code>2&gt;&amp;1</code></h6><p>2是标准错误，1是标准输出，&amp;的意思是 <strong>等效于</strong>。</p>
<p>实际上就是把标准错误也重定向到file中</p>
<h6 id="command-gt-a-2-gt-amp-1与command-gt-a-2-gt-a的区别"><a href="#command-gt-a-2-gt-amp-1与command-gt-a-2-gt-a的区别" class="headerlink" title="command&gt;a 2&gt;&amp;1与command&gt;a 2&gt;a的区别"></a>command&gt;a 2&gt;&amp;1与command&gt;a 2&gt;a的区别</h6><blockquote>
<p>经过上面的分析，<code>command&gt;a 2&gt;&amp;1</code>这条命令，等价于<code>command 1&gt;a 2&gt;&amp;1</code>，也就是说执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中，那么是否等价于<code>command 1&gt;a 2&gt;a</code>呢？其实不是，区别在于前者只打开一次文件a，后者会打开两次并导致标准输出被标准错误<strong>覆盖</strong>。</p>
<p><code>&amp;1</code>的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，<code>command 1&gt;a 2&gt;&amp;1</code>比<code>command 1&gt;a 2&gt;a</code>的效率更高。</p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro基础</title>
    <url>/2020/08/19/shiro%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h4><p>通过 api：Shiro 的 Session 接口的一个 setTimeout() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录后，可以用如下的方式取得 session</span></span><br><span class="line">SecurityUtils.getSubject().getSession().setTimeout(<span class="number">30000</span>)</span><br></pre></td></tr></table></figure>
<p><strong>设置的最大时间，正负都可以，为负数时表示永不过期。</strong></p>
<span id="more"></span>
<h5 id="设置成下面的负数-1L-遇到的一些问题"><a href="#设置成下面的负数-1L-遇到的一些问题" class="headerlink" title="设置成下面的负数 -1L, 遇到的一些问题"></a>设置成下面的负数 <code>-1L</code>, 遇到的一些问题</h5><p><code>SecurityUtils.getSubject().getSession().setTimeout(-1L);</code></p>
<p>这样调用后，总是抛出 session 已经过时的异常，一直找不到原因，</p>
<blockquote>
<p>后来调试源码才发现，这里设置的时间单位是:ms，但是Shiro会把这个时间转成:s，而且是会舍掉小数部分，这样我设置的是-1ms，转成s后就是0s，马上就过期了，所以后面再对这个会话进行操作时，总会抛异常</p>
</blockquote>
<p><em>正确的设置永不超时的方法应该是：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// timeout: -1000ms 永不超时</span></span><br><span class="line">SecurityUtils.getSubject().getSession().setTimeout(-<span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>安全框架</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro权限控制</title>
    <url>/2020/07/23/shiro%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>spring-boot连接sqlserver</title>
    <url>/2020/08/03/spring-boot%E8%BF%9E%E6%8E%A5sqlserver/</url>
    <content><![CDATA[<h5 id="下载所需依赖的jar包"><a href="#下载所需依赖的jar包" class="headerlink" title="下载所需依赖的jar包"></a>下载所需依赖的jar包</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.microsoft.sqlserver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sqljdbc4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:sqlserver://localhost:1433;DatabaseName=数据库名</span></span><br><span class="line"><span class="meta">spring.datasource.driverClassName</span>=<span class="string">com.microsoft.sqlserver.jdbc.SQLServerDriver</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">用户名</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">密码</span></span><br></pre></td></tr></table></figure>
<h5 id="sqlserver查看表机构"><a href="#sqlserver查看表机构" class="headerlink" title="sqlserver查看表机构"></a>sqlserver查看表机构</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_help table_name;           </span><br><span class="line">sp_columns table_name;</span><br></pre></td></tr></table></figure>
<h5 id="sqlserver查看表的主键约束"><a href="#sqlserver查看表的主键约束" class="headerlink" title="sqlserver查看表的主键约束"></a>sqlserver查看表的主键约束</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sp_helpconstraint table_name;</span><br></pre></td></tr></table></figure>
<h5 id="sqlserver查看表字段注释"><a href="#sqlserver查看表字段注释" class="headerlink" title="sqlserver查看表字段注释"></a>sqlserver查看表字段注释</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">c.name <span class="keyword">as</span> columnName,</span><br><span class="line">a.VALUE <span class="keyword">as</span> columnDescript</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sys.extended_properties a,</span><br><span class="line">sysobjects b,</span><br><span class="line">sys.columns c</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">a.major_id <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">AND</span> c.object_id <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">AND</span> c.column_id <span class="operator">=</span> a.minor_id</span><br><span class="line"><span class="keyword">AND</span> b.name <span class="operator">=</span> ‘要查询的表名’</span><br></pre></td></tr></table></figure>
<h5 id="字段对应关系"><a href="#字段对应关系" class="headerlink" title="字段对应关系"></a>字段对应关系</h5><div class="table-container">
<table>
<thead>
<tr>
<th>SQL Server 类型</th>
<th>JDBC 类型 (java.sql.Types)</th>
<th>Java 语言类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>bigint</td>
<td>BIGINT</td>
<td>long</td>
</tr>
<tr>
<td>timestampbinary</td>
<td>BINARY</td>
<td>byte[]</td>
</tr>
<tr>
<td>bit</td>
<td>BIT</td>
<td>boolean</td>
</tr>
<tr>
<td>char</td>
<td>CHAR</td>
<td>String</td>
</tr>
<tr>
<td>decimalmoneysmallmoney</td>
<td>DECIMAL</td>
<td>java.math.BigDecimal</td>
</tr>
<tr>
<td>float</td>
<td>DOUBLE</td>
<td>double</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
<td>int</td>
</tr>
<tr>
<td>imagevarbinary(max)</td>
<td>LONGVARBINARY</td>
<td>byte[]</td>
</tr>
<tr>
<td>varchar(max)text</td>
<td>LONGVARCHAR</td>
<td>String</td>
</tr>
<tr>
<td>nchar</td>
<td>CHARNCHAR (Java SE 6.0)</td>
<td>String</td>
</tr>
<tr>
<td>nvarchar</td>
<td>VARCHARNVARCHAR (Java SE 6.0)</td>
<td>String</td>
</tr>
<tr>
<td>nvarchar(max)ntext</td>
<td>LONGVARCHARLONGNVARCHAR (Java SE 6.0)</td>
<td>String</td>
</tr>
<tr>
<td>numeric</td>
<td>NUMERIC</td>
<td>java.math.BigDecimal</td>
</tr>
<tr>
<td>real</td>
<td>REAL</td>
<td>float</td>
</tr>
<tr>
<td>smallint</td>
<td>SMALLINT</td>
<td>short</td>
</tr>
<tr>
<td>datetimesmalldatetime</td>
<td>TIMESTAMP</td>
<td>java.sql.Timestamp</td>
</tr>
<tr>
<td>varbinaryudt</td>
<td>VARBINARY</td>
<td>byte[]</td>
</tr>
<tr>
<td>varchar</td>
<td>VARCHAR</td>
<td>String</td>
</tr>
<tr>
<td>tinyint</td>
<td>TINYINT</td>
<td>short</td>
</tr>
<tr>
<td>uniqueidentifier</td>
<td>CHAR</td>
<td>String</td>
</tr>
<tr>
<td>xml</td>
<td>LONGVARCHARSQLXML (Java SE 6.0)</td>
<td>StringSQLXML</td>
</tr>
<tr>
<td>time</td>
<td>TIME (1)</td>
<td>java.sql.Time (1)</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td>java.sql.Date</td>
</tr>
<tr>
<td>datetime2</td>
<td>TIMESTAMP</td>
<td>java.sql.Timestamp</td>
</tr>
<tr>
<td>datetimeoffset (2)</td>
<td>microsoft.sql.Types.DATETIMEOFFSET</td>
<td>microsoft.sql.DateTimeOffset</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-how2j</title>
    <url>/2021/03/14/spring-how2j/</url>
    <content><![CDATA[<h4 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC/DI"></a>IOC/DI</h4><p>Spring是一个基于IOC和AOP的结构的J2EE系统的框架。</p>
<p>IOC 控制反转，是Spring的基础，<code>Inversion Of Control</code></p>
<p>简单地说就是创建对象由以前的程序员自己new构造方法来调用，变成了交由Spring创建对象。</p>
<p>DI，Dependency Inject，依赖注入，</p>
<p>简单地说，就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。</p>
<span id="more"></span>
<h4 id="注入对象"><a href="#注入对象" class="headerlink" title="注入对象"></a>注入对象</h4><p>一个栗子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context     </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;c&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.how2java.pojo.Category&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;category 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;p&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.how2java.pojo.Product&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;product1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;c&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="注解方式IOC、DI"><a href="#注解方式IOC、DI" class="headerlink" title="注解方式IOC、DI"></a>注解方式IOC、DI</h4><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><p>@Component  对bean进行注解</p>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP，Aspect Oriented Program，面向切面编程。</p>
<blockquote>
<p>首先，在面向切面编程的思想里面，把功能分为<strong>核心业务功能</strong>，和<strong>周边功能</strong>。<br>所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务<br>所谓的周边功能，比如性能统计，日志，事务管理等等</p>
<p> 周边功能在Spring的面向切面编程AOP思想里，即被定义为<strong>切面</strong></p>
<p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别<strong>独立进行开发</strong><br>然后把切面功能和核心业务功能 <strong>“编织”</strong> 在一起，这就叫AOP</p>
</blockquote>
<h4 id="注解方式的AOP"><a href="#注解方式的AOP" class="headerlink" title="注解方式的AOP"></a>注解方式的AOP</h4><ul>
<li>注解配置业务类</li>
<li>注解配置切面<ul>
<li>@Aspect 表示这是一个切面</li>
<li>@Around(value = “execution(<em> com.how2java.service.ProductService.</em>(..))”) 表示对com.how2java.service.ProductService 这个类中的所有方法进行切面操作</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot-how2j</title>
    <url>/2021/03/14/springboot-how2j/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在学习SSM(H)的过程中，需要做大量的配置工作，其实很多配置行为本身只是手段，并不是目的。基于这个考虑，把该简化的简化，该省略的省略，开发人员只需关系业务功能就行了，这就是 <strong>Springboot.</strong></p>
<span id="more"></span>
<h4 id="部署-war方式"><a href="#部署-war方式" class="headerlink" title="部署-war方式"></a>部署-war方式</h4><ul>
<li><p>Application，新加<code>@ServletComponentScan</code>注解，并继承<code>SpringBootServletInitializer</code>。</p>
<p>  一个栗子：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.springboot;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pom.xml </p>
<ul>
<li>新加打包为war的声明</li>
<li>spring-boot-starter-tomcat修改为 provided方式，以避免和独立 tomcat 容器的冲突.</li>
</ul>
</li>
<li><p>即可创建war包 <code>mvn clean package</code></p>
</li>
</ul>
<h4 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h4><ul>
<li>yml</li>
<li>properties</li>
</ul>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud-learning</title>
    <url>/2021/03/25/springcloud-learning/</url>
    <content><![CDATA[<p>Spring Cloud的两个版本Edgware和Finchley。</p>
<h4 id="主要探讨Spring-Cloud各个版本之间的问题。"><a href="#主要探讨Spring-Cloud各个版本之间的问题。" class="headerlink" title="主要探讨Spring Cloud各个版本之间的问题。"></a>主要探讨Spring Cloud各个版本之间的问题。</h4><span id="more"></span>
<h5 id="consul多实例注册的问题处理"><a href="#consul多实例注册的问题处理" class="headerlink" title="consul多实例注册的问题处理"></a>consul多实例注册的问题处理</h5><ul>
<li><p>通过配置属性指定新的规则</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 粗暴的使用随机数来组织实例名</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.instance-id</span>=<span class="string">$&#123;spring.application.name&#125;-$&#123;random.int[10000,99999]&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过扩展<code>ConsulServiceRegistry</code>来重设实例名</p>
<p>重写其中的<code>register</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsulServiceRegistry</span> <span class="keyword">extends</span> <span class="title">ConsulServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConsulServiceRegistry</span><span class="params">(ConsulClient client, ConsulDiscoveryProperties properties, TtlScheduler ttlScheduler, HeartbeatProperties heartbeatProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(client, properties, ttlScheduler, heartbeatProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(ConsulRegistration reg)</span> </span>&#123;</span><br><span class="line">        reg.getService().setId(reg.getService().getName() + “-” + reg.getService().getAddress() + “-” + reg.getService().getPort());</span><br><span class="line">        <span class="keyword">super</span>.register(reg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Spring-Cloud-Alibaba与Spring-Boot、Spring-Cloud之间的关系"><a href="#Spring-Cloud-Alibaba与Spring-Boot、Spring-Cloud之间的关系" class="headerlink" title="Spring Cloud Alibaba与Spring Boot、Spring Cloud之间的关系"></a>Spring Cloud Alibaba与Spring Boot、Spring Cloud之间的关系</h5><h5 id="它们之间的兼容性"><a href="#它们之间的兼容性" class="headerlink" title="它们之间的兼容性"></a>它们之间的兼容性</h5><div class="table-container">
<table>
<thead>
<tr>
<th>Spring Boot</th>
<th>Spring Cloud</th>
<th>Spring Cloud Alibaba</th>
</tr>
</thead>
<tbody>
<tr>
<td>2.1.x</td>
<td>Greenwich</td>
<td>0.9.x</td>
</tr>
<tr>
<td>2.0.x</td>
<td>Finchley</td>
<td>0.2.x</td>
</tr>
<tr>
<td>1.5.x</td>
<td>Edgware</td>
<td>0.1.x</td>
</tr>
<tr>
<td>1.5.x</td>
<td>Dalston</td>
<td>0.1.x</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>它暂时还处在Spring Cloud的孵化器中。</p>
<h6 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h6><p>它不是一个简单的组件，<strong>而是一个综合套件。</strong>其中涵盖了非常多的内容：</p>
<ul>
<li>服务治理</li>
<li>配置管理</li>
<li>限流降级</li>
<li>对阿里开源生态（Dubbo、RocketMQ等）支持的诸多组件</li>
</ul>
<p>它将红极一时的Dubbo，以及阿里巴巴的强力消息中间件RocketMQ融入Spring Cloud体系。</p>
<h5 id="Spring-Cloud-Alibaba到底坑不坑"><a href="#Spring-Cloud-Alibaba到底坑不坑" class="headerlink" title="Spring Cloud Alibaba到底坑不坑"></a>Spring Cloud Alibaba到底坑不坑</h5><ol>
<li>远程调用RPC</li>
<li>注册中心</li>
<li>熔断、限流</li>
</ol>
<h4 id="注册和配置中心-Nacos"><a href="#注册和配置中心-Nacos" class="headerlink" title="注册和配置中心 Nacos"></a>注册和配置中心 Nacos</h4><h5 id="什么是Nacos"><a href="#什么是Nacos" class="headerlink" title="什么是Nacos"></a>什么是Nacos</h5><p>它致力于帮助您发现、配置和管理微服务。它提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>它帮助您更敏捷和容易地构建、交付和管理微服务平台。</p>
<p>它是构建以”服务“为中心的现代应用架构（例如微服务范式、云原生范式）的服务基础设施。</p>
<h5 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h5><p>根据不同平台，执行不同命令，启动单机版Nacos服务：</p>
<ul>
<li>Linux/Unix/Mac：<code>sh startup.sh -m standalone</code></li>
<li>Windows：<code>cmd startup.cmd -m standalone</code></li>
</ul>
<p><strong>默认用户名密码为：nacos</strong></p>
<h5 id="构建应用接入Nacos注册中心"><a href="#构建应用接入Nacos注册中心" class="headerlink" title="构建应用接入Nacos注册中心"></a>构建应用接入Nacos注册中心</h5><h6 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h6><ol>
<li>配置pom.xml文件</li>
<li>创建应用主类，并实现一个HTTP接口</li>
<li>配置文件配置服务名称和Nacos地址</li>
<li>启动应用。可使用<code>-Dserver.port=8001</code>的形式在本机以不同端口上启动多个实例。</li>
</ol>
<h6 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h6><p>基本类似于上面的几个步骤，但是主类中的实现是不同的。</p>
<p><em>此时已经实现对服务提供方实例的负载均衡了，但是操作还是比较繁琐，需要改进。</em></p>
<h4 id="支持几种服务消费方式（RestTemplate、WebClient、Feign）"><a href="#支持几种服务消费方式（RestTemplate、WebClient、Feign）" class="headerlink" title="支持几种服务消费方式（RestTemplate、WebClient、Feign）"></a>支持几种服务消费方式（RestTemplate、WebClient、Feign）</h4><h5 id="使用RestTemplate"><a href="#使用RestTemplate" class="headerlink" title="使用RestTemplate"></a>使用RestTemplate</h5><h5 id="使用WebClient"><a href="#使用WebClient" class="headerlink" title="使用WebClient"></a>使用WebClient</h5><h5 id="使用Feign"><a href="#使用Feign" class="headerlink" title="使用Feign"></a>使用Feign</h5><h4 id="Nacos配置的多环境管理"><a href="#Nacos配置的多环境管理" class="headerlink" title="Nacos配置的多环境管理"></a>Nacos配置的多环境管理</h4><ul>
<li>Data Id</li>
<li>Group</li>
</ul>
<h4 id="Nacos的数据持久化"><a href="#Nacos的数据持久化" class="headerlink" title="Nacos的数据持久化"></a>Nacos的数据持久化</h4><p>在Nacos的conf文件夹下，有MySql的数据库初始化文件，<code>nacos-mysql.sql</code>。</p>
<p>修改下<code>conf/application.properties</code>文件，增加支持MySQL数据源配置，添加（<strong>目前仅支持MySQL</strong>）数据源的url、用户名和密码。</p>
<h4 id="Nacos的集群部署"><a href="#Nacos的集群部署" class="headerlink" title="Nacos的集群部署"></a>Nacos的集群部署</h4>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud-sentinel篇</title>
    <url>/2021/03/28/springcloud-sentinel%E7%AF%87/</url>
    <content><![CDATA[<h4 id="sentinel是什么"><a href="#sentinel是什么" class="headerlink" title="sentinel是什么"></a>sentinel是什么</h4><p>Sentinel的官方标题为 <strong>分布式系统的流量防卫兵。</strong> 从名字上看，很容易就能猜到它是用来作服务稳定性保障的。以前 <strong>Hystrix</strong> 也是用于服务稳定性保障的，但是比较可惜的是Netflix已经宣布对Hystrix停止更新。那么，未来除了Spring Cloud官方推荐的 <strong>resilience4j</strong> 之外，Spring Cloud Alibaba下整合的Sentinel也是用户可以重点考察和选型的目标。</p>
<span id="more"></span>
<h4 id="使用Sentinel实现接口限流"><a href="#使用Sentinel实现接口限流" class="headerlink" title="使用Sentinel实现接口限流"></a>使用Sentinel实现接口限流</h4><p>它分为两个部分：</p>
<ul>
<li><p>sentinel-dashboard</p>
<p>  与hystrix-dashboard类似，但是这个更为强大一些。除了提供实现监控之外，还提供了流控规则、熔断规则的在线维护等功能。</p>
</li>
<li><p>客户端整合</p>
<p>  每个微服务客户端都需要整合sentinel的客户端封装与配置，才能将监控信息上报给dashboard展示以及实时地更改限流或熔断规则等。</p>
</li>
</ul>
<h5 id="部署Sentinel-Dashboard"><a href="#部署Sentinel-Dashboard" class="headerlink" title="部署Sentinel Dashboard"></a>部署Sentinel Dashboard</h5><p>这是一个jar包，可通过命令行启动：</p>
<p><code>java -jar sentinel-dashboard-1.6.0.jar</code></p>
<p>如果你需要自定义端口的话，可以在启动命令上增加参数来调整，比如<code>-Dserver.port=8080</code>。</p>
<h5 id="Spring-Cloud整合Sentinel"><a href="#Spring-Cloud整合Sentinel" class="headerlink" title="Spring Cloud整合Sentinel"></a>Spring Cloud整合Sentinel</h5>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>spring中@RequestBody和@ReuqestParam的区别</title>
    <url>/2020/08/04/spring%E4%B8%AD-RequestBody%E5%92%8C-ReuqestParam%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><ul>
<li>常用来处理简单类型的数据绑定，因为使用<code>request.getParameter()</code>的方式获取参数，所以可以处理get方式中queryString的值，也可以处理post方式中body data的值。</li>
<li>用来处理Content-Type为<code>application/x-www-form-urlencoded</code>编码的内容，提交方式为get、post。</li>
</ul>
<h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><ul>
<li>该注解常用来处理Content-Type: 不是<code>application/x-www-form-urlencoded</code>编码的内容，例如application/json, application/xml等。</li>
<li>SpringMVC通过使用HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li><blockquote>
<p>在GET请求中，不能使用@RequestBody。</p>
</blockquote>
</li>
<li><blockquote>
<p>在POST请求，可以使用@RequestBody和@RequestParam，但是如果使用@RequestBody，对于参数转化的配置必须统一。</p>
</blockquote>
</li>
</ol>
<h5 id="ajax传递json格式参数，后端使用-RequestBody来接收"><a href="#ajax传递json格式参数，后端使用-RequestBody来接收" class="headerlink" title="ajax传递json格式参数，后端使用@RequestBody来接收"></a>ajax传递json格式参数，后端使用<code>@RequestBody</code>来接收</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">icheckDelete</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = &#123;</span><br><span class="line">        list : array <span class="comment">//这是个数组</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        dataType: <span class="string">&quot;JSON&quot;</span>,</span><br><span class="line">        contentType:<span class="string">&#x27;application/json;charset=UTF-8&#x27;</span>,<span class="comment">//关键是要加上这行</span></span><br><span class="line">        traditional:<span class="literal">true</span>,<span class="comment">//这使json格式的字符不会被转码</span></span><br><span class="line">        data: <span class="built_in">JSON</span>.stringify(parms),</span><br><span class="line">        type: <span class="string">&quot;DELETE&quot;</span>, </span><br><span class="line">        timeout: <span class="number">20000</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        success : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        error : <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line">            alert(data.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger与token验证</title>
    <url>/2020/09/02/swagger%E4%B8%8Etoken%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h4 id="spring-boot-swagger2-设置全局-token，解决接口需要-token-验证的问题"><a href="#spring-boot-swagger2-设置全局-token，解决接口需要-token-验证的问题" class="headerlink" title="spring-boot swagger2 设置全局 token，解决接口需要 token 验证的问题"></a>spring-boot swagger2 设置全局 token，解决接口需要 token 验证的问题</h4><p><strong>问题背景：项目中需要在 header 中进行校验传入的 token，导致 swagger 不能调试</strong><br><span id="more"></span><br>具体的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiKey;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.google.common.collect.Lists.newArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">               .apiInfo(apiInfo()) </span><br><span class="line">               .select() </span><br><span class="line">               .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) </span><br><span class="line">               .paths(PathSelectors.any()) </span><br><span class="line">               .build() </span><br><span class="line">               <span class="comment">// 关键在于添加此处 </span></span><br><span class="line">               .securitySchemes(security());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">        主要添加这个方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ApiKey&gt; <span class="title">security</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newArrayList(</span><br><span class="line">            <span class="keyword">new</span> ApiKey(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;token&quot;</span>, <span class="string">&quot;header&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现的效果图<br><img src="http://wrr123.github.io/2020/09/02/swagger%E4%B8%8Etoken%E9%AA%8C%E8%AF%81/001.png" alt></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger基本使用</title>
    <url>/2020/08/03/swagger%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一种接口文档的规范</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>是一套基于<code>OpenAPI</code>规范构建的开源工具，可以帮助我们设计、构建、记录以及使用<code>RestAPI</code>。swagger主要包含了以下三个方面：</p>
<ol>
<li>Swagger Editor：基于浏览器的编辑器，我们可以使用它编写我们的<code>OpenAPI</code>规范。</li>
<li>Swagger UI: 它会将我们编写的<code>OpenAPI</code>规范呈现为交互式的API文档。</li>
<li>Swagger Codegen: 它可以通过<code>OpenAPI(以前称为Swagger)</code>规范定义的任何API生成服务器存根和客户端SDK来简化构建过程。</li>
</ol>
<h4 id="使用Swagger有什么优点"><a href="#使用Swagger有什么优点" class="headerlink" title="使用Swagger有什么优点"></a>使用Swagger有什么优点</h4><ol>
<li>代码变，文档变。只需要少量的注解，Swagger就可以根据代码自动生成API文档，很好的保证了文档的时效性。</li>
<li>跨语言性，支持40多种语言。</li>
<li>Swagger UI呈现出来的是一份可交互式的API文档，我们可以直接在文档页面尝试API的调用，省去了准备复杂的调用参数的过程。</li>
<li>还可以将文档规范导入相关的工具(例如<code>SnopUI</code>),这些工具将会为我们自动的创建自动化测试。</li>
</ol>
<h4 id="基于spring-boot-web项目的基本使用"><a href="#基于spring-boot-web项目的基本使用" class="headerlink" title="基于spring boot web项目的基本使用"></a>基于spring boot web项目的基本使用</h4><h5 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h5><ol>
<li>首先我们创建三个包：<code>cn.itweknow.sbswagger.controller</code>、<code>cn.itweknow.sbswagger.testcontroller</code> 以及 <code>cn.itweknow.sbswagger.model</code>。</li>
<li>在 controller 包下新建 <code>UserController.java</code> 类，在 <code>testcontroller</code> 包下新建 <code>TestController.java</code> 类，在 model 包下新建 <code>User.java</code> 类。</li>
<li><code>UserController</code> 提供用户的增、删、改、查四个接口，<code>TestContrller</code> 提供一个测试接口，这里粘上 <code>UserController.java</code> 的代码，其余代码可以查看<a href="https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-swagger">源码</a> 。</li>
</ol>
<p>UserController.java代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/find/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="集成Swagger2"><a href="#集成Swagger2" class="headerlink" title="集成Swagger2"></a>集成Swagger2</h5><p>上面的java类已经具有了如下的几个接口</p>
<ol>
<li>/user/add：新增用户。</li>
<li>/user/find/{id}：根据 id 查询用户。</li>
<li>/user/update：更新用户。</li>
<li>/user/delete/{id}：根据 id 删除用户。</li>
</ol>
<h6 id="添加swagger依赖"><a href="#添加swagger依赖" class="headerlink" title="添加swagger依赖"></a>添加swagger依赖</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="java配置"><a href="#java配置" class="headerlink" title="java配置"></a>java配置</h6><p>添加如下的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意: <code>@Configuration</code> 是告诉 Spring Boot 需要加载这个配置类， <code>@EnableSwagger2</code> 是启用 Swagger2，如果没加的话自然而然也就看不到后面的验证效果了</strong></p>
<h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><blockquote>
<p>至此，我们已经成功的在 Spring Boot 项目中集成了 Swagger2，启动项目后，我们可以通过在浏览器中访问 <code>http://localhost:8080/v2/api-docs</code> 来验证，您会发现返回的结果是一段 JSON 串，可读性非常差。幸运的是 Swagger2 为我们提供了可视化的交互界面 SwaggerUI，下面我们就一起来试试吧。</p>
</blockquote>
<h5 id="集成Swagger-UI"><a href="#集成Swagger-UI" class="headerlink" title="集成Swagger UI"></a>集成Swagger UI</h5><h6 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="访问验证"><a href="#访问验证" class="headerlink" title="访问验证"></a>访问验证</h6><blockquote>
<p>其实就只需要添加一下依赖就可以了，我们重新启动一下项目，然后在浏览器中访问 <code>http://localhost:8080/swagger-ui.html</code> 就可以看到如下的效果了:</p>
</blockquote>
<p><img src="http://wrr123.github.io/2020/08/03/swagger%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/001.png" alt></p>
<h4 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h4><h5 id="文档相关描述配置"><a href="#文档相关描述配置" class="headerlink" title="文档相关描述配置"></a>文档相关描述配置</h5><ol>
<li><p>通过在控制器类上增加<code>@Api</code>注解，可以给控制器增加描述和标签信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;用户相关接口&quot;, description = &quot;提供用户相关的 Rest API&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过在接口方法上增加<code>@ApiOperation</code>注解来展开对接口的描述，当然这个注解还可以指定很多的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;新增用户接口&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实体描述，可以通过<code>@ApiModel</code>和<code>@ApiModelProperty</code>注解来对我们API中所涉及到的对象进行描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel(&quot;用户实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户 id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>文档信息配置，Swagger 还支持设置一些文档的版本号、联系人邮箱、网站、版权、开源协议等等信息，但与上面几条不同的是这些信息不是通过注解配置，而是通过创建一个 ApiInfo 对象，并且使用 <code>Docket.appInfo()</code> 方法来设置，我们在 SwaggerConfig.java 类中新增如下内容即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.select()</span><br><span class="line">            .apis(RequestHandlerSelectors.any())</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">            <span class="string">&quot;Spring Boot 项目集成 Swagger 实例文档&quot;</span>,</span><br><span class="line">            <span class="string">&quot;我的博客网站：https://itweknow.cn，欢迎大家访问。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;API V1.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Terms of service&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> Contact(<span class="string">&quot;名字想好没&quot;</span>, <span class="string">&quot;https://itweknow.cn&quot;</span>, <span class="string">&quot;gancy.programmer@gmail.com&quot;</span>),</span><br><span class="line">                <span class="string">&quot;Apache&quot;</span>, <span class="string">&quot;http://www.apache.org/&quot;</span>, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>补全信息后的swagger文档界面</p>
<p><img src="http://wrr123.github.io/2020/08/03/swagger%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/002.png" alt></p>
<h4 id="接口过滤"><a href="#接口过滤" class="headerlink" title="接口过滤"></a>接口过滤</h4><blockquote>
<p>有些时候我们并不是希望所有的 Rest API 都呈现在文档上，这种情况下 Swagger2 提供给我们了两种方式配置，一种是基于 <code>@ApiIgnore</code> 注解，另一种是在 Docket 上增加筛选。</p>
</blockquote>
<ol>
<li><p><code>@ApiIgnore</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiIgnore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Docket 上增加筛选。Docket 类提供了 <code>apis()</code> 和 <code>paths()</code> 两个方法来帮助我们在不同级别上过滤接口：</p>
<ul>
<li><code>apis()</code> ：这种方式我们可以通过指定包名的方式，让 Swagger 只去某些包下面扫描。</li>
<li><code>paths()</code> ：这种方式可以通过筛选 API 的 url 来进行过滤。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;cn.itweknow.sbswagger.controller&quot;</span>))</span><br><span class="line">.paths(Predicates.or(PathSelectors.ant(<span class="string">&quot;/user/add&quot;</span>),</span><br><span class="line">        PathSelectors.ant(<span class="string">&quot;/user/find/*&quot;</span>)))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="自定义响应信息"><a href="#自定义响应信息" class="headerlink" title="自定义响应信息"></a>自定义响应信息</h4><blockquote>
<p>Swagger 允许我们通过 Docket 的 <code>globalResponseMessage()</code> 方法全局覆盖 HTTP 方法的响应消息，但是首先我们得通过 Docket 的 <code>useDefaultResponseMessages</code> 方法告诉 Swagger 不使用默认的 HTTP 响应消息，假设我们现在需要覆盖所有 GET 方法的 500 和 403 错误的响应消息，我们只需要在 SwaggerConfig.java 类中的 Docket Bean 下添加如下内容</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.useDefaultResponseMessages(<span class="keyword">false</span>)</span><br><span class="line">.globalResponseMessage(RequestMethod.GET, newArrayList(</span><br><span class="line"><span class="keyword">new</span> ResponseMessageBuilder()</span><br><span class="line">              .code(<span class="number">500</span>)</span><br><span class="line">              .message(<span class="string">&quot;服务器发生异常&quot;</span>)</span><br><span class="line">              .responseModel(<span class="keyword">new</span> ModelRef(<span class="string">&quot;Error&quot;</span>))</span><br><span class="line">              .build(),</span><br><span class="line">       <span class="keyword">new</span> ResponseMessageBuilder()</span><br><span class="line">              .code(<span class="number">403</span>)</span><br><span class="line">              .message(<span class="string">&quot;资源不可用&quot;</span>)</span><br><span class="line">              .build()</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<h4 id="相关注解说明"><a href="#相关注解说明" class="headerlink" title="相关注解说明"></a>相关注解说明</h4><h5 id="Controller相关注解"><a href="#Controller相关注解" class="headerlink" title="Controller相关注解"></a>Controller相关注解</h5><p><code>@Api</code>: 可设置对控制器的描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>注解属性</strong></th>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">tags</td>
<td style="text-align:left">String[]</td>
<td style="text-align:left">控制器标签。</td>
</tr>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">String</td>
<td style="text-align:left">控制器描述（该字段被申明为过期）。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="接口相关注解"><a href="#接口相关注解" class="headerlink" title="接口相关注解"></a>接口相关注解</h5><p><code>@ApiOperation</code>: 可设置对接口的描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>注解属性</strong></th>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">String</td>
<td style="text-align:left">接口说明。</td>
</tr>
<tr>
<td style="text-align:left">notes</td>
<td style="text-align:left">String</td>
<td style="text-align:left">接口发布说明。</td>
</tr>
<tr>
<td style="text-align:left">tags</td>
<td style="text-align:left">Stirng[]</td>
<td style="text-align:left">标签。</td>
</tr>
<tr>
<td style="text-align:left">response</td>
<td style="text-align:left">Class&lt;?&gt;</td>
<td style="text-align:left">接口返回类型。</td>
</tr>
<tr>
<td style="text-align:left">httpMethod</td>
<td style="text-align:left">String</td>
<td style="text-align:left">接口请求方式。</td>
</tr>
</tbody>
</table>
</div>
<p><code>@ApiIgnore</code>: Swagger 文档不会显示拥有该注解的接口。 <code>@ApiImplicitParams</code>: 用于描述接口的非对象参数集。 <code>@ApiImplicitParam</code>: 用于描述接口的非对象参数，一般与 <code>@ApiImplicitParams</code> 组合使用。</p>
<p><strong>@ApiImplicitParam 主要属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>注解属性</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">paramType</td>
<td style="text-align:left">查询参数类型，实际上就是参数放在那里。取值：path：以地址的形式提交数据，根据 id 查询用户的接口就是这种形式传参；query：Query string 的方式传参；header：以流的形式提交；form：以 Form 表单的形式提交。</td>
</tr>
<tr>
<td style="text-align:left">dataType</td>
<td style="text-align:left">参数的数据类型。取值：Long 和 String</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">参数名字。</td>
</tr>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">参数意义的描述。</td>
</tr>
<tr>
<td style="text-align:left">required</td>
<td style="text-align:left">是否必填。取值：true：必填参数；false：非必填参数。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Model相关注解"><a href="#Model相关注解" class="headerlink" title="Model相关注解"></a>Model相关注解</h5><p><code>@ApiModel</code>: 可设置接口相关实体的描述。 <code>@ApiModelProperty</code>: 可设置实体属性的相关描述。</p>
<p><strong>@ApiModelProperty 主要属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>注解属性</strong></th>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">String</td>
<td style="text-align:left">字段说明。</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">String</td>
<td style="text-align:left">重写字段名称。</td>
</tr>
<tr>
<td style="text-align:left">dataType</td>
<td style="text-align:left">Stirng</td>
<td style="text-align:left">重写字段类型。</td>
</tr>
<tr>
<td style="text-align:left">required</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">是否必填。</td>
</tr>
<tr>
<td style="text-align:left">example</td>
<td style="text-align:left">Stirng</td>
<td style="text-align:left">举例说明。</td>
</tr>
<tr>
<td style="text-align:left">hidden</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">是否在文档中隐藏该字段。</td>
</tr>
<tr>
<td style="text-align:left">allowEmptyValue</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">是否允许为空。</td>
</tr>
<tr>
<td style="text-align:left">allowableValues</td>
<td style="text-align:left">String</td>
<td style="text-align:left">该字段允许的值，当我们 API 的某个参数为枚举类型时，使用这个属性就可以清楚地告诉 API 使用者该参数所能允许传入的值。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><h5 id="Required-String-parameter-39-xxxx-39-is-not-present？"><a href="#Required-String-parameter-39-xxxx-39-is-not-present？" class="headerlink" title="Required String parameter &#39;xxxx&#39; is not present？"></a><code>Required String parameter &#39;xxxx&#39; is not present</code>？</h5><p><img src="http://wrr123.github.io/2020/08/03/swagger%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/003.png" alt></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>taskwarrior命令行基本使用</title>
    <url>/2020/10/10/taskwarrior%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h4><p><code>task - 一款命令行的 todo 任务管理软件</code></p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><code>task 过滤符 子命令 [&lt;mods&gt;|&lt;args&gt;] // 调用 task 子命令</code></p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><blockquote>
<p>taskwarrior是一个命令行式的任务列表管理软件。它可以维持一个你的任务列表，允许你添加/删除/修改任务。它具有丰富的子命令，可以做你想不到的事情。当然，在底层，它是一个任务列表排程程序。你添加文字任务和关于任务的描述，当你用日期来排列时它就是一个日程表，当你用优先级排列时，它就是你的做事顺序。你还可以添加标签，项目组，方便你管理你的这些任务。</p>
</blockquote>
<h4 id="过滤符（filter）"><a href="#过滤符（filter）" class="headerlink" title="过滤符（filter）"></a>过滤符（filter）</h4><blockquote>
<p>过滤符号由0或多个查找特征组成，用来选择你想要查看或修改的任务，例如，列出所有<code>Home</code>项目下的任务</p>
<p><code>task project:Home list  // list是一个子命令，列出tasks</code></p>
<p>你可以指定多个过滤符号</p>
<p><code>task project:Home +weekend graden list</code></p>
<p>该例中，有三个过滤符： <code>Home</code>项目，weekend标签，还有描述中必须包含<code>garden</code>。当然也可以理解为：</p>
<p><code>description.contains:garden</code></p>
</blockquote>
<span id="more"></span>
<p>修改内容</p>
<p>修改内容可以由 0 个或多个修改组成，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">task 过滤符 子命令 project:Home</span><br><span class="line">task 过滤符 子命令 +weekend +garden due:tomorrow</span><br><span class="line">task 过滤符 子命令 Description/annotation text</span><br><span class="line">task 过滤符 子命令 /from/to/</span><br></pre></td></tr></table></figure>
<h4 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h4><blockquote>
<p>taskwarrior支持很多子命令，包含 读命令，写命令，杂项命令 和 脚本帮助命令。读命令不允许修改task，写命令对命令进行修改，脚本帮助命令帮助你写附加的脚本，例如shell的自动补全等。</p>
</blockquote>
<h5 id="读子命令"><a href="#读子命令" class="headerlink" title="读子命令"></a>读子命令</h5><blockquote>
<p>reports是读子命令。输出和其它一些行为可以在配置文件里面配置，也有一些读子命令不是关于reports的。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">task --version              // 查看task的版本</span><br><span class="line"></span><br><span class="line">task 过滤符                // 查看满足条件的tasks</span><br><span class="line"></span><br><span class="line">task 过滤符 active         // 查看已经start，正处于激活状态的task</span><br><span class="line"></span><br><span class="line">task 过滤符 all            // 显示满足条件的所有tasks，包括递归task的父task</span><br><span class="line"></span><br><span class="line">task 过滤符 blocked        // 显示那些依赖于其它task的tasks</span><br><span class="line"></span><br><span class="line">task 过滤符 burndown.daily     // 绘制日统计图像</span><br><span class="line"></span><br><span class="line">task 过滤符 burndown.weekly    // 绘制周视图</span><br><span class="line"></span><br><span class="line">task 过滤符 burndown.monthly   // 绘制月视图</span><br><span class="line"></span><br><span class="line">task calendar [due|&lt;month&gt; &lt;year&gt; | &lt;year&gt;] [y] </span><br><span class="line">// 尖括号包含的内容替换成相应的量，显示一个月的日历,如果给出年，则显示一年的，如2014，如果给出年月，如`2 2014`则会从2014年2月份开始的几个月的日历。如果是due，则会显示预期最早的task。</span><br><span class="line"></span><br><span class="line">task colors [sample | legend]   // 显示支持的颜色，有简单版和完全版之分</span><br><span class="line"></span><br><span class="line">task columns                // 显示所有列和样式，在导出报表的时候非常有用</span><br><span class="line"></span><br><span class="line">task 过滤符 completed      // 显示已经完成的tasks</span><br><span class="line"></span><br><span class="line">task 过滤符 count          // 计算已经完成的tasks数量</span><br><span class="line"></span><br><span class="line">task 过滤符 <span class="built_in">export</span>         // 将选中的task导出成json格式，可以重定向到某个文件里面</span><br><span class="line"></span><br><span class="line">task 过滤符 ghistory.annual    // 年报表视图,完成情况</span><br><span class="line"></span><br><span class="line">task 过滤符 ghistory.monthly   // 月报表视图</span><br><span class="line"></span><br><span class="line">task <span class="built_in">help</span>   // 获取帮助</span><br><span class="line"></span><br><span class="line">task 过滤符 history.annual     // 年报表</span><br><span class="line"></span><br><span class="line">task 过滤符 history.monthly    // 月报表</span><br><span class="line"></span><br><span class="line">task 过滤符 ids    // 获取被选中项目的id序列，如1-3或2，3这样</span><br><span class="line">// 当用在修改特定的task时，它可是十分强大的，例如：</span><br><span class="line">task $(task project:Home ids) modify priority:H</span><br><span class="line">// 对Home project中的task进行修改，都添加一个高优先级,译者测试不成功，并且有点多此一举，不如用下面的：</span><br><span class="line">task project:Home modify priority:H</span><br><span class="line"></span><br><span class="line">task 过滤符 uuids      // 得到uuid的序列，用逗号分割</span><br><span class="line"></span><br><span class="line">task 过滤符 information    // 也写作info，得到选中task的详细信息</span><br><span class="line"></span><br><span class="line">task 过滤符 list       // 得到一个标准的列表，包含一些列</span><br><span class="line"></span><br><span class="line">task 过滤符 ls         // 得到一个精简了列的task列表</span><br><span class="line"></span><br><span class="line">task 过滤器 minimal    // 极简列表</span><br><span class="line"></span><br><span class="line">task 过滤符 newest     // 得到最新的tasks</span><br><span class="line"></span><br><span class="line">task 过滤符 next       // 显示最紧急的一批tasks,按照urgency这个计算得来的指标排序</span><br><span class="line"></span><br><span class="line">task 过滤符 ready      // ready的tasks，指没在时间表中，或者已经过期了的</span><br><span class="line"></span><br><span class="line">task 过滤符 oldest     // 最早的tasks,按age排序</span><br><span class="line"></span><br><span class="line">task 过滤符 overdue    // 在超出预期未完成的</span><br><span class="line"></span><br><span class="line">task 过滤符 projects    // 列出所有的projects</span><br><span class="line"></span><br><span class="line">task 过滤符 recurring      // 查找递归</span><br><span class="line"></span><br><span class="line">task 过滤符 unblocked      // 没有依赖性的</span><br><span class="line"></span><br><span class="line">task 过滤符 waitting       // 显示正在等待的tasks,和顺序有关</span><br></pre></td></tr></table></figure>
<h5 id="写子命令"><a href="#写子命令" class="headerlink" title="写子命令"></a>写子命令</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">task add 内容 // 添加一个任务到列表</span><br><span class="line"></span><br><span class="line">task 过滤符 annotate 操作内容    // 为task添加注释</span><br><span class="line"></span><br><span class="line">task 过滤符 append 内容          // 追加文本到已经存在的task尾部</span><br><span class="line"></span><br><span class="line">task 过滤器 delete 操作内容      // 删除满足条件的task</span><br><span class="line"></span><br><span class="line">task 过滤符 denotate 操作内容    // 当内容和task原有的notate相符时，则删除notate</span><br><span class="line"></span><br><span class="line">task 过滤符 <span class="keyword">done</span> 操作内容        // 将task标记为已经完成</span><br><span class="line"></span><br><span class="line">task 过滤符 duplicate 操作内容 // 复制原有的task,并可以修改,如有操作内容是作为notation</span><br><span class="line"></span><br><span class="line">task import &amp;lt;文件1&amp;gt; [&amp;lt;文件2&amp;gt;]   // 从文件中导入tasks</span><br><span class="line"></span><br><span class="line">task <span class="built_in">log</span> 操作内容     // 添加一个新的但是已经完成了的任务,等于做记录</span><br><span class="line"></span><br><span class="line">task merge &lt;url&gt;    // 远程合并task数据库，如</span><br><span class="line">ssh://[user@]host.xz[:port]/path/to/.task/</span><br><span class="line">rsync://[user@]host.xz[:port]/path/to/.task/</span><br><span class="line">[user@]host.xz:path/to/.task/</span><br><span class="line">/path/to/<span class="built_in">local</span>/.task/</span><br><span class="line"></span><br><span class="line">你甚至可以在.taskrc配置文件中对常用的url进行别名设置。</span><br><span class="line"></span><br><span class="line">task 过滤符 modify 操作内容    // 修改现有的tasks，操作可以有添加标签，修改project，优先级等</span><br><span class="line"></span><br><span class="line">task 过滤符 prepend 操作内容   // 为task添加文字到头部</span><br><span class="line"></span><br><span class="line">task pull &lt;url&gt;     // 拉取远程的数据覆盖本地数据库</span><br><span class="line"></span><br><span class="line">task push &lt;url&gt;     // 推送自己的版本到远程，这和版本库很类似啊，下次你搭建一个服务器，随处都可以访问了</span><br><span class="line"></span><br><span class="line">task 过滤符 start 操作内容   // 标记为开始</span><br><span class="line"></span><br><span class="line">task 过滤符 stop 操作内容   // 移除开始标记，暂停</span><br></pre></td></tr></table></figure>
<h5 id="杂项子命令"><a href="#杂项子命令" class="headerlink" title="杂项子命令"></a>杂项子命令</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">task config [name [value|<span class="string">&#x27;&#x27;</span>]] // 查看或者修改某项配置</span><br><span class="line"></span><br><span class="line">task diagnostics    // 诊断</span><br><span class="line"></span><br><span class="line">task execute 外部命令`// 执行外部命令</span><br><span class="line"></span><br><span class="line">task logo       // 显示taskwarrior的logo</span><br><span class="line"></span><br><span class="line">task reports    // 列举所有支持的报告项，包括系统报告和用户自定义报告</span><br><span class="line"></span><br><span class="line">task shell      // 进入task的命令行，可以直接list这样运行执行</span><br><span class="line"></span><br><span class="line">task show [all | substring]     // 显示当前设置</span><br><span class="line"></span><br><span class="line">task 过滤符 stats  // 显示统计信息，包括空间及其它状态信息</span><br><span class="line"></span><br><span class="line">task 过滤符 tags   // tags的统计信息</span><br><span class="line"></span><br><span class="line">task 过滤符 projects   // projects的统计信息</span><br><span class="line"></span><br><span class="line">task timesheet [weeks]      // 得到一个周报表，哪些做完了，哪些开始了</span><br><span class="line"></span><br><span class="line">task undo   // 撤销最近的动作</span><br><span class="line"></span><br><span class="line">task version    // 显示版本号的详细信息</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>the-silver-search</title>
    <url>/2020/08/11/the-silver-search/</url>
    <content><![CDATA[<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><img src="http://wrr123.github.io/2020/08/11/the-silver-search/001.png" alt></p>
<p>关于文本搜索，最常见的用法是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ag &quot;search string&quot;</span><br></pre></td></tr></table></figure>
<p>此时 <code>ag</code> 会遍历当前目录下的文本文件，在每个文件的每一行查找 “search string” 这种模式，把文件名、行号和匹配的内容高亮显示出来。由于这种模式可以是一个正则表达式，使得搜索功能极为的强大。</p>
<span id="more"></span>
<h5 id="如果想在某个指定的目录下搜索，或只搜索某个文件的内容，在搜索的字符串后面加上路径即可："><a href="#如果想在某个指定的目录下搜索，或只搜索某个文件的内容，在搜索的字符串后面加上路径即可：" class="headerlink" title="如果想在某个指定的目录下搜索，或只搜索某个文件的内容，在搜索的字符串后面加上路径即可："></a>如果想在某个指定的目录下搜索，或只搜索某个文件的内容，在搜索的字符串后面加上路径即可：</h5><p><code>ag &quot;search string&quot; /path/to/directory</code></p>
<h5 id="ag-G-可以使搜索只在特定的文件中进行。"><a href="#ag-G-可以使搜索只在特定的文件中进行。" class="headerlink" title="ag -G 可以使搜索只在特定的文件中进行。"></a><code>ag -G</code> 可以使搜索只在特定的文件中进行。</h5><p>一个栗子</p>
<p><code>ag -G &quot;.+\.java&quot; &quot;search string&quot; /path/to/directory</code></p>
<h5 id="忽略大小写敏感"><a href="#忽略大小写敏感" class="headerlink" title="忽略大小写敏感"></a>忽略大小写敏感</h5><p><code>ag -i</code></p>
<p><strong><code>ag</code> 根据输入智能判定大小写的匹配方式。如果查询的字符只含有小写字母，使用大小写不敏感的匹配方式；如果出现了大写字母，使用大小写敏感的匹配方式。</strong></p>
<h5 id="全词匹配"><a href="#全词匹配" class="headerlink" title="全词匹配"></a>全词匹配</h5><p><code>ag -w</code></p>
<p>它要求匹配的字符串前后有合适的分隔符。</p>
<h5 id="搜索不满足特定模式的行"><a href="#搜索不满足特定模式的行" class="headerlink" title="搜索不满足特定模式的行"></a>搜索不满足特定模式的行</h5><p><code>ag -v</code> 对搜索结果取反。</p>
<h5 id="如果只关心有哪些文件匹配，而不在意文件的内容"><a href="#如果只关心有哪些文件匹配，而不在意文件的内容" class="headerlink" title="如果只关心有哪些文件匹配，而不在意文件的内容"></a>如果只关心有哪些文件匹配，而不在意文件的内容</h5><p><code>ag -l</code> 显示匹配的文件名。只显示满足条件的文件的名称。</p>
<p>类似的，<code>ag -L</code> 显示没有任何匹配的文件名。</p>
]]></content>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>thinking in java</title>
    <url>/2020/09/17/thinking-in-java/</url>
    <content><![CDATA[<h4 id="分析和设计"><a href="#分析和设计" class="headerlink" title="分析和设计"></a>分析和设计</h4><p>面向对象的模式是思考程序设计时，一种新的、而且全然不同的方式，许多人最开始都会在如何构造一个项目上皱起了眉头。事实上，我们可以作出一个 “好” 的设计，它能充分利用 OOP 提供的所有优点。</p>
<h5 id="不要迷失"><a href="#不要迷失" class="headerlink" title="不要迷失"></a>不要迷失</h5><p>在整个开发过程中，最重要的事情就是：不要将自己迷失！</p>
<p>但事实上这种事情很容易发生，大多数方法都设计用来解决最大范围内的问题。当然也存在一些特别困难的项目，需要付出更为艰辛的努力，或者付出更大的代价。但是，大多数项目还是比较 “常规的”，所以一般都能作出成功的分析与设计，而且只需要用到推荐的一小部分方法。</p>
<p>但无论多么有限，某些形式的处理总是有益的，这可使整个项目的开发更加容易，总比直截了当的开始编码好！</p>
<p>假如你正在考察一种特殊的方法，其中包含了大量细节，并推荐了许多步骤和文档，那么仍然很难正确判断自己该在何时停止，时刻提醒自己注意一下几个问题：</p>
<ol>
<li>对象是什么？（怎样将自己的项目分隔成一系列单独的组件）</li>
<li>它们的接口是什么？（需要将什么消息发给每个对象）</li>
</ol>
<p>在确定了对象和它们的接口之后，便可着手编写一个程序。</p>
<p>整个过程可划分为四个阶段。</p>
<span id="more"></span>
<h5 id="拟出一个计划"><a href="#拟出一个计划" class="headerlink" title="拟出一个计划"></a>拟出一个计划</h5><p>第一步是决定在后面的过程中采取哪些步骤。</p>
<h5 id="要制作什么"><a href="#要制作什么" class="headerlink" title="要制作什么"></a>要制作什么</h5><p>在上一代程序设计中（即 “过程化或程序化设计”），这个阶段称为 “建立需求分析和系统规格”。</p>
<p>需求分析的意思是 “建立一系列规则，根据它判断任务什么时候完成，以及客户怎样才能满意”。</p>
<p>系统规格则表示 “这里是一些具体的说明，让你知道程序需要做什么（而不是怎样做）才能满足条件”。</p>
<h5 id="如何构建"><a href="#如何构建" class="headerlink" title="如何构建"></a>如何构建</h5><p>在这一阶段，必须拿出一套设计模式，并解释其中包含的各类对象在外观上是什么样子，以及相互间是如何沟通的。</p>
<p>此时可考虑采用一种特殊的图标工具： “统一建模语言” （UML）。作为第一阶段中的描述工具，UML 也是很有帮助的。此外，还可用它在第二阶段中处理一些图表（如流程图）。</p>
<h5 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h5><p>全面的思考、周密的准备、良好的构造不仅使程序更易构建与调试，也使其更易理解和维护，而那正是一套软件盈利的必要条件。</p>
<h5 id="校订"><a href="#校订" class="headerlink" title="校订"></a>校订</h5><p>构建一套系统时，“校订” 几乎是不可避免的。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat-how2j</title>
    <url>/2021/03/13/tomcat-how2j/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Tomcat是常见的免费的web服务器。</p>
<h5 id="Tomcat名字的由来"><a href="#Tomcat名字的由来" class="headerlink" title="Tomcat名字的由来"></a>Tomcat名字的由来</h5><p>Tomcat是野外的猫科动物，不依赖人类，独立生活。Tomcat的作者，取这个名字的初衷是希望这一款服务器可以自力更生，自给自足，像Tomcat这种野生动物一样，不依赖其他插件，而可以独立达到提供web服务的效果。</p>
<h4 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h4><ul>
<li>server.xml<br>tomcat的相关配置信息都在<code>server.xml</code>文件中。<h4 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h4></li>
<li>查看<code>JAVA_HOME</code>是否配置了</li>
<li>CATALINA_HOME未设置<br>解决：<ul>
<li>在环境变量中删除 <code>CATALINA_HOME, CATALINA_BASE</code>的配置，记得不仅要检查环境变量，还要检查用户变量。</li>
<li>或者把<code>CATALINA_HOME</code>设置为正确的tomcat目录。</li>
</ul>
</li>
<li>端口冲突</li>
<li>localhost.yyyy-mm-dd.log<ul>
<li>有可能是配置的context目录不存在</li>
<li>也有可能多了一个 <code>&gt;</code> 符号。</li>
</ul>
</li>
<li>Error FilterStart</li>
<li>JDK版本<h4 id="404问题排查"><a href="#404问题排查" class="headerlink" title="404问题排查"></a>404问题排查</h4></li>
<li>正确的端口号</li>
<li>环境变量</li>
<li>确定web应用是否成功启动</li>
<li>webapps下的ROOT目录</li>
<li>访问的地址上是否添加的web应用的名称</li>
<li>是否访问对资源了</li>
<li>不能访问WEB-INF下的资源</li>
<li>访问的资质后面多加了一个斜杠<h4 id="端口被占用"><a href="#端口被占用" class="headerlink" title="端口被占用"></a>端口被占用</h4></li>
<li>查看80端口被哪些程序占用了</li>
<li>根据pid(进程id)查询对应的应用程序</li>
<li>根据名称结束该程序<h4 id="持久化异常"><a href="#持久化异常" class="headerlink" title="持久化异常"></a>持久化异常</h4>tomcat启动的时候会报一个<code>Exception loading sessions from persistent storage</code>异常，但是又不影响正常的业务。<br>治标的解决办法：<br>只需要删除 <code>session.ser</code> 文件即可。<br>治本的解决办法：<br>关闭tomcat的持久化功能。<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4></li>
</ul>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>typora编辑器</title>
    <url>/2021/01/06/typora%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h4 id="emoji表情"><a href="#emoji表情" class="headerlink" title="emoji表情"></a>emoji表情</h4><p>如今<span style="color:red;">emoji表情</span> 越来越多地出现在一些网站文章中，但在桌面端（特别是Windows系统）文本编辑器上插入<span style="color:red;">emoji</span>是一件十分麻烦的事情。在使用Typora之前，打出emoji表情的办法基本有两个：</p>
<ol>
<li><span style="color:green;">输入法联想</span> ：优点是比较方便，但会插入一张图片而不是一个字符，在许多情景下都不是很合适。</li>
<li><span style="color:green;">复制emoji符号</span> ：优点是能保证符号的形式，但显然每次用都需要去复制，比较麻烦。</li>
</ol>
<p><strong>在Typora中，你可以用<code>:emoji:</code> 的形式来打出emoji，软件会自动给出图形的提示，还是比较好用的。</strong></p>
<h4 id="一个学术文档编辑器"><a href="#一个学术文档编辑器" class="headerlink" title="一个学术文档编辑器"></a>一个学术文档编辑器</h4><p style="color:#f08080;">
    除了基本的文本编辑体验极佳之外，Typora还是一个非常优秀的学术文档编辑器。
    当然作为一个轻量级的、基于Markdown的编辑器，它不能与那些`LaTex`编辑器相提并论，
    但它仍支持了许多可用于学术写作的功能。
</p>

<span id="more"></span>
<h5 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h5><blockquote>
<big>LaTeX是一种基于TeX的排版系统，由于它易于快速生成复杂表格和数学公式，非常适用于生成高印刷质量的科技和数学类文档。</big>

</blockquote>
<p>Typora原生支持LaTeX语法，你有两种方式输入LaTeX风格的数学公式：</p>
<ol>
<li><strong>行内公式（inline）</strong>：用 <script type="math/tex">...</script>括起公式，公式会出现在行内。</li>
<li><strong>块间公式（display）</strong> ：用 $$$…$$$ 括起公式（注意$$$$后需要换行），公式会默认显示在行中间。</li>
</ol>
<p>具体的LaTeX语法可以在 <a href="https://blog.csdn.net/happyday_d/article/details/83715440">这里</a> 找到。</p>
<blockquote>
<p><a href="https://007sair.github.io/2016/07/04/UNICODE/">HTML字符转义、特殊字符笔记</a></p>
</blockquote>
<h5 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h5><p>Typora中代码的插入也可以分为行内和块间两种：</p>
<ol>
<li><p>行内代码：用 <code style="color:red;">`…`</code>  或   <code style="color:red;">``…``</code>  括起括号，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。</p>
</li>
<li><p>代码块：输入<code style="color:red;">```</code> 后并输入语言名，换行，开始写代码，Typora就会自动帮你实现代码高亮。</p>
<p>Typora原生支持许多编程语言代码块的语法高亮，基本日常常用的编程语言它都能很好的支持。</p>
<p>除此以外，你也可以直接换行开始写，而后再选择语言。</p>
</li>
</ol>
<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p>在Markdown中插入表格一直是一件比较头疼的事情。在一般的Markdown编辑器中，你可以通过以下的格式插入表格：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|左对齐|右对齐|居中对齐|</span><br><span class="line">|:----|---:|:-----:|</span><br><span class="line">|单元格|单元格|单元格|</span><br><span class="line">|单元格|单元格|单元格|</span><br></pre></td></tr></table></figure>
<p>而在Typora中只需要在行内 <span style="color:maroon;">鼠标右键 - 插入 - 表格 </span> ，并输入行数和列数，Typora就会自动生成一张样式不错的空表格。</p>
<h5 id="链接引用与脚注"><a href="#链接引用与脚注" class="headerlink" title="链接引用与脚注"></a>链接引用与脚注</h5><p><strong>链接引用</strong> 类似与我们常在论文末尾看到的 <code>参考文献</code> 的写法，你可以通过<code>[]:</code> 的语法来为你的文档机上链接引用。</p>
<p><strong>脚注</strong>：你可以在需要插入脚注标号的位置写 <code>[^ number]</code>，再在下方通过 <code>[^ number]:</code> </p>
]]></content>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>vim</title>
    <url>/2020/08/20/vim/</url>
    <content><![CDATA[<h4 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h4><p>vim 代码折叠方式可以用 “foldmethod” 选项来设置，如: <code>set foldmethod = indent</code></p>
<h5 id="有-6-种方式来折叠代码"><a href="#有-6-种方式来折叠代码" class="headerlink" title="有 6 种方式来折叠代码"></a>有 6 种方式来折叠代码</h5><ol>
<li><code>manual</code> 手工定义折叠</li>
<li><code>indent</code> 用缩进来表示折叠</li>
<li><code>expr</code> 用表达式来定义折叠</li>
<li><code>syntax</code> 用语法高亮来定义折叠</li>
<li><code>diff</code> 对没有更改的文本进行折叠</li>
<li><code>marker</code> 用标志折叠</li>
</ol>
<span id="more"></span>
<h5 id="indent-折叠命令"><a href="#indent-折叠命令" class="headerlink" title="indent 折叠命令"></a>indent 折叠命令</h5><h6 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h6><ul>
<li><code>za</code>  打开或关闭当前折叠</li>
<li><code>zM</code> 关闭所有折叠</li>
<li><code>zR</code> 打开所有折叠</li>
</ul>
<blockquote>
<p>indent方式，vim会自动利用缩进进行折叠，我们可以使用现成的折叠成果．<br>我们可以在(括号)折叠处输入以下命令：</p>
<p>zc 折叠<br>zC 对所在范围内所有嵌套的折叠点进行折叠<br>zo 展开折叠<br>zO 对所在范围内所有嵌套的折叠点展开<br>[z 到当前打开的折叠的开始处。<br>]z 到当前打开的折叠的末尾处。<br>zj 向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。<br>zk 向上移动到前一折叠的结束处。关闭的折叠也被计入。</p>
</blockquote>
<h5 id="marker-折叠命令"><a href="#marker-折叠命令" class="headerlink" title="marker 折叠命令"></a>marker 折叠命令</h5><blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">marker折叠方式时，我们需要用标计来标识代码的折叠，系统默认是&#123;&#123;&#123;和&#125;&#125;&#125;</span><br><span class="line">折叠命令</span><br><span class="line"></span><br><span class="line">zf　创建折叠，比如在marker方式下：</span><br><span class="line"> zf56G，创建从当前行起到56行的代码折叠；</span><br><span class="line"> 10zf或10zf+或zf10↓，创建从当前行起到后10行的代码折叠。</span><br><span class="line"> 10zf-或zf10↑，创建从当前行起到之前10行的代码折叠。</span><br><span class="line"> 在括号处zf%，创建从当前行起到对应的匹配的括号上去（（），&#123;&#125;，[]，&lt;&gt;等）。</span><br><span class="line">zd 删除 (delete) 在光标下的折叠。仅当 &#x27;foldmethod&#x27; 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。</span><br><span class="line">zD 循环删除 (Delete) 光标下的折叠，即嵌套删除折叠。仅当 &#x27;foldmethod&#x27; 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。</span><br><span class="line">zE 除去 (Eliminate) 窗口里“所有”的折叠。仅当 &#x27;foldmethod&#x27; 设为 &quot;manual&quot; 或 &quot;marker&quot; 时有效。</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="在命令模式下粘贴数据"><a href="#在命令模式下粘贴数据" class="headerlink" title="在命令模式下粘贴数据"></a>在命令模式下粘贴数据</h4><p>vim 中，赋值一些内容就是将内容放到寄存器中。</p>
<p>在命令模式下，粘贴寄存器的内容的方法是：</p>
<p><strong><code>ctrl-R 加寄存器的名字</code></strong> 。</p>
<p>复制之后的内容一般放在寄存器 <code>&quot;</code> 中。</p>
<p>一个栗子：</p>
<p>比如在 visual 模式下，复制了内容： <code>aaabbb</code></p>
<p>然后希望替换这些内容，于是输入命令：</p>
<p><code>%s/</code>，这时候使用 <code>ctrl-R 再按 &quot;</code>,那么复制的内容就会出现在命令行中了。</p>
<h4 id="统计一个字符串出现的次数"><a href="#统计一个字符串出现的次数" class="headerlink" title="统计一个字符串出现的次数"></a>统计一个字符串出现的次数</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:%s/string/&amp;/gn</span><br></pre></td></tr></table></figure>
<h4 id="Movement-Characters"><a href="#Movement-Characters" class="headerlink" title="Movement: Characters"></a>Movement: Characters</h4><p><code>t [char]</code> : Jump to one character before the next occurence of [char]</p>
<p><code>T [char]</code>: Jump to one character after the next occurence of [char]</p>
<p><code>;</code>: repeat last <code>f F t T</code> movement</p>
<p><code>,</code>: repeat last <code>f F t T</code> movement in the opposite direction</p>
<h4 id="Movement-Code"><a href="#Movement-Code" class="headerlink" title="Movement: Code"></a>Movement: Code</h4><p><code>[[</code> : Jump to previous function</p>
<p><code>]]</code>: Jump to next function</p>
<p><code>[&#123;</code>: Jump to beginning of current block</p>
<p><code>]&#125;</code>: Jump to end of currnet block</p>
<h4 id="Indenting-text"><a href="#Indenting-text" class="headerlink" title="Indenting text"></a>Indenting text</h4><ul>
<li><p><code>&gt;aB</code></p>
<p>  Indent current block (defined by curly braces).</p>
</li>
<li><p><code>&gt;ap</code></p>
<p>  Indent current paragraph.</p>
</li>
<li><p><code>&gt;i&#123;</code></p>
<p>  Indent inside current set of curly braces.</p>
</li>
<li><p><code>=</code></p>
<p>  In visual mode: Reformat selected text.</p>
</li>
</ul>
<h4 id="buffers"><a href="#buffers" class="headerlink" title="buffers"></a>buffers</h4><ul>
<li><p><code>:ls</code></p>
<p>  List open buffers.</p>
</li>
<li><p><code>:buf 2</code></p>
<p>  Switch to buffer #2.</p>
</li>
<li><p><code>:bn</code></p>
<p>  Switch to next buffer.</p>
</li>
<li><p><code>:bp</code></p>
<p>  Switch to previous buffer.</p>
</li>
<li><p><code>:bd</code></p>
<p>  Close current buffer.</p>
</li>
</ul>
<h4 id="Scrolling"><a href="#Scrolling" class="headerlink" title="Scrolling"></a>Scrolling</h4><ul>
<li><p>H</p>
<p>  Jump to the high part of the screen.</p>
</li>
<li><p>M</p>
<p>  Jump to the middle part of the screen.</p>
</li>
<li><p>L</p>
<p>  Jump to the low part of the screen.</p>
</li>
<li><p>zt</p>
<p>  Scroll so the current line is at the top of the screen.</p>
</li>
<li><p>zz</p>
<p>  Scroll so the current line is in the middle of the screen.</p>
</li>
<li><p>zb</p>
<p>  Scroll so the current line is at the bottom of the screen.</p>
</li>
</ul>
<h4 id="Floding"><a href="#Floding" class="headerlink" title="Floding"></a>Floding</h4><ul>
<li><p>:fold</p>
<p>  In visual mode: Fold selected lines.</p>
</li>
<li><p>3zF</p>
<p>  Fold 3 lines.</p>
</li>
<li><p>zo</p>
<p>  Open current fold under the cursor.</p>
</li>
<li><p>zc</p>
<p>  Close current fold under the cursor.</p>
</li>
<li><p>za</p>
<p>  Toggle current fold under the cursor.</p>
</li>
<li><p>zR</p>
<p>  Open all folds.</p>
</li>
<li><p>zM</p>
<p>  Close all folds.</p>
</li>
<li><p>zd</p>
<p>  Delete fold under the cursor. (Leaves text intact, just removes fold.)</p>
</li>
</ul>
<h4 id="Bookmark-and-History"><a href="#Bookmark-and-History" class="headerlink" title="Bookmark and History"></a>Bookmark and History</h4><ul>
<li><p>ma</p>
<p>  Set current position as mark ‘a’ (any lowercase letter will do).</p>
</li>
<li><p>`a</p>
<p>  Jump to mark ‘a’. (The first character is a backtick, left of the ‘1’ on your keyboard.)</p>
</li>
<li><p>g;</p>
<p>  Go back to the last place you edited. (You can do it multiple times in a row.)</p>
</li>
</ul>
<h4 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h4><ul>
<li><p>:sort</p>
<p>  Sort selected text.</p>
</li>
<li><p>:%sort</p>
<p>  Sort the whole file.</p>
</li>
<li><p>:1,10sort</p>
<p>  Sort the first ten lines of the file.</p>
</li>
<li><p>:!sort -n</p>
<p>  Sort selected text using the external Unix <code>sort</code> command with the <code>-n</code> option.</p>
</li>
<li><p>:%!uniq</p>
<p>  Run the whole file through the external <code>uniq</code> command.</p>
</li>
<li><p>vimdiff <em>[file1]</em> <em>[file2]</em></p>
<p>  Diff <em>[file1]</em> and <em>[file2]</em> using synchronized split windows.</p>
</li>
<li><p>]c</p>
<p>  In vimdiff mode, move to next line with differences.</p>
</li>
<li><p>[c</p>
<p>  In vimdiff mode, move to previous line with differences.</p>
</li>
<li><p>vim + <em>[file]</em></p>
<p>  Open <em>[file]</em> in Vim and jump to the end of the file.</p>
</li>
<li><p>vim +21 <em>[file]</em></p>
<p>  Open <em>[file]</em> in Vim and jump to line 21.</p>
</li>
<li><p>[i</p>
<p>  Show (in the status line) the first line containing the word under the cursor.</p>
</li>
<li><p>[I</p>
<p>  Show (in the status line) all lines containing the word under the cursor.</p>
</li>
<li><p>:g/pattern/</p>
<p>  Show (in the status line) all lines that match the regex <code>/pattern/</code>.</p>
</li>
<li><p>:e scp://username@server//path/to/file</p>
<p>  Open a remote file over SSH.</p>
</li>
<li><p>:au! BufNewFile,BufRead *.php set filetype=php.html.javascript.css</p>
<p>  When you open or create a .php file, set the filetype to include HTML, JS, and CSS (for good syntax highlighting).</p>
</li>
<li><p>:iab <expr> dts strftime(“%-d %b %Y (%a)”)</expr></p>
<p>  Make it so typing ‘dts’ followed by a space will insert the current date.</p>
</li>
</ul>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>vim宏的使用</title>
    <url>/2020/07/09/vim%E5%AE%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<hr>
<p>vim宏的实质就是把一个vim指令集存到了寄存器中，然后再调用寄存器的指令。</p>
<h4 id="使用宏命令可以重复执行你所记录下的命令"><a href="#使用宏命令可以重复执行你所记录下的命令" class="headerlink" title="使用宏命令可以重复执行你所记录下的命令"></a>使用宏命令可以重复执行你所记录下的命令</h4><ul>
<li><p>命令模式下，按<code>q</code> + <code>&lt;register&gt;</code> + 一系列的命令 + <code>q</code></p>
<blockquote>
<p><register>指的是用户自己定义的a-z中的一个寄存器</register></p>
<p><code>q</code> + <register> 开始记录命令</register></p>
<p><code>q</code> 记录完成，退出命令。</p>
</blockquote>
</li>
</ul>
<h4 id="宏的使用"><a href="#宏的使用" class="headerlink" title="宏的使用"></a>宏的使用</h4><p><code>@&lt;register&gt;</code></p>
<p>使用<code>@</code>符号加上你之前定义的寄存器来使用宏。</p>
<p><strong>如果你使用了一次宏，也可以使用<code>@@</code>来重复执行上一次使用的宏</strong></p>
<h4 id="修改宏"><a href="#修改宏" class="headerlink" title="修改宏"></a>修改宏</h4><blockquote>
<p>1、先用G（大写）到文件末尾，然后用o（小写）新加一行，不要编辑，用ESC退出到普通模式，其实就是为编辑宏找了个地方。<br>2、使用命令”ap会看到寄存器a中的命令宏像文本一样出现在这一行，然后编辑这一行。编辑的时候与vim编辑其他的文件一样。编辑结束后用0（零）回到行首。<br>3、然后用”ay$将正确内容写到寄存器a中，最后删除这一行即可。<br>4、当你需要向命令宏寄存器中增加内容时，可以用命令qA来向a寄存器增加内容，之后输入你想增加的内容，再使用q结束。</p>
</blockquote>
]]></content>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>vsCode</title>
    <url>/2020/08/20/vsCode/</url>
    <content><![CDATA[<h4 id="设置缩进-2-个空格"><a href="#设置缩进-2-个空格" class="headerlink" title="设置缩进 2 个空格"></a>设置缩进 2 个空格</h4><p><img src="http://wrr123.github.io/2020/08/20/vsCode/001.png" alt></p>
<p><strong>设置完成不会立刻生效，可以 ctrl + shift + p，然后输入 reload window，回车，重启一下就生效了。</strong></p>
<span id="more"></span>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode使用eslint格式化代码</title>
    <url>/2020/07/29/vscode%E4%BD%BF%E7%94%A8eslint%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h4 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h4><h4 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h4><p><strong>EditorConfig和Prettier一样，都是用来配置格式化你的代码的，这个格式化代码，要和你的<code>lint</code>配置相符，否则会出现你格式化代码以后，却不能通过你的代码校验工具的校验</strong></p>
<p>editorConfig不是什么软件，而是一个名称为.editorconfig的自定义文件。该文件用来定义项目的编码规范，编辑器的行为会与.editorconfig 文件中定义的一致，并且其优先级比编辑器自身的设置要高，这在多人合作开发项目时十分有用而且必要</p>
<p>有些编辑器默认支持editorConfig，如webstorm；而有些编辑器则需要安装editorConfig插件，如ATOM、Sublime、VS Code等</p>
<p>当打开一个文件时，EditorConfig插件会在打开文件的目录和其每一级父目录查找.editorconfig文件，直到有一个配置文件root=true</p>
<p>EditorConfig的配置文件是从上往下读取的并且最近的EditorConfig配置文件会被最先读取. 匹配EditorConfig配置文件中的配置项会按照读取顺序被应用, 所以最近的配置文件中的配置项拥有优先权</p>
<h5 id="官网的一个配置"><a href="#官网的一个配置" class="headerlink" title="官网的一个配置"></a>官网的一个配置</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># EditorConfig is awesome: https://EditorConfig.org</span><br><span class="line"></span><br><span class="line"># top-most EditorConfig file 表示是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件</span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line"># Unix-style newlines with a newline ending every file 对于所有的文件  始终在文件末尾插入一个新行</span><br><span class="line">[*]</span><br><span class="line">end_of_line = lf</span><br><span class="line">insert_final_newline = true</span><br><span class="line"></span><br><span class="line"># Matches multiple files with brace expansion notation</span><br><span class="line"># Set default charset  对于所有的js,py文件，设置文件字符集为utf-8</span><br><span class="line">[*.&#123;js,py&#125;]</span><br><span class="line">charset = utf-8</span><br><span class="line"></span><br><span class="line"># 4 space indentation 控制py文件类型的缩进大小</span><br><span class="line">[*.py]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 4</span><br><span class="line"></span><br><span class="line"># Tab indentation (no size specified) 设置某中文件的缩进风格为tab Makefile未指明</span><br><span class="line">[Makefile]</span><br><span class="line">indent_style = tab</span><br><span class="line"></span><br><span class="line"># Indentation override for all JS under lib directory  设置在lib目录下所有JS的缩进为</span><br><span class="line">[lib/**.js]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br><span class="line"></span><br><span class="line"># Matches the exact files either package.json or .travis.yml 设置确切文件 package.json/.travis/.yml的缩进类型</span><br><span class="line">[&#123;package.json,.travis.yml&#125;]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>editorConfig配置文件需要是UTF-8字符集编码的, 以回车换行或换行作为一行的分隔符</p>
<p>斜线(/)被用作为一个路径分隔符，井号(#)或分号(;)被用作于注释. 注释需要与注释符号写在同一行</p>
<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">*                匹配除/之外的任意字符串</span><br><span class="line">**               匹配任意字符串</span><br><span class="line">?                匹配任意单个字符</span><br><span class="line">[name]           匹配name中的任意一个单一字符</span><br><span class="line">[!name]          匹配不存在name中的任意一个单一字符</span><br><span class="line">&#123;s1,s2,s3&#125;       匹配给定的字符串中的任意一个(用逗号分隔) </span><br><span class="line">&#123;num1..num2&#125;   　匹配num1到num2之间的任意一个整数, 这里的num1和num2可以为正整数也可以为负整数</span><br></pre></td></tr></table></figure>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>所有的属性和值都是忽略大小写的. 解析时它们都是小写的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">indent_style    设置缩进风格(tab是硬缩进，space为软缩进)</span><br><span class="line">indent_size     用一个整数定义的列数来设置缩进的宽度，如果indent_style为tab，则此属性默认为tab_width</span><br><span class="line">tab_width       用一个整数来设置tab缩进的列数。默认是indent_size</span><br><span class="line">end_of_line     设置换行符，值为lf、cr和crlf</span><br><span class="line">charset         设置编码，值为latin1、utf-8、utf-8-bom、utf-16be和utf-16le，不建议使用utf-8-bom</span><br><span class="line">trim_trailing_whitespace  设为true表示会去除换行行首的任意空白字符。</span><br><span class="line">insert_final_newline      设为true表示使文件以一个空白行结尾</span><br><span class="line">root        　　　表示是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件</span><br></pre></td></tr></table></figure>
<h5 id="控制指定文件类型的缩进大小"><a href="#控制指定文件类型的缩进大小" class="headerlink" title="控制指定文件类型的缩进大小"></a>控制指定文件类型的缩进大小</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[&#123;*.json,*.yml&#125;]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br></pre></td></tr></table></figure>
<h5 id="文件末尾新行"><a href="#文件末尾新行" class="headerlink" title="文件末尾新行"></a>文件末尾新行</h5><p>始终在文件末尾插入一个新行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*]</span><br><span class="line">end_of_line = lf</span><br><span class="line">insert_final_newline = true</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>对于所有的文件</p>
<ul>
<li>每一行的尾部自动调整为 Lf</li>
<li>文件的末尾是一个空行</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vuejs常用api</title>
    <url>/2020/07/01/vuejs%E5%B8%B8%E7%94%A8api/</url>
    <content><![CDATA[<h4 id="vm-nextTick-callback"><a href="#vm-nextTick-callback" class="headerlink" title="vm.$nextTick([callback])"></a>vm.$nextTick([callback])</h4><ul>
<li><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul>
<li><code>&#123;Function&#125; [callback]</code></li>
</ul>
</li>
<li><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法<code>Vue.nextTick</code>一样，不同的是回调的<code>this</code>自动绑定到调用它的实例上。</p>
</li>
<li><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        example: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 修改数据</span></span><br><span class="line">            <span class="built_in">this</span>.message = <span class="string">&#x27;changed&#x27;</span></span><br><span class="line">            <span class="comment">// DOM还没有更新</span></span><br><span class="line">            <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// DOM现在更新了</span></span><br><span class="line">                <span class="comment">// `this`绑定到当前实例</span></span><br><span class="line">                <span class="built_in">this</span>.doSomethingElse()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="一点理解"><a href="#一点理解" class="headerlink" title="一点理解"></a>一点理解</h5><p><code>nextTick()</code> 函数是将回调函数延迟在下一次 dom 更新数据后调用；简单的理解就是： <em>当数据更新了，在 dom 中渲染后，自动执行该函数。</em></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之inject的用法</title>
    <url>/2020/09/10/vue%E4%B9%8Binject%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>inject 选项可以是：一个字符串数组、或一个对象，对象的 key 是本地的绑定名，value 是在可用的注入内容中搜索用的 key(字符串 或 Symbol)。</p>
<p><strong>使用场景：由于 Vue 有 $parent 属性可以让子组件访问父组件，但是孙组件想要访问祖先组件就比较困难。通过 provide/inject 可以轻松实现跨级访问祖先组件的数据。</strong><br><span id="more"></span></p>
<p>一个栗子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    id&#x3D;&quot;app&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;router-view</span><br><span class="line">      v-if&#x3D;&quot;isRouterAlive&quot;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MergeTipDialog,</span><br><span class="line">    BreakNetTip</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isShow: false,</span><br><span class="line">      isRouterAlive: true</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件中返回要传给下级的数据</span><br><span class="line">  provide () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      reload: this.reload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reload () &#123;</span><br><span class="line">      this.isRouterAlive &#x3D; false</span><br><span class="line">      this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">        this.isRouterAlive &#x3D; true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;popup-assign</span><br><span class="line">    :id&#x3D;&quot;id&quot;</span><br><span class="line">    @success&#x3D;&quot;successHandle&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;confirm-d-tit&quot;&gt;&lt;span class&#x3D;&quot;gray-small-btn&quot;&gt;&#123;&#123; name &#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;strong&gt;将被分配给&lt;&#x2F;strong&gt;</span><br><span class="line">    &lt;a</span><br><span class="line">      slot&#x3D;&quot;reference&quot;</span><br><span class="line">      class&#x3D;&quot;unite-btn&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      指派</span><br><span class="line">    &lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;popup-assign&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import PopupAssign from &#39;..&#x2F;PopupAssign&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">&#x2F;&#x2F;引用vue reload方法</span><br><span class="line">  inject: [&#39;reload&#39;],</span><br><span class="line">  components: &#123;</span><br><span class="line">    PopupAssign</span><br><span class="line">  &#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; ...mapActions([&#39;freshList&#39;]),</span><br><span class="line">    async successHandle () &#123;</span><br><span class="line">      this.reload()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插槽作用域</title>
    <url>/2020/07/02/vue%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<p>定义：是vuejs中一个很有用的特性，可以显著的提高组件的通用性和可复用性。</p>
<h4 id="组件和插槽比较"><a href="#组件和插槽比较" class="headerlink" title="组件和插槽比较"></a>组件和插槽比较</h4><p>父组件通过<code>prop</code>向子组件传递数据，通过插槽向子组件传递内容。</p>
<p>共同点：都是从上(父)往下(子)传递数据</p>
<p>区别：Prop传递的是组件的属性，而插槽传递的是<code>VNode</code>节点。</p>
<p><strong>作用域插槽：是从下(子)往上(父)传递数据，官方描述<code>可从子组件获取数据</code></strong></p>
<h4 id="什么是插槽"><a href="#什么是插槽" class="headerlink" title="什么是插槽"></a>什么是插槽</h4><p>在组件中，使用<code>&lt;slot&gt;&lt;/slot&gt;</code>定义一个插槽，那么该组件在其他组件(父组件)中使用时，父组件的该组件 <strong>中间的内容</strong> 会被替换掉插槽所在位置。</p>
<h5 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h5><blockquote>
<p>父级模板中的所有内容都是在父级作用域中编译的；子模版里的所有内容都是在子作用域中编译的。</p>
</blockquote>
<h5 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h5><p>指给插槽设置具体的后备（默认的）内容是很有用的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义一个含插槽的组件SubmitButton --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父组件定义为这样(1) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">submit-button</span>&gt;</span><span class="tag">&lt;/<span class="name">submit-button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被渲染为（1） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父组件定义为这样(2) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">submit-button</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">submit-button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被渲染为（2） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  Save	</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h5><p>给<code>&lt;slot&gt;</code>指定一个特殊的属性： <code>name</code>;</p>
<p>其中不带name属性的<code>&lt;slot&gt;</code>会带一个隐式的名字<code>default</code>。</p>
<p>在向具名插槽提供内容的时候，我们可以在一个<code>&lt;template&gt;</code>元素上使用<code>v-slot</code>指令，并以<code>v-slot</code>的参数的形式提供其名称</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在<code>&lt;template&gt;</code>元素中的内容会被传入相应的插槽中。</p>
<p>任何没有被带有<code>v-slot</code>的<code>&lt;template&gt;</code>元素包裹的内容都会被视为默认插槽的内容。</p>
<p>当然，你也可以指定默认插槽的名称。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5><p>有时让插槽内容能够访问子组件才有的数据是很有用的。</p>
<p>为了让子组件的某个数据如<code>user</code>在父级的插槽内容中可用，我们可以将<code>user</code>作为<code>&lt;slot&gt;</code>元素的一个attribute绑定上去：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>绑定在<code>&lt;slot&gt;</code>元素上的attribute被称为 <strong>插槽prop</strong>。</p>
<p>现在在父级作用域中，我们可以使用带值的<code>v-slot</code>来定义我们提供的<strong>插槽prop</strong>的名字：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述的例子中，将包含插槽prop的对象命名为<code>slotProps</code>,实际上，你可以使用任意你喜欢的名字。</p>
<h5 id="独占默认插槽的缩写写法"><a href="#独占默认插槽的缩写写法" class="headerlink" title="独占默认插槽的缩写写法"></a>独占默认插槽的缩写写法</h5><p>可以将v-slot直接使用在组件上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用不带参数的v-slot来假定为默认插槽</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意: 默认插槽的缩写写法不能和具名插槽混用，因为他会导致作用域不明</strong></p>
<p><strong>因此，只要出现多个插槽，请始终为所有的插槽使用完整的基于<code>&lt;template&gt;</code>的语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="解构插槽Prop"><a href="#解构插槽Prop" class="headerlink" title="解构插槽Prop"></a>解构插槽Prop</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以将user重命名为person</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user: person &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; person.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>甚至可以定义后备内容，用于插槽prop是<code>undefined</code>的情形</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h5><p>和<code>v-bind</code>、<code>v-on</code>一样，<code>v-slot</code>也有缩写。</p>
<p>可以把参数之前的内容(<code>v-slot:</code>)替换为字符<code>#</code>。</p>
<p>如<code>v-slot:header</code>可以被重写为<code>#header</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>然而，和其他的指令一样，该缩写只有在其存在参数的时候才有效。</strong></p>
<p>所以下面的语法是无效的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这样会触发一个警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>如果你希望使用缩写的话，那么你必须以明确的插槽名来取而代之</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #<span class="attr">default</span>=<span class="string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="作用域插槽的一些理解"><a href="#作用域插槽的一些理解" class="headerlink" title="作用域插槽的一些理解"></a>作用域插槽的一些理解</h5><p>作用域插槽可以在父组件中访问子组件中的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">...</span><br><span class="line">child</span><br><span class="line">&#x2F;&#x2F; 在子组件上，给 slot 绑定一个属性，我们叫做 ‘插槽prop’</span><br><span class="line">&lt;slot :user&#x3D;&quot;&quot; &gt;&lt;&#x2F;slot&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; vue 2.6 之前</span><br><span class="line">&lt;child slot-scope&#x3D;&quot;scope&quot;&gt;&#123;&#123;scope.user&#125;&#125;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F; vue 2.6 之后</span><br><span class="line">&lt;child v-slot:default&#x3D;&quot;scope&quot;&gt;&#123;&#123;scope.user&#125;&#125;&lt;&#x2F;child&gt;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">&lt;child v-slot&#x3D;&quot;scope&quot;&gt;&#123;&#123;scope.user&#125;&#125;&lt;&#x2F;child&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插槽作用域</title>
    <url>/2020/07/02/vue%E6%8F%92%E6%A7%BD%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>定义：是vuejs中一个很有用的特性，可以显著的提高组件的通用性和可复用性。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vue数据存储</title>
    <url>/2020/09/09/vue%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h4 id="localStorage-和-SessionStorage-的区别"><a href="#localStorage-和-SessionStorage-的区别" class="headerlink" title="localStorage 和 SessionStorage 的区别"></a>localStorage 和 SessionStorage 的区别</h4><ul>
<li>localStorage 没有时间限制的数据存储</li>
<li>sessionStorage 针对一个 session 的数据存储(关闭窗口，存储的数据清空)</li>
</ul>
<p>都是存储在浏览器端的<br><span id="more"></span></p>
<h4 id="vuex是什么"><a href="#vuex是什么" class="headerlink" title="vuex是什么"></a>vuex是什么</h4><p>官方定义：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>Vuex 是一种设计思想。每一个 Vuex 应用的核心就是 Store(仓库)。组件的状态和数据都放到一个统一的内存空间 state 去管理，state 的数据映射到组件上，当组件的数据发生变化时，通过 Dispatch Action 或者直接 Commit Mutations 的方法修改 state。我们不能直接改变 state 中的状态。改变 state 中状态的唯一途径就是显式的提交（Commit）Mutations。这样使得我们可以方便的追踪每一个状态的变化，从而使我们能够实现一些功能帮助我们更好的了解我们的应用。state 修改后反映到组件上，形成闭环。</p>
<p>当父子组件之间通信的时候，我们通常会采用 <code>props + emit</code> 的方式。Vuex 适合更为复杂的使用场景。<br>比如：</p>
<ul>
<li>解决多个关联度比较低的兄弟组件之间的状态共享</li>
<li>解决路由跳转复杂的参数传递</li>
</ul>
<h4 id="vue-store"><a href="#vue-store" class="headerlink" title="vue store"></a>vue store</h4><h5 id="state-mutations-getter-actions"><a href="#state-mutations-getter-actions" class="headerlink" title="state mutations getter actions"></a>state mutations getter actions</h5><ul>
<li>state 对数据的全局存储</li>
<li>mutations 对数据的同步更改</li>
<li>getter 可以理解为 computed，对数据进行计算</li>
<li>actions 对数据的异步更改</li>
</ul>
<p>一个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$store);</span><br><span class="line">    <span class="comment">/*payLoad 所有的参数对象 &#123;a:aa,b:bb&#125;*/</span></span><br><span class="line">    <span class="comment">/*调用mutation方法*/</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;mutationsFun&quot;</span>, payLoad)</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/*调用action 方法*/</span></span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;ActionsFun&quot;</span>,payLoad)</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">counter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h4 id="vue-store-存储-commit-和-dispatch"><a href="#vue-store-存储-commit-和-dispatch" class="headerlink" title="vue store 存储 commit 和 dispatch"></a>vue store 存储 commit 和 dispatch</h4><p>区别：</p>
<ul>
<li>dispatch 含有异步操作，例如向后台提交数据，写法： <code>this.$store.dispatch(&#39;mutations方法名&#39;, 值)</code></li>
<li>commit 同步操作，写法： <code>this.$store.commit(&#39;mutations方法名&#39;, 值)</code> </li>
</ul>
]]></content>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期钩子</title>
    <url>/2020/09/08/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<h4 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h4><p><img src="http://wrr123.github.io/2020/09/08/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/lifecycle.png" alt></p>
<span id="more"></span>
<h4 id="实例的生命周期钩子"><a href="#实例的生命周期钩子" class="headerlink" title="实例的生命周期钩子"></a>实例的生命周期钩子</h4><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程 — 例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 <strong>生命周期钩子</strong> 的函数,这给了用户在不同阶段添加自己代码的机会。</p>
<p>比如 <code>created</code> 钩子可以用来在一个实例被创建之后执行代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">	a: 1</span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">	&#x2F;&#x2F; this 指向 vm 实例</span><br><span class="line">	console.log(&#39;a is: &#39; + this.a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure></p>
<p>也有一些其他的钩子，在实例生命周期的不同阶段被调用，如 <code>mounted</code>、<code>updated</code> 和 <code>destroyed</code> 。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p>
<h4 id="简述生命周期函数钩子"><a href="#简述生命周期函数钩子" class="headerlink" title="简述生命周期函数钩子"></a>简述生命周期函数钩子</h4><p>先后顺序：</p>
<ul>
<li>beforeCreated</li>
<li>created</li>
<li>beforeMounted</li>
<li>mounted</li>
<li>beforeUpdated</li>
<li>updated</li>
<li>beforeDestroyed</li>
<li>destroyed</li>
</ul>
<h4 id="生命周期-created-和-mounted-两者间的区别"><a href="#生命周期-created-和-mounted-两者间的区别" class="headerlink" title="生命周期 created 和 mounted 两者间的区别"></a>生命周期 created 和 mounted 两者间的区别</h4><ul>
<li><code>created</code>: 在模板渲染成 HTML 前调用，即通常初始化某些属性值，然后再渲染成视图。</li>
<li><code>mounted</code>: 在模板渲染成 HTML 后调用，通常是初始化页面完成后，再对 HTML 的 dom 节点进行一些需要的操作。</li>
</ul>
]]></content>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件</title>
    <url>/2020/08/27/vue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><h5 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h5><p>在注册一个组件的时候，我们始终需要给它一个名字。不如我们在全局注册的时候已经看到了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-compoment-name&#x27;</span>, &#123;<span class="comment">/* ... */</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>该组件名就是 <code>Vue.component</code> 的第一个参数。</strong></p>
<h5 id="组件名大小写"><a href="#组件名大小写" class="headerlink" title="组件名大小写"></a>组件名大小写</h5><p>定义组件名的方式有两种：</p>
<h6 id="使用-kebab-case"><a href="#使用-kebab-case" class="headerlink" title="使用 kebab-case"></a>使用 kebab-case</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 ``</p>
</blockquote>
<h6 id="使用-PascalCase"><a href="#使用-PascalCase" class="headerlink" title="使用 PascalCase"></a>使用 PascalCase</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;MyComponentName&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>和</code> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。</p>
</blockquote>
<span id="more"></span>
<h5 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h5><p>使用 <code>Vue.component</code> 来创建组件，这些组件都是 <strong>全局注册</strong> 的。</p>
<p>全局注册的组件可以在任何新创建的 <strong>Vue根实例（new Vue）</strong> 的模板中使用。</p>
<p>一个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;component-a&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line">Vue.component(<span class="string">&#x27;component-b&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line">Vue.component(<span class="string">&#x27;component-c&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-b</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-c</span>&gt;</span><span class="tag">&lt;/<span class="name">component-c</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在所有的子组件中也是如此，也就是说这三个组件 <em>在各自内部</em> 也都可以相互使用。</p>
<h5 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h5><blockquote>
<p>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p>
</blockquote>
<h5 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h5><h6 id="在模块系统中局部注册"><a href="#在模块系统中局部注册" class="headerlink" title="在模块系统中局部注册"></a>在模块系统中局部注册</h6><p>在一个假设的 <code>ComponentB.js</code> 或 <code>ComponentB.vue</code> 文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;./ComponentA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ComponentB <span class="keyword">from</span> <span class="string">&#x27;./ComponentB&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentB</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="基础组件的自动化全局注册"><a href="#基础组件的自动化全局注册" class="headerlink" title="基础组件的自动化全局注册"></a>基础组件的自动化全局注册</h6><blockquote>
<p>可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为<a href="https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐">基础组件</a>，它们会在各个组件中被频繁的用到。</p>
</blockquote>
<p>如果你恰好使用了 webpack （或在内部使用了 webpack 的 Vue CLI 3+），那么就可以使用 <code>require.context</code> 只全局注册这些非常通用的基础组件。</p>
<p>一个栗子：让你在应用入口文件（比如 <code>main.js</code>）中全局导入基础组件的示例代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">&#x27;lodash/upperFirst&#x27;</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">&#x27;lodash/camelCase&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">&#x27;./components&#x27;</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 获取和目录深度无关的文件名</span></span><br><span class="line">      fileName</span><br><span class="line">        .split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>记住 <strong>全局注册的行为必须在根 Vue 实例（通过 new Vue）创建之前发生。</strong></p>
<h4 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h4><h5 id="Prop的大小写（camelCase-vs-kebab-case）"><a href="#Prop的大小写（camelCase-vs-kebab-case）" class="headerlink" title="Prop的大小写（camelCase vs kebab-case）"></a>Prop的大小写（camelCase vs kebab-case）</h5><hr>
<p>HTML 中的 attribute 名是大小写 <strong>不敏感</strong> 的，所以浏览器会把所有大写字符解释为小写字符。</p>
<p>这意味着当你使用 DOM 中的模板时，camelCase（驼峰命名法）的 prop 名需要使用其等价的 kebab-case（短横线分割命名）命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">&#x27;postTitle&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>重申一次，如果你使用字符串模板，那么这个限制就不存在了。</strong></p>
<h5 id="Prop-类型"><a href="#Prop-类型" class="headerlink" title="Prop 类型"></a>Prop 类型</h5><p>上面，我们只接触了 <strong>字符串数组类型</strong> 形式列出的 prop，</p>
<p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不仅为你的组件提供了文档，还会再它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。</p>
<h5 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a>传递静态或动态 Prop</h5><ul>
<li>传入一个数字</li>
<li>传入一个布尔值</li>
<li>传入一个数组</li>
<li>传入一个对象</li>
<li>传入一个对象的所有 property</li>
</ul>
<h5 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h5><blockquote>
<p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
</blockquote>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><h5 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h5><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>
<p>一个栗子：触发一个名为 camcelCase 名字的事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;myEvent&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>那么监听这个名字的 kebab-case 版本是不会有任何效果的</strong></p>
<p>一个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有效果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:my-event</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p>
<p>因此，我们推荐你<strong>始终使用 kebab-case 的事件名</strong>。</p>
</blockquote>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><h5 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h5><p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <strong>Web Component 规范草案</strong>，将 <code>slot</code> 元素作为承载分发内容的出口。</p>
]]></content>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>vue计算属性和侦听器</title>
    <url>/2020/08/10/vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><h5 id="模板内的表达式"><a href="#模板内的表达式" class="headerlink" title="模板内的表达式"></a>模板内的表达式</h5><p>模板内的表达式非常的便利，但是它设计的初衷是用于简单运算的。</p>
<p>在模板中放入太多的逻辑会让模板过重且难以维护。</p>
<p>一个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)&#125;&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理。</p>
</blockquote>
<span id="more"></span>
<h5 id="计算属性的一个栗子"><a href="#计算属性的一个栗子" class="headerlink" title="计算属性的一个栗子"></a>计算属性的一个栗子</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Original Message: &quot;&#123;&#123; message &#125;&#125;&quot;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        <span class="comment">// 计算属性的getter</span></span><br><span class="line">        reversedMessage () &#123;</span><br><span class="line">            <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<ul>
<li>Original message: “Hello”</li>
<li>Computed reversed message: “olleH”</li>
</ul>
<p><strong>这里我们声明了一个计算属性 <code>reversedMessage</code> 。</strong></p>
<p>我们提供的函数将用作 property <code>vm.reversedMessage</code> 的 getter 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// olleH</span></span><br><span class="line">vm.message = <span class="string">&#x27;GoodBye&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// eyBdooG</span></span><br></pre></td></tr></table></figure>
<p><strong>如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</strong></p>
<p>一个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    aDouble: <span class="function"><span class="params">vm</span> =&gt;</span> vm.a * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="计算属性-vs-方法"><a href="#计算属性-vs-方法" class="headerlink" title="计算属性 vs 方法"></a>计算属性 vs 方法</h4><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方法的最终结果确实是完全相同的，然而，不同的是 <strong>计算属性是基于它们的响应式依赖进行缓存的。</strong> 只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>这也同样意味着下面的计算属性将不再更新，因为 <strong><code>Date.now()</code></strong> 不是响应式依赖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    now: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比之下，每当触发重新渲染时，调用方法 <strong>总会</strong> 再次执行函数。</p>
<blockquote>
<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <strong>A</strong>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <strong>A</strong>。如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter！如果你不希望有缓存，请用方法来替代。</p>
</blockquote>
<h4 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h4><p>Vue提供了一种更通用的方式来观察和响应Vue实例上的数据变动：<strong>侦听属性。</strong>当你有一些数据需要随着其他数据的变动而变动时，你很容易滥用 <code>watch</code> ——特别是如果你之前使用过 AngularJS 。然而，通常更好的做法是使用 <strong>计算属性</strong> 而不是命令式的 <code>watch</code> 回调。</p>
<p>细想下面的一个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; fullName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">        lastName: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">        fullName: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        firstName: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        lastName: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><em>上面的代码是命令式且重复的。</em></p>
<p>将它与计算属性的版本进行比较：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">        lastName: <span class="string">&#x27;Bar&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        fullName: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h4><p>计算属性默认只有 getter， 不过在需要时你也可以提供一个 setter：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    fullName: &#123;</span><br><span class="line">        <span class="comment">// getter</span></span><br><span class="line">        get: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// setter    </span></span><br><span class="line">        set: <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>现在再运行 <code>vm.fullName = &#39;Jhon Doe&#39;</code> 时，setter会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应的被更新。</p>
<h4 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h4><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。</p>
<p>这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。</p>
<p><strong>当需要在数据变化时，执行异步或开销较大的操作时，这个方式是最有用的。</strong></p>
<p>一个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;watch-example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Ask a yes/no question:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;question&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; answer &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span><br><span class="line">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#watch-example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    answer: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    question: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.answer = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="line">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="line">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="line">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="line">    <span class="built_in">this</span>.debouncedGetAnswer = _.debounce(<span class="built_in">this</span>.getAnswer, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getAnswer: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.question.indexOf(<span class="string">&#x27;?&#x27;</span>) === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.answer = <span class="string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.answer = <span class="string">&#x27;Thinking...&#x27;</span></span><br><span class="line">      <span class="keyword">var</span> vm = <span class="built_in">this</span></span><br><span class="line">      axios.get(<span class="string">&#x27;https://yesno.wtf/api&#x27;</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">          vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">          vm.answer = <span class="string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>在这了栗子中，使用 <code>watch</code> 选项允许我们执行异步操作(访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<p><em>除了 <code>watch</code> 选项之外，你还可以使用命令式的 <code>vm.$watch API</code> 。</em></p>
<h4 id="computed-的-get-和-set-用法"><a href="#computed-的-get-和-set-用法" class="headerlink" title="computed 的 get() 和 set() 用法"></a>computed 的 get() 和 set() 用法</h4><p>当原属性的值发生变化的时候，执行计算属性的 get()，<br>当计算属性发生变化的时候，先执行计算属性的 set()，再执行计算属性的 get() 。</p>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack入门指南</title>
    <url>/2020/08/24/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p>
<p><img src="http://wrr123.github.io/2020/08/24/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/001.png" alt></p>
<span id="more"></span>
<h4 id="使用-webpack-打包后的-vue-项目如何运行"><a href="#使用-webpack-打包后的-vue-项目如何运行" class="headerlink" title="使用 webpack 打包后的 vue 项目如何运行"></a>使用 webpack 打包后的 vue 项目如何运行</h4><p>可以部署到 express 服务器上运行。</p>
<ol>
<li><p>安装 express-generator 生成器</p>
<p><code>npm install express-generator -g // 也可使用cnpm比较快</code></p>
</li>
<li><p>创建一个 express 项目</p>
<p><code>express expressName // expressName 为项目名</code></p>
</li>
<li><p>进入项目目录，安装相关项目依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> expressName</span><br><span class="line">npm install <span class="comment"># 或者 cnpm install</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此时生成的项目目录是这样的：</p>
<p><img src="http://wrr123.github.io/2020/08/24/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/002.png" alt></p>
</li>
<li><p>将 dist 文件夹下的所有文件复制到 express 项目的 public 文件夹下面，然后运行 <code>npm start</code> 来启动 express 项目。</p>
</li>
<li><p>打开浏览器，输入 <code>localhost:3000</code> 就可以看到效果了。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title>window.location.href和window.open的几种用法和区别</title>
    <url>/2020/07/09/window-location-href%E5%92%8Cwindow-open%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="Window-Location"><a href="#Window-Location" class="headerlink" title="Window Location"></a>Window Location</h4><p>window.location对象在编写时，可以不使用window这个前缀。</p>
<p>一些例子：</p>
<ul>
<li>location.hostname 返回web主机的域名</li>
<li>location.pathname 返回当前页面的路径和文件名</li>
<li>location.port 返回web主机的端口</li>
<li>location.protocal 返回所使用的web协议(如http，https)</li>
</ul>
<h4 id="Window-Location-Href"><a href="#Window-Location-Href" class="headerlink" title="Window Location Href"></a>Window Location Href</h4><p>该属性返回当前页面的URL</p>
<h4 id="Window-Location-Pathname"><a href="#Window-Location-Pathname" class="headerlink" title="Window Location Pathname"></a>Window Location Pathname</h4><p>该属性返回URL的路径名</p>
<h4 id="Window-Location-Assign"><a href="#Window-Location-Assign" class="headerlink" title="Window Location Assign"></a>Window Location Assign</h4><p><code>location.assign()</code>该方法加载新的文档</p>
<h4 id="location-href常见的几种形式"><a href="#location-href常见的几种形式" class="headerlink" title="location.href常见的几种形式"></a>location.href常见的几种形式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.location.href;<span class="comment">//当前页面打开URL页面</span></span><br><span class="line"><span class="built_in">window</span>.location.href;<span class="comment">//当前页面打开URL页面</span></span><br><span class="line"><span class="built_in">this</span>.location.href;<span class="comment">//当前页面打开URL页面</span></span><br><span class="line">location.href;<span class="comment">// 当前页面打开URL页面</span></span><br><span class="line">parent.location.href;<span class="comment">//在父页面打开新页面</span></span><br><span class="line">top.location.href;<span class="comment">//在顶层页面打开新页面   </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：①如果页面中自定义了frame，那么可将parent、self、top换为自定义frame的名称,效果是在frame窗口打开url地址。</p>
<p>②此外，window.location.href=window.location.href;和window.location.Reload();都是刷新当前页面。区别在于是否有提交数据。当有提交数据时，window.location.Reload()会提示是否提交，window.location.href=window.location.href;则是向指定的url提交数据.</p>
<p>③用window.open()打开新页面<br>但是用window.location.href＝”” 却是在原窗口打开的.<br>有时浏览器会一些安全设置window.open肯定被屏蔽。例如避免弹出广告窗口。</p>
</blockquote>
<h4 id="window-location-href和window-open-之间的区别"><a href="#window-location-href和window-open-之间的区别" class="headerlink" title="window.location.href和window.open()之间的区别"></a>window.location.href和window.open()之间的区别</h4><ol>
<li><p>```text<br>window.location是window对象的属性，而window.open是window对象的方法<br>  window.location是你对当前浏览器窗口的URL地址对象的参考！<br>  window.open是用来打开一个新窗口的函数！ </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;text</span><br><span class="line">   window.open不一定是打开一个新窗口!!!!!!!!   </span><br><span class="line">     只要有窗口的名称和window.open中第二个参数中的一样就会将这个窗口替换，用这个特性的话可以在iframe和frame中来代替location.href。 </span><br><span class="line">   如&lt;iframe name&#x3D;&quot;aa&quot;&gt;&lt;&#x2F;iframe&gt;   </span><br><span class="line">     &lt;input type&#x3D;button   onclick&#x3D;&quot;window.open(&#39;1.htm&#39;,&#39;aa&#39;,&#39;&#39;)&quot;&gt;和   </span><br><span class="line">     &lt;input type&#x3D;button   </span><br><span class="line">      onclick&#x3D;&quot;self.frames[&#39;aa&#39;].location.href&#x3D;&#39;1.htm&#39;&quot;&gt;的效果一样 </span><br></pre></td></tr></table></figure>
</li>
<li><p>```text<br>在给按钮、表格、单元格、下拉列表和DIV等做链接时一般都要用Javascript来完成，和做普通链接一样，可能我们需要让链接页面在当前窗口打开，也可能需要在新窗口打开，这时我们就可以使用下面两项之一来完成： </p>
<pre><code>window.open 用来打开新窗口 
window.location 用来替换当前页，也就是重新定位当前页 
可以用以下来个实例来测试一下。 
</code></pre><p><input type="button" value="新窗口打开" onclick="window.open('http://www.google.com')"><br><input type="button" value="当前页打开" onclick="window.location='http://www.google.com/'"> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;text</span><br><span class="line">   window.location或window.open如何指定target? </span><br><span class="line">   这是一个经常遇到的问题，特别是在用frame框架的时候 </span><br><span class="line">   解决办法: </span><br><span class="line">   window.location 改为 top.location　即可在顶部链接到指定页 </span><br><span class="line">   或 </span><br><span class="line">   window.open(&quot;你的网址&quot;,&quot;_top&quot;); </span><br></pre></td></tr></table></figure>
</li>
<li><p>```text<br>window.open 用来打开新窗口<br>window.location 用来替换当前页，也就是重新定位当前页 </p>
<p>用户不能改变document.location(因为这是当前显示文档的位置)。<br>window.location本身也是一个对象。 </p>
<p>   但是,可以用window.location改变当前文档 (用其它文档取代当前文档),而document.location不是对象。<br>   服务器重定向后有可能使document.url变动,但window.location.href指的永远是访问该网页时用的URL.<br>   大多数情况下,document.location和location.href是相同的，但是，当存在服务器重定向时，document.location包含的是已经装载的URL，而location.href包含的则是原始请求的文档的URL.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. &#96;&#96;&#96;text</span><br><span class="line">   window.open()是可以在一个网站上打开另外的一个网站的地址 </span><br><span class="line">   而window.location()是只能在一个网站中打开本网站的网页 </span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn</title>
    <url>/2020/08/20/yarn/</url>
    <content><![CDATA[<h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>Yarn 对你的代码来说是一个包管理器。它可以让你使用并分享 <strong>全世界开发者的（例如 JavaScript）</strong> 代码。Yarn 能够快速、安全、并可靠地完成这些工作，所以你不用有任何担心。</p>
<p>通过 Yarn 你可以使用其他开发者针对不同问题的解决方案，使自己的开发过程更简单。使用过程中遇到问题，你可以将其上报或者贡献解决方案。一旦问题被修复，Yarn 会更新保持同步。</p>
<p>代码通过 <strong>包（package）</strong> （或者称为 <strong>模块（module）</strong>） 的方式来共享。一个包里包含所有需要共享的代码，一级描述包信息的文件，称为 <code>package.json</code> 。</p>
<span id="more"></span>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="初始化一个项目"><a href="#初始化一个项目" class="headerlink" title="初始化一个项目"></a>初始化一个项目</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure>
<h5 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add [package]</span><br><span class="line">yarn add [package]@[version]</span><br><span class="line">yarn add [package]@[tag]</span><br></pre></td></tr></table></figure>
<h5 id="将依赖项添加到不同依赖项类别中"><a href="#将依赖项添加到不同依赖项类别中" class="headerlink" title="将依赖项添加到不同依赖项类别中"></a>将依赖项添加到不同依赖项类别中</h5><p>分别添加到 <code>devDependencies、peerDenpendencies 和 optionalDependencies</code> 类别中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn add [package] --dev</span><br><span class="line">yarn add [packae] --peer</span><br><span class="line">yarn add [package] --optional</span><br></pre></td></tr></table></figure>
<h5 id="升级依赖包"><a href="#升级依赖包" class="headerlink" title="升级依赖包"></a>升级依赖包</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn upgrade [package]</span><br><span class="line">yarn upgrade [package]@[version]</span><br><span class="line">yarn upgrade [package]@[tag]</span><br></pre></td></tr></table></figure>
<p>移除依赖包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn remove [package]</span><br></pre></td></tr></table></figure>
<h5 id="安装项目的全部依赖"><a href="#安装项目的全部依赖" class="headerlink" title="安装项目的全部依赖"></a>安装项目的全部依赖</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<h4 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h4><h5 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn save 软件名 --registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>
<h5 id="全局修改"><a href="#全局修改" class="headerlink" title="全局修改"></a>全局修改</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>
<h5 id="使用第三方软件快速修改"><a href="#使用第三方软件快速修改" class="headerlink" title="使用第三方软件快速修改"></a>使用第三方软件快速修改</h5><p><code>yrm</code> Yarn registry manager</p>
<p>yrm 不仅可以快速切换镜像源，还可以测试自己网络访问不同源的速度。</p>
<h6 id="安装-yrm"><a href="#安装-yrm" class="headerlink" title="安装 yrm"></a>安装 <code>yrm</code></h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g yrm</span><br></pre></td></tr></table></figure>
<h6 id="列出当前可用的所有镜像源"><a href="#列出当前可用的所有镜像源" class="headerlink" title="列出当前可用的所有镜像源"></a>列出当前可用的所有镜像源</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yrm ls</span><br><span class="line"></span><br><span class="line">    npm -----  https://registry.npmjs.org/</span><br><span class="line">    cnpm ----  http://r.cnpmjs.org/</span><br><span class="line">    taobao --  https://registry.npm.taobao.org/</span><br><span class="line">    nj ------  https://registry.nodejitsu.com/</span><br><span class="line">    rednpm -- http://registry.mirror.cqupt.edu.cn</span><br><span class="line">    skimdb -- https://skimdb.npmjs.com/registry</span><br><span class="line">    yarn ----  https://registry.yarnpkg.com</span><br></pre></td></tr></table></figure>
<h6 id="使用淘宝镜像"><a href="#使用淘宝镜像" class="headerlink" title="使用淘宝镜像"></a>使用淘宝镜像</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yrm use taobao</span><br></pre></td></tr></table></figure>
<h6 id="测试访问速度"><a href="#测试访问速度" class="headerlink" title="测试访问速度"></a>测试访问速度</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yrm <span class="built_in">test</span> taobao</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>包管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title>三个数的最大乘积-力扣</title>
    <url>/2021/01/20/%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF-%E5%8A%9B%E6%89%A3/</url>
    <content><![CDATA[<h4 id="题目—三个数的最大乘积"><a href="#题目—三个数的最大乘积" class="headerlink" title="题目—三个数的最大乘积"></a>题目—三个数的最大乘积</h4><p>给定一个整数数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1, 2, 3]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h5><h6 id="基本改变"><a href="#基本改变" class="headerlink" title="基本改变"></a>基本改变</h6><p>所谓贪心算法是指，在对问题求解时，总是做出在 <span style="color:red;">在当前看来最好的选择</span> 。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的 <span style="color:red;">局部最优解</span>。</p>
<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有的问题都能得到 <strong>整体最优解</strong>，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响之前的状态，只与当前状态有关。</p>
<p><span style="color:red;">所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</span></p>
<h6 id="贪心算法的基本思路："><a href="#贪心算法的基本思路：" class="headerlink" title="贪心算法的基本思路："></a>贪心算法的基本思路：</h6><ol>
<li>建立数学模型来描述问题；</li>
<li>把求解的问题分成若干个子问题；</li>
<li>对每一子问题求解，得到子问题的局部最优解；</li>
<li>把子问题的解局部最优解合成原来解问题的一个解。</li>
</ol>
<h6 id="贪心算法适用的问题"><a href="#贪心算法适用的问题" class="headerlink" title="贪心算法适用的问题"></a>贪心算法适用的问题</h6><p>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</p>
<p>实际上，<span style="color:red;">贪心算法适用的情况很少</span> 。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>
<h6 id="贪心算法的实现框架"><a href="#贪心算法的实现框架" class="headerlink" title="贪心算法的实现框架"></a>贪心算法的实现框架</h6><p>从问题的某一初始解出发：</p>
<p>while (能朝给定总目标前进一步)  {</p>
<p>   利用可行的决策，求出可行解的一个解元素；</p>
<p>}</p>
<p>由所有解元素组合成问题的一个可行解。</p>
<h6 id="贪心策略的选择"><a href="#贪心策略的选择" class="headerlink" title="贪心策略的选择"></a>贪心策略的选择</h6><p>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适用采用贪心算法策略，找到的解是否一定是问题的最优解。</p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p><span style="color:red;">快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。</span></p>
]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式服务跟踪</title>
    <url>/2021/03/23/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Dalston</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离-how2j</title>
    <url>/2021/03/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-how2j/</url>
    <content><![CDATA[<h4 id="什么是前后端分离"><a href="#什么是前后端分离" class="headerlink" title="什么是前后端分离"></a>什么是前后端分离</h4><p>html页面的内容可以简单的看成包含数据部分和不包含数据部分。所以先准备一个不包含数据的html，把它传给浏览器，这个速度本身非常快，因为没有最占时间的数据库操作部分。然后通过Ajax技术，仅仅从服务器获取 <strong>纯数据</strong>，然后把纯数据显示在html上。</p>
<h4 id="几种实现前后端分离的方式"><a href="#几种实现前后端分离的方式" class="headerlink" title="几种实现前后端分离的方式"></a>几种实现前后端分离的方式</h4><ul>
<li>J2EE方式</li>
<li>SSM方式</li>
<li>Springboot方式</li>
<li>vue + springboot方式</li>
</ul>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>前端部分-how2j</title>
    <url>/2021/03/12/%E5%89%8D%E7%AB%AF%E9%83%A8%E5%88%86-how2j/</url>
    <content><![CDATA[<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><h5 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h5><p>可以在浏览器上设置编码方式为<code>GB2312</code>，或者在html的最前面加上编码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=GB2312&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h5><ul>
<li><p>完整的HTML</p>
<p>一个完整的html文件应该至少包含html元素，body元素，以及里面的内容。</p>
</li>
<li><p>不完整的元素</p>
</li>
<li><p>有的特殊元素</p>
<p>有的特殊元素，没有内容，即开始和结束标签直接放在一起。</p>
<p>比如hr, br等等。</p>
</li>
</ul>
<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><p>属性是用来修饰标签的。</p>
<h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><p>html用<code>&lt;!-- --&gt;</code>来进行注释。</p>
<h5 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h5><div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;h1&gt; 到 &lt;h6&gt;</code></td>
<td>分别表示不同大小的标题</td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>段落，自带换行</td>
</tr>
<tr>
<td><code>&lt;b&gt; 或 &lt;strong&gt;</code></td>
<td>粗体</td>
</tr>
<tr>
<td><code>&lt;i&gt; 或 &lt;em&gt;</code></td>
<td>斜体</td>
</tr>
<tr>
<td><code>&lt;pre&gt;</code></td>
<td>在网页上显示代码，如java代码等</td>
</tr>
<tr>
<td><code>&lt;del&gt;</code></td>
<td>删除线效果</td>
</tr>
<tr>
<td><code>&lt;ins&gt;</code></td>
<td>下划线，其中<u>标签也可以实现下划线效果，但是不建议使用</u></td>
</tr>
<tr>
<td><code>&lt;img&gt;</code></td>
<td>图像</td>
</tr>
<tr>
<td><code>&lt;a&gt;</code></td>
<td>超链接</td>
</tr>
<tr>
<td><code>&lt;table&gt;，&lt;tr&gt;, &lt;td&gt;</code></td>
<td>表格, 行， 单元格</td>
</tr>
<tr>
<td><code>&lt;ul&gt;, &lt;ol&gt;</code></td>
<td>无序列表， 有序列表</td>
</tr>
<tr>
<td><code>&lt;div&gt;, &lt;span&gt;</code></td>
<td>块级元素， 内联元素，它们通常结合CSS来进行页面布局</td>
</tr>
</tbody>
</table>
</div>
<h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><h6 id="字体元素"><a href="#字体元素" class="headerlink" title="字体元素"></a>字体元素</h6><p>font常用的属性有color和size，分别表示颜色和大小。</p>
<h6 id="颜色表示法"><a href="#颜色表示法" class="headerlink" title="颜色表示法"></a>颜色表示法</h6><ul>
<li>颜色名，如<code>red, blue</code></li>
<li>颜色对应的16进制，如<code>#ff0000</code>就表示红色。</li>
</ul>
<h5 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h5><p><code>&lt;iframe&gt;</code>即内联框架，通过内联框架可以实现在网页中<code>插入</code>网页。</p>
<h6 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h6><div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;input type=&quot;text&quot;&gt;</code></td>
<td>文本框</td>
</tr>
<tr>
<td><code>&lt;input type=&quot;password&quot;&gt;</code></td>
<td>密码框</td>
</tr>
<tr>
<td><code>&lt;form&gt;</code></td>
<td>表单</td>
</tr>
<tr>
<td><code>&lt;input type=&quot;radio&quot;&gt;</code></td>
<td>单选框</td>
</tr>
<tr>
<td><code>&lt;input type=&quot;checked&quot;&gt;</code></td>
<td>复选框</td>
</tr>
<tr>
<td><code>&lt;select&gt; &lt;option&gt;</code></td>
<td>下拉列表</td>
</tr>
<tr>
<td><code>&lt;textarea&gt;</code></td>
<td>文本域</td>
</tr>
<tr>
<td><code>&lt;input type=&quot;button&quot;&gt;</code></td>
<td>普通按钮</td>
</tr>
<tr>
<td><code>&lt;input type=&quot;submit&quot;&gt;</code></td>
<td>提交按钮</td>
</tr>
<tr>
<td><code>&lt;input type=&quot;reset&quot;&gt;</code></td>
<td>重置按钮</td>
</tr>
<tr>
<td><code>&lt;input type=&quot;image&quot;&gt;</code></td>
<td>使用图像作为按钮进行form的提交</td>
</tr>
<tr>
<td><code>&lt;button&gt;</code></td>
<td>按钮标签</td>
</tr>
</tbody>
</table>
</div>
<h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><h5 id="css语法"><a href="#css语法" class="headerlink" title="css语法"></a>css语法</h5><p><code>selector &#123;property: value&#125;</code>,即</p>
<p>选择器 {属性: 值}。</p>
<h5 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h5><ul>
<li><p>元素选择器</p>
</li>
<li><p>id选择器</p>
</li>
<li><p>类选择器</p>
</li>
<li><p>更准确的选择(同时根据元素名和class来选择)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.blue</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h5><p>以<code>/*</code> 开始，以<code>*/</code>结束。</p>
<h5 id="常用的CSS属性"><a href="#常用的CSS属性" class="headerlink" title="常用的CSS属性"></a>常用的CSS属性</h5><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>width, height</td>
<td>尺寸大小，元素的宽度和高度</td>
</tr>
<tr>
<td>background-*（color，image）</td>
<td>背景（颜色，图片）</td>
</tr>
<tr>
<td>color</td>
<td>文字颜色</td>
</tr>
<tr>
<td>text-align</td>
<td>对齐</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本修饰</td>
</tr>
<tr>
<td>line-height</td>
<td>行间距</td>
</tr>
<tr>
<td>letter-spacing</td>
<td>字符间距</td>
</tr>
<tr>
<td>word-spacing</td>
<td>单词间距</td>
</tr>
<tr>
<td>text-index</td>
<td>首行缩进</td>
</tr>
<tr>
<td>text-transform</td>
<td>大小写</td>
</tr>
<tr>
<td>white-space</td>
<td>空白格</td>
</tr>
<tr>
<td>font-size</td>
<td>尺寸</td>
</tr>
<tr>
<td>font-style</td>
<td>风格</td>
</tr>
<tr>
<td>font-weight</td>
<td>粗细</td>
</tr>
<tr>
<td>font-family</td>
<td>字库</td>
</tr>
<tr>
<td>cursor</td>
<td>鼠标样式</td>
</tr>
<tr>
<td>table-layout</td>
<td>表格布局</td>
</tr>
<tr>
<td>border-collapse</td>
<td>表格边框</td>
</tr>
<tr>
<td>border-style</td>
<td>边框风格</td>
</tr>
<tr>
<td>border-color</td>
<td>边框颜色</td>
</tr>
<tr>
<td>border-width</td>
<td>边框宽度</td>
</tr>
<tr>
<td>padding</td>
<td>内边距，指元素的内容和边框之间的距离</td>
</tr>
<tr>
<td>margin</td>
<td>外边距，指元素边框和元素边框之间的距离</td>
</tr>
</tbody>
</table>
</div>
<h5 id="css优先级问题"><a href="#css优先级问题" class="headerlink" title="css优先级问题"></a>css优先级问题</h5><ol>
<li><code>!important</code></li>
<li>style属性</li>
<li>style标签</li>
<li>外部css文件</li>
</ol>
<h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><ul>
<li><p>绝对定位 <code>position: absolute;</code></p>
</li>
<li><p>相对定位 <code>position: relative;</code></p>
</li>
<li><p>浮动 <code>float:left/right;</code></p>
<p>清楚浮动带来的影响，使用 <code>clear</code>.</p>
</li>
</ul>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>JavaScript用于网页与用户之间的交互，完整的JavaScript由语言基础、BOM和DOM组成。</p>
<h5 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h5><p>JavaScript代码必须放在script标签中，script标签可以放在html的任何地方，一般建议放在head标签里。</p>
<h5 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h5><ul>
<li>alert调试</li>
<li>使用浏览器自带的调试功能</li>
<li>console.log()调试</li>
</ul>
<h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>声明了但未赋值</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Number</td>
<td>数字</td>
</tr>
<tr>
<td>String</td>
<td>字符串</td>
</tr>
<tr>
<td>var</td>
<td>动态类型</td>
</tr>
<tr>
<td>typeof</td>
<td>变量类型判断</td>
</tr>
<tr>
<td>null</td>
<td>空对象、或对象不存在</td>
</tr>
</tbody>
</table>
</div>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><ul>
<li>全局变量</li>
<li>局部变量</li>
</ul>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件有很多种，比如鼠标移动、鼠标点击和键盘点击等等。</p>
<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><p>JavaScript提供了一种try catch的错误处理机制，当有错误抛出的时候，可以catch住。</p>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><ul>
<li>数字 Number</li>
<li>字符串 String</li>
<li>数组 Array</li>
<li>日期 Date</li>
<li>Math</li>
<li>自定义对象</li>
</ul>
<h5 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h5><p>浏览器对象模型（Browser Object Model）</p>
<ul>
<li>Window 窗口</li>
<li>Navigator 浏览器</li>
<li>Screen 客户端屏幕</li>
<li>History 访问历史</li>
<li>Location 浏览器地址</li>
</ul>
<h6 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h6><div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>setTimeout</td>
<td>只执行一次</td>
</tr>
<tr>
<td>setInterval</td>
<td>不停的重复执行</td>
</tr>
<tr>
<td>clearInterval</td>
<td>终止重复执行</td>
</tr>
</tbody>
</table>
</div>
<p><strong>不要在setInterval调用的函数中使用<code>document.write();</code></strong></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON JavaScript对象表示法（Java Script Object Notation）是一种存储数据的方式。</p>
<h5 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h5><ul>
<li><p>将字符串转换为JSON对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;盖伦\&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;,\&quot;hp\&quot;:616&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = s1+s2;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;这是一个JSON格式的字符串:&quot;</span> + s3);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> gareen = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span>+s3+<span class="string">&quot;)&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;这是一个JSON对象: &quot;</span> + gareen);</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON对象转换为字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> hero = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;盖伦&quot;</span>,<span class="string">&quot;hp&quot;</span>:<span class="string">&quot;616&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;这是一个json 对象：&quot;</span>+ hero);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> heroString = <span class="built_in">JSON</span>.stringify(hero)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;这是一个json 字符串：&quot;</span>+ heroString );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-n个骰子的点数</title>
    <url>/2021/01/29/%E5%8A%9B%E6%89%A3-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h4 id="题目（what）"><a href="#题目（what）" class="headerlink" title="题目（what）"></a>题目（what）</h4><p>把 <code>n</code> 个骰子扔在地上，所有骰子朝上一面的点数之和为 <code>s</code>。输入 <code>n</code>，打印出 <code>s</code> 的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 <code>i</code> 个元素代表这 <code>n</code> 个骰子所能掷出的点数集合中第 <code>i</code> 小的那个的概率。</p>
<span id="more"></span>
<h4 id="分析（how）"><a href="#分析（how）" class="headerlink" title="分析（how）"></a>分析（how）</h4><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5>]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-单词频率</title>
    <url>/2021/02/04/%E5%8A%9B%E6%89%A3-%E5%8D%95%E8%AF%8D%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<h4 id="题目（what）"><a href="#题目（what）" class="headerlink" title="题目（what）"></a>题目（what）</h4><p>设计一个方法，找出任意指定单词在一本书中的出现频率。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li><code>WordsFrequency(book)</code> 构造函数，参数为字符串数组构成的一本书</li>
<li><code>get(word)</code> 查询指定单词在书中出现的频率</li>
</ul>
<span id="more"></span>
<h4 id="分析（how）"><a href="#分析（how）" class="headerlink" title="分析（how）"></a>分析（how）</h4><p>利用 <code>HashMap</code> ，来存储每个单词出现的次数。</p>
]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-尽可能使字符串相等</title>
    <url>/2021/02/05/%E5%8A%9B%E6%89%A3-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<h4 id="题目（what）"><a href="#题目（what）" class="headerlink" title="题目（what）"></a>题目（what）</h4><p>给你两个长度相同的字符串: <code>s</code> 和 <code>t</code>。</p>
<p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 <code>0</code>），也就是两个字符的 <code>ASCII</code> 码值的差的绝对值。</p>
<p>用于变更字符串的最大预算为 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>
<p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p>
<p>如果 <code>s</code> 中没有子字符串可以转化为 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p>
<span id="more"></span>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： s &#x3D; &quot;abcd&quot;, t &#x3D; &quot;bcdf&quot;, cost &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3,所以最大长度为 3。</span><br></pre></td></tr></table></figure>
<h4 id="分析（how）"><a href="#分析（how）" class="headerlink" title="分析（how）"></a>分析（how）</h4><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5>]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-把数组排成最小的数</title>
    <url>/2021/01/27/%E5%8A%9B%E6%89%A3-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h4 id="题目（what）"><a href="#题目（what）" class="headerlink" title="题目（what）"></a>题目（what）</h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<span id="more"></span>
<h4 id="分析（how）"><a href="#分析（how）" class="headerlink" title="分析（how）"></a>分析（how）</h4><h5 id="排列和组合的区别？"><a href="#排列和组合的区别？" class="headerlink" title="排列和组合的区别？"></a>排列和组合的区别？</h5><p>排列和组合的共同点是从 <code>n</code> 个不同的元素中，任取 <code>m(m &lt; n)</code> 个元素，而不同点是：</p>
<ul>
<li>排列：按照一定的顺序排成一列。</li>
<li>组合：无论怎样的顺序并成一组。</li>
</ul>
<p><span style="color: red;">如何在typora中使用数学公式？</span> </p>
<h4 id="总结（why）"><a href="#总结（why）" class="headerlink" title="总结（why）"></a>总结（why）</h4>]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-求1加到n的和</title>
    <url>/2021/01/28/%E5%8A%9B%E6%89%A3-%E6%B1%821%E5%8A%A0%E5%88%B0n%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<h4 id="题目（what）"><a href="#题目（what）" class="headerlink" title="题目（what）"></a>题目（what）</h4><p>求1+2+…n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h4 id="分析（how）"><a href="#分析（how）" class="headerlink" title="分析（how）"></a>分析（how）</h4><h5 id="俄罗斯农名乘法"><a href="#俄罗斯农名乘法" class="headerlink" title="俄罗斯农名乘法"></a>俄罗斯农名乘法</h5><p><img src="http://wrr123.github.io/2021/01/28/%E5%8A%9B%E6%89%A3-%E6%B1%821%E5%8A%A0%E5%88%B0n%E7%9A%84%E5%92%8C/001.gif" alt></p>
<span id="more"></span>
<p>俄式乘法又称为俄国农夫法，它是两个正整数相乘的一种算法，这种算法不是很高效，但是它的乘法过程非常有趣。</p>
<p><img src="http://wrr123.github.io/2021/01/28/%E5%8A%9B%E6%89%A3-%E6%B1%821%E5%8A%A0%E5%88%B0n%E7%9A%84%E5%92%8C/002.png" alt></p>
<h4 id="延申（why）"><a href="#延申（why）" class="headerlink" title="延申（why）"></a>延申（why）</h4>]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-礼物的最大价值</title>
    <url>/2021/02/01/%E5%8A%9B%E6%89%A3-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<h4 id="题目（what）"><a href="#题目（what）" class="headerlink" title="题目（what）"></a>题目（what）</h4><p>在一个 <code>m * n</code> 的期盼的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 <code>0</code>）。你可以从棋盘的左上角拿格子里的礼物，并每次向右或向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上卖弄的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<span id="more"></span>
<h4 id="分析（how）"><a href="#分析（how）" class="headerlink" title="分析（how）"></a>分析（how）</h4>]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣--账户合并</title>
    <url>/2021/01/18/%E5%8A%9B%E6%89%A3-%E8%B4%A6%E6%88%B7%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h4 id="题目—账户合并"><a href="#题目—账户合并" class="headerlink" title="题目—账户合并"></a>题目—账户合并</h4><p>
    给定一个列表`accounts`，每个元素 `accounts[i]` 是一个字符串列表，其中第一个元素 `accounts[i][0]` 是名称（name），其余元素是 `emails` 表示该账户的邮箱地址。
</p>

<p>现在，我们想合并这些账号。如果两个账号都有一些共同的邮箱地址，则两个账号必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>
<p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。 </p>
<span id="more"></span>
<h4 id="方法一：哈希表-并查集"><a href="#方法一：哈希表-并查集" class="headerlink" title="方法一：哈希表 + 并查集"></a>方法一：哈希表 + 并查集</h4><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>定义：</p>
<p>因程序需要，有时我们只需要某个类同时保留一个对象，不希望有更多对象，此时，我们则应考虑单例模式的设计。</p>
<p><strong>特点</strong></p>
<ol>
<li>单例模式只能有一个实例。</li>
<li>单例类必须创建自己的唯一实例。</li>
<li>单例类必须向其它对象提供这一实例。</li>
</ol>
]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-连接所有点的最小费用</title>
    <url>/2021/01/19/%E5%8A%9B%E6%89%A3-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/</url>
    <content><![CDATA[<h4 id="题目-—-连接所有点的最小费用"><a href="#题目-—-连接所有点的最小费用" class="headerlink" title="题目 — 连接所有点的最小费用"></a>题目 — 连接所有点的最小费用</h4><p>给你一个 <code>points</code> 数组，表示 <code>2D</code> 平面上的一些点，其中 <code>points[i] = [xi, yi]</code>。</p>
<p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code>的费用为它们之间的 <strong>曼哈顿距离</strong> ，：<code>|xi - xj| + |yi - yj|</code>，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p>
<span id="more"></span>
<h4 id="最小生成树算法之Kruskal-算法"><a href="#最小生成树算法之Kruskal-算法" class="headerlink" title="最小生成树算法之Kruskal 算法"></a>最小生成树算法之<code>Kruskal</code> 算法</h4><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p><code>Kruskal</code> 算法是基于贪心的思想得到的。首先我们把所有的边按照权值先从小到大排列，接着按照顺序选取每条边，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。至于怎么合并到同一个集合，那么我们就可以用到一个工具—— <span style="color:red">并查集</span>。换而言之，<code>Kruskal</code> 算法就是基于并查集的贪心算法。</p>
<h5 id="Kruskal-算法流程"><a href="#Kruskal-算法流程" class="headerlink" title="Kruskal 算法流程"></a>Kruskal 算法流程</h5><ol>
<li>将图 G 看作一个森林，每个顶点为一棵独立的树；</li>
<li>将所有的边加入集合 S，即一开始 <code>S = E</code>；</li>
<li>将 <code>S</code> 中拿出一条最短的边<code>(u, v)</code>，如果 <code>(u, v)</code> 不在同一棵树内，则连接<code>u, v</code> 合并这两棵树，同时将<code>(u, v)</code> 加入生成树的边集 <code>E&#39;</code>；</li>
<li>重复 <code>3</code> 直到所有点属于同一棵树，边集 <code>E&#39;</code> 就是一棵最小生成树。</li>
</ol>
<h5 id="Kruskal-算法的时间复杂度"><a href="#Kruskal-算法的时间复杂度" class="headerlink" title="Kruskal 算法的时间复杂度"></a>Kruskal 算法的时间复杂度</h5><p><code>kruskal</code> 算法每次要从剩余的边中选取一个最小的边。通常我们先对边按权值从小到大排序，这一步的时间复杂度为 <code>O(|Elog|E|)</code>。<code>Kruskal</code> 算法的实现通常使用并查集，来快速判断两个顶点是狗属于同一个集合。最坏的情况可能要枚举完所有的边，此时要循环 <code>|E|</code> 次，所以这一步的时间复杂度为 <code>O(|E|a(V)|)</code>，其中 <code>a</code> 为 <code>Ackermann</code> 函数，其增长非常慢，我们可以视为常数。所以 <code>Kruskal</code> 算法的时间复杂度为 <code>O(|Elog|E|)</code>。</p>
]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣之冗余连接</title>
    <url>/2021/01/13/%E5%8A%9B%E6%89%A3%E4%B9%8B%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>在本问题中，树指的是一个连通且无环的 <strong>无向图</strong>。</p>
<p>输入一个图，该图由一个有着 N 个节点（节点值不重复1，2，3，。。。N）的树及一条附加的边构成。附加的边的两个顶点包含在 1 到 N 中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以 <code>边</code> 组成的二维数组，每一个 <code>边</code> 的元素是一对 <code>[u, v]</code>， 满足 <code>u &lt; v</code>, 表示连接顶点 <code>u</code> 和 <code>v</code> 的 <strong>无向图</strong> 的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着 N 个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边应满足相同的格式 <code>u &lt; v</code>。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1, 2], [1, 3], [2, 3]]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="方法一：并查集"><a href="#方法一：并查集" class="headerlink" title="方法一：并查集"></a>方法一：并查集</h5><p style="color:green;">
    在一棵树中，边的数量比节点的数量少1。如果一棵树有 N 个节点，则这棵树有 N - 1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。
    树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。
    可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。
    <ul style="color:orange;">
        <li>
            如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。
        </li>    
        <li>
            如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。
        </li>
    </ul>
</p>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>并查集被很多 Oler 认为是最简洁而优雅的数据结构之一，主要用于解决一些 <strong>元素分组</strong> 的问题。它管理一系列 <strong>不相交的集合</strong>，并支持两种操作：</p>
<ul>
<li><strong>合并</strong> （Union）：把两个不相交的集合合并为一个集合。</li>
<li><strong>查询</strong> （Find）：查询两个元素是否在同一个集合中。</li>
</ul>
<h5 id="并查集的设计"><a href="#并查集的设计" class="headerlink" title="并查集的设计"></a>并查集的设计</h5><ol>
<li><strong>并查集的结构</strong> ：每个节点都有一个父指针指向自己的父节点，父子节点属于同一个集合，根节点作为一个集合的 <span style="color:red;">代表节点。</span></li>
<li><strong>并查集的构造：</strong> 初始时每一个点自成一个集合，每一个节点的父指针都指向自己，每一个集合的 <span style="color:red;">代表节点</span> 为集合元素自身。</li>
<li><strong>集合的合并：</strong> 是把一个集合的 <span style="color:red;">代表节点</span> 的父节点指向另一个节点的 <span style="color:red;">代表节点</span>。</li>
<li><strong>并查集的路径压缩：</strong> 查找根节点时，顺便做路径压缩操作：将沿途节点的父指针设为所查询到的根节点。</li>
</ol>
]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>启动springboot项目的几种方式</title>
    <url>/2020/09/17/%E5%90%AF%E5%8A%A8springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h4><ol>
<li><p>直接在 IDE 下运行 Application 这个类的 main 方法</p>
</li>
<li><p>在 springboot 的应用的根目录下运行，<code>mvn spring-boot:run</code></p>
</li>
<li><p>使用 <code>mvn install</code>,生成 jar 包之后执行</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先切换到项目根目录下</span></span><br><span class="line">mvn install</span><br><span class="line"><span class="built_in">cd</span> target</span><br><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成入门</title>
    <url>/2020/07/08/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）。</p>
<p>本文简要介绍持续集成的概念和做法。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015092301.png" alt="img"></p>
<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p><strong>持续集成指的是，频繁地（一天多次）将代码集成到主干。</strong></p>
<p>它的好处主要有两个。</p>
<blockquote>
<p><strong>（1）快速发现错误。</strong>每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</p>
<p><strong>（2）防止分支大幅偏离主干。</strong>如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</p>
</blockquote>
<p><strong>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。</strong>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
<p>Martin Fowler说过，”持续集成并不能消除Bug，而是让它们非常容易发现和改正。”</p>
<p>与持续集成相关的，还有两个概念，分别是持续交付和持续部署。</p>
<h2 id="二、持续交付"><a href="#二、持续交付" class="headerlink" title="二、持续交付"></a>二、持续交付</h2><p><strong>持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</strong>如果评审通过，代码就进入生产阶段。</p>
<p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>
<h2 id="三、持续部署"><a href="#三、持续部署" class="headerlink" title="三、持续部署"></a>三、持续部署</h2><p><strong>持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</strong></p>
<p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p>
<p>持续部署的前提是能自动化完成测试、构建、部署等步骤。它与持续交付的区别，可以参考下图。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015092302.jpg" alt="img"></p>
<p>（<a href="http://blog.crisp.se/2013/02/05/yassalsundman/continuous-delivery-vs-continuous-deployment">图片来源</a>）</p>
<h2 id="四、流程"><a href="#四、流程" class="headerlink" title="四、流程"></a>四、流程</h2><p>根据持续集成的设计，代码从提交到生产，整个过程有以下几步。</p>
<h3 id="4-1-提交"><a href="#4-1-提交" class="headerlink" title="4.1 提交"></a>4.1 提交</h3><p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p>
<h3 id="4-2-测试（第一轮）"><a href="#4-2-测试（第一轮）" class="headerlink" title="4.2 测试（第一轮）"></a>4.2 测试（第一轮）</h3><p>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。</p>
<p>测试有好几种。</p>
<blockquote>
<ul>
<li>单元测试：针对函数或模块的测试</li>
<li>集成测试：针对整体产品的某个功能的测试，又称功能测试</li>
<li>端对端测试：从用户界面直达数据库的全链路测试</li>
</ul>
</blockquote>
<p>第一轮至少要跑单元测试。</p>
<h3 id="4-3-构建"><a href="#4-3-构建" class="headerlink" title="4.3 构建"></a>4.3 构建</h3><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p>
<p>交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。</p>
<p>常用的构建工具如下。</p>
<blockquote>
<ul>
<li><a href="http://jenkins-ci.org/">Jenkins</a></li>
<li><a href="https://travis-ci.com/">Travis</a></li>
<li><a href="https://www.codeship.io/">Codeship</a></li>
<li><a href="http://stridercd.com/">Strider</a></li>
</ul>
</blockquote>
<p>Jenkins和Strider是开源软件，Travis和Codeship对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。</p>
<h3 id="4-4-测试（第二轮）"><a href="#4-4-测试（第二轮）" class="headerlink" title="4.4 测试（第二轮）"></a>4.4 测试（第二轮）</h3><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p>
<p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p>
<p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p>
<h3 id="4-5-部署"><a href="#4-5-部署" class="headerlink" title="4.5 部署"></a>4.5 部署</h3><p>通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ <code>tar filename.tar *</code> ）存档，发到生产服务器。</p>
<p>生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有<a href="http://www.ansible.com/">Ansible</a>，<a href="https://www.chef.io/chef/">Chef</a>，<a href="https://puppetlabs.com/">Puppet</a>等。</p>
<h3 id="4-6-回滚"><a href="#4-6-回滚" class="headerlink" title="4.6 回滚"></a>4.6 回滚</h3><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>
<h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul>
<li>Gergely Nemeth, <a href="https://blog.risingstack.com/continuous-deployment-of-node-js-applications/">Continuous Deployment of Node.js Applications</a></li>
<li>Codeship, <a href="https://codeship.com/continuous-integration-essentials">Continuous Integration Essentials</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎搜索技巧</title>
    <url>/2021/03/04/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h4 id="在某个网站或域名下搜索"><a href="#在某个网站或域名下搜索" class="headerlink" title="在某个网站或域名下搜索"></a>在某个网站或域名下搜索</h4><p>如<code>site:blog.csdn.net java</code>，在csdn的博客搜索java相关的信息；</p>
<h4 id="搜索某种类型的文件"><a href="#搜索某种类型的文件" class="headerlink" title="搜索某种类型的文件"></a>搜索某种类型的文件</h4><p>如<code>filetype:pdf python</code></p>
<blockquote>
<p>用来查找文献、电子书、PPT等非常有用</p>
<p>支持的文件类型：ppt, ppts, doc, docx, xlsx, xls, pdf, txt等等（不同的搜索引擎支持的文件类型不一样）</p>
</blockquote>
<span id="more"></span>
<h5 id="常见的域名"><a href="#常见的域名" class="headerlink" title="常见的域名"></a>常见的域名</h5><ul>
<li><code>.com</code> 国际通用顶级域名，也是目前使用最为广泛的域名，它后缀的含义代表商业组织机构；</li>
<li><code>.net</code> 国际通用域名，也是目前国际广泛流行的域名，后缀代表网络服务机构；</li>
<li><code>.cn</code> 中国国家级顶级域名，也是在国内广泛使用的域名，后缀表示含义为中国企业互联网标识；</li>
<li><code>.org</code> 国际顶级域名，是目前国际广泛使用的域名，后缀含义代表非盈利性组织；</li>
<li><code>.top</code> 国际顶级域名，作为目前最流行的最热闹的新型后缀域名，寓意为顶级排名、高端、突破，可以用于任何组织和个人。</li>
<li><code>.edu</code> 教育机构</li>
<li><code>.gov</code> 政府</li>
<li><code>.mil</code> 军事</li>
<li><code>.arts</code> 艺术机构</li>
<li><code>.firm</code> 商业公司</li>
<li><code>.info</code> 提供信息的机构</li>
</ul>
<h4 id="逻辑与、或：AND-OR"><a href="#逻辑与、或：AND-OR" class="headerlink" title="逻辑与、或：AND, OR"></a>逻辑与、或：AND, OR</h4><ul>
<li>注意 AND， OR必须大写，否则会被认为是普通的单词，而不是搜索指令</li>
<li>AND指令一般以空格代替，不明确写出。另外AND指令还可以用<code>+</code>替代</li>
<li>OR指令可用 <code>|</code> 代替</li>
</ul>
<h4 id="逻辑非："><a href="#逻辑非：" class="headerlink" title="逻辑非：-"></a>逻辑非：<code>-</code></h4><blockquote>
<p>逻辑非 - ，也就是减号，代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。Google 和 baidu 都支持这个指令。</p>
</blockquote>
<h4 id="精确搜索：双引号"><a href="#精确搜索：双引号" class="headerlink" title="精确搜索：双引号"></a>精确搜索：双引号</h4><blockquote>
<p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。bd和Google 都支持这个指令。</p>
</blockquote>
<h4 id="通配符：-和"><a href="#通配符：-和" class="headerlink" title="通配符：? 和 *"></a>通配符：<code>?</code> 和 <code>*</code></h4><ul>
<li><code>*</code>代表一连串字符，<code>?</code>代表单个字符</li>
</ul>
<h4 id="in指令：位置关键词查找"><a href="#in指令：位置关键词查找" class="headerlink" title="in指令：位置关键词查找"></a>in指令：位置关键词查找</h4><ul>
<li>intitle：在网页标题中查找</li>
<li>inurl：在网页的url地址中查找</li>
<li>inanchor:在网页的链接锚中查找</li>
<li>intext：在正文中检索</li>
</ul>
<h4 id="link：搜索所有链接到某个URL地址的网页"><a href="#link：搜索所有链接到某个URL地址的网页" class="headerlink" title="link：搜索所有链接到某个URL地址的网页"></a>link：搜索所有链接到某个URL地址的网页</h4><ul>
<li>最重要的用途：迅速判断一个网页的热度</li>
</ul>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link:www.newhua.com</span><br></pre></td></tr></table></figure>
<h4 id="related-寻找某网页的”类似网页”"><a href="#related-寻找某网页的”类似网页”" class="headerlink" title="related:寻找某网页的”类似网页”"></a>related:寻找某网页的”类似网页”</h4><p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">related:www.newhua.com</span><br></pre></td></tr></table></figure>
<h4 id="数值范围："><a href="#数值范围：" class="headerlink" title="数值范围：.."></a>数值范围：..</h4><ul>
<li>例如：数码相机 600..900 万像素 3000..4000 元</li>
<li>注意：“900”与“万”之间必须有空格。</li>
</ul>
<h4 id="从Google服务器上缓存页面中查询信息"><a href="#从Google服务器上缓存页面中查询信息" class="headerlink" title="从Google服务器上缓存页面中查询信息"></a>从Google服务器上缓存页面中查询信息</h4><p>“cache”用来搜索Google服务器上某页面的缓存，通常用于查找某些已经被删除的死链接网页。</p>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cache:www.yahoo.com.cn</span><br></pre></td></tr></table></figure>
<h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p><code>info</code>用来显示与某链接相关的一系列搜索，提供cache、link、related和完全包含该链接的网页的功能。</p>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info:www.sina.com.cn</span><br></pre></td></tr></table></figure>
<h4 id="查单词，做翻译"><a href="#查单词，做翻译" class="headerlink" title="查单词，做翻译"></a>查单词，做翻译</h4><p>使用<code>define</code>指令</p>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define:关键词</span><br></pre></td></tr></table></figure>
<h4 id="括号"><a href="#括号" class="headerlink" title="括号:()"></a>括号:<code>()</code></h4><p>用<code>()</code>来将多个术语或搜索运算符进行分组来控制搜索的执行方式。</p>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷开发入门</title>
    <url>/2020/07/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>敏捷开发（agile development）是非常流行的软件开发方法。据<a href="https://www.statista.com/statistics/673786/worldwide-software-development-survey-agile-development-continuous-integration-adoption/">统计</a>，2018年90%的软件开发采用敏捷开发。</p>
<p>但是，到底什么是敏捷开发，能说清的人却不多。本文尝试用简洁易懂的语言，解释敏捷开发。</p>
<h4 id="迭代开发"><a href="#迭代开发" class="headerlink" title="迭代开发"></a>迭代开发</h4><p><strong>敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。</strong></p>
<p>那么什么是”迭代开发”呢？迭代的英文是 iterative，直译为”重复”，迭代开发其实就是”重复开发”。</p>
<p>对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次”大开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次”大开发”变成多次”小开发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019030702.jpg" alt="img"></p>
<p>举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。</p>
<p><strong>迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。</strong>开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。</p>
<h4 id="增量开发"><a href="#增量开发" class="headerlink" title="增量开发"></a>增量开发</h4><p>迭代开发只是要求将开发分成多个迭代，并没有回答一个重要的问题：怎么划分迭代，哪个任务在这个迭代，哪个任务在下个迭代？这时，一般采用”增量开发”（incremental development）划分迭代。</p>
<p><strong>所谓”增量开发”，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。</strong></p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019030703.jpg" alt="img"></p>
<p>举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼……每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶……</p>
<p><strong>增量开发加上迭代开发，才算真正的敏捷开发。</strong></p>
<h4 id="敏捷开发的好处"><a href="#敏捷开发的好处" class="headerlink" title="敏捷开发的好处"></a>敏捷开发的好处</h4><h3 id="3-1-早期交付"><a href="#3-1-早期交付" class="headerlink" title="3.1 早期交付"></a>3.1 早期交付</h3><p><strong>敏捷开发的第一个好处，就是早期交付，从而大大降低成本。</strong></p>
<p>还是以上一节的房产公司为例，如果按照传统的”瀑布开发模式”，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。</p>
<p>敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。</p>
<h3 id="3-2-降低风险"><a href="#3-2-降低风险" class="headerlink" title="3.2 降低风险"></a>3.2 降低风险</h3><p><strong>敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。</strong></p>
<p>请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？</p>
<p>对于软件项目来说，先有一个原型产品，了解市场的接受程度，往往是项目成功的关键。有一本书叫做《梦断代码》，副标题就是”20+个程序员，三年时间，4732个bug，100+万美元，最后失败的故事”，这就是没有采用敏捷开发的结果。相反的，Instagram 最初是一个地理位置打卡 App，后来发现用户不怎么在乎地理位置，更喜欢上传照片，就改做照片上传软件，结果成了独角兽。</p>
<p>由于敏捷开发可以不断试错，找出对业务最重要的功能，然后通过迭代，调整软件方向。相比传统方式，大大增加了产品成功的可能性。如果市场需求不确定，或者你对该领域不熟悉，那么敏捷开发几乎是唯一可行的应对方式。</p>
<h2 id="如何进行每一次迭代"><a href="#如何进行每一次迭代" class="headerlink" title="如何进行每一次迭代"></a>如何进行每一次迭代</h2><p>虽然敏捷开发将软件开发分成多个迭代，但是也要求，<strong>每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。</strong></p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019030704.jpg" alt="img"></p>
<p>具体来说，每次迭代都必须依次完成以下五个步骤。</p>
<blockquote>
<ol>
<li>需求分析（requirements analysis）</li>
<li>设计（design）</li>
<li>编码（coding）</li>
<li>测试（testing）</li>
<li>部署和评估（deployment / evaluation）</li>
</ol>
</blockquote>
<p>每个迭代大约持续2~6周。</p>
<h2 id="敏捷开发的价值观"><a href="#敏捷开发的价值观" class="headerlink" title="敏捷开发的价值观"></a>敏捷开发的价值观</h2><p>《敏捷软件开发宣言》里面提到四个价值观。</p>
<blockquote>
<ul>
<li>程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。</li>
<li>软件能够运行，优于详尽的文档。</li>
<li>跟客户的密切协作，优于合同和谈判。</li>
<li>能够响应变化，优于遵循计划。</li>
</ul>
</blockquote>
<h2 id="十二条原则"><a href="#十二条原则" class="headerlink" title="十二条原则"></a>十二条原则</h2><p>该宣言还提出十二条敏捷开发的原则。</p>
<ol>
<li>通过早期和持续交付有价值的软件，实现客户满意度。</li>
<li>欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。</li>
<li>不断交付可用的软件，周期通常是几周，越短越好。</li>
<li>项目过程中，业务人员与开发人员必须在一起工作。</li>
<li>项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。</li>
<li>面对面交谈是最好的沟通方式。</li>
<li>可用性是衡量进度的主要指标。</li>
<li>提倡可持续的开发，保持稳定的进展速度。</li>
<li>不断关注技术是否优秀，设计是否良好。</li>
<li>简单性至关重要，尽最大可能减少不必要的工作。</li>
<li>最好的架构、要求和设计，来自团队内部自发的认识。</li>
<li>团队要定期反思如何更有效，并相应地进行调整。</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.mindk.com/blog/iterative-development/">Iterative development: the secret to great product launches</a>, Pavlo Zinchenko</li>
<li><a href="https://en.wikipedia.org/wiki/Agile_software_development">Agile software development</a>, Wikipedia</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和list之间的转换</title>
    <url>/2020/07/13/%E6%95%B0%E7%BB%84%E5%92%8Clist%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="数组-gt-list"><a href="#数组-gt-list" class="headerlink" title="数组==&gt;list"></a>数组==&gt;list</h4><ol>
<li><p>for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;10&#x27;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(String item: arr) &#123;</span><br><span class="line">	list.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>asList()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arrays));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>使用Collections.addAll()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(arrays.length);</span><br><span class="line">Collections.addAll(list2, arrays);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="List-gt-数组"><a href="#List-gt-数组" class="headerlink" title="List ==&gt; 数组"></a>List ==&gt; 数组</h4><ol>
<li><p>for循环</p>
</li>
<li><p>使用<code>toArray()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要转换的list集合</span></span><br><span class="line"> List&lt;String&gt; testList = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;add(<span class="string">&quot;aa&quot;</span>);add(<span class="string">&quot;bb&quot;</span>);add(<span class="string">&quot;cc&quot;</span>);&#125;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使用toArray(T[] a)方法</span></span><br><span class="line"> String[] array2 = testList.toArray(<span class="keyword">new</span> String[testList.size()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印该数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++)&#123;</span><br><span class="line">      System.out.println(array2[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="HashSet-的遍历"><a href="#HashSet-的遍历" class="headerlink" title="HashSet 的遍历"></a>HashSet 的遍历</h4><ol>
<li><p>使用迭代器的方式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">  iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach循环</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String str: set) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>日常生活中的基础概念</title>
    <url>/2020/10/14/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h4 id="什么叫同比和环比"><a href="#什么叫同比和环比" class="headerlink" title="什么叫同比和环比"></a>什么叫同比和环比</h4><p>同比是 <code>month-on-month</code> 翻译过来的；环比是 <code>year-on-yaer</code> 翻译过来的。</p>
<p>环比可分为 <code>日环比、周环比、月环比和年环比。</code></p>
<p>计算公式：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">环比增长率 = （本期数 - 上期数）/ 上期数 * 100%</span><br><span class="line">同比增长率 = （本期数 - 同期数）/ 同期数 * 100%</span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <tags>
        <tag>日常生活</tag>
      </tags>
  </entry>
  <entry>
    <title>服务容错保护</title>
    <url>/2021/03/22/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<h4 id="Hystrix服务降级"><a href="#Hystrix服务降级" class="headerlink" title="Hystrix服务降级"></a>Hystrix服务降级</h4><blockquote>
<p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。</p>
</blockquote>
<span id="more"></span>
<ul>
<li><p>引入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用主类中使用<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>注解开启Hystrix的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注解<code>@SpringCloudApplication</code>是上述三个注解的合并。</strong></p>
</li>
<li><p>改造消费方式，在为具体执行逻辑的函数上增加<code>@HystrixCommand</code>注解来指定服务降级方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConsumerService consumerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> consumerService.consumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://eureka-client/dc&quot;</span>, String.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;fallback&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Hystrix依赖隔离"><a href="#Hystrix依赖隔离" class="headerlink" title="Hystrix依赖隔离"></a>Hystrix依赖隔离</h4><blockquote>
<p>“舱壁模式”对于熟悉Docker的读者一定不陌生，Docker通过“舱壁模式”实现进程的隔离，使得容器与容器之间不会互相影响。而Hystrix则使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。</p>
<p>通过对依赖服务的线程池隔离实现，可以带来如下优势：</p>
<ul>
<li>应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。</li>
<li>可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。</li>
<li>当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。</li>
<li>当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（后续会通过Spring Cloud Config与Spring Cloud Bus的联合使用来介绍）来处理它。</li>
<li>当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。</li>
<li>除了上面通过线程池隔离服务发挥的优点之外，每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。</li>
</ul>
<p>总之，通过对依赖服务实现线程池隔离，让我们的应用更加健壮，不会因为个别依赖服务出现问题而引起非相关服务的异常。同时，也使得我们的应用变得更加灵活，可以在不停止服务的情况下，配合动态配置刷新实现性能配置上的调整。</p>
</blockquote>
<p>Hystrix中除了使用线程池之外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销要远比线程池的开销小得多，但是它不能设置超时和实现异步访问。所以，只有在依赖服务是足够可靠的情况下才使用信号量。</p>
<p>在HystrixCommand和HystrixObservableCommand中2处支持信号量的使用：</p>
<ul>
<li><p>命令执行</p>
<p>如果隔离策略参数<code>execution.isolation.strategy</code>设置为<code>SEMAPHORE</code>，Hystrix会使用信号量替代线程池来控制依赖服务的并发控制。</p>
</li>
<li><p>降级逻辑</p>
<p>当Hystrix尝试降级逻辑的时候，它会在调用线程中使用信号量。</p>
</li>
</ul>
<h4 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h4><p>”断路器“本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，”断路器“能够及时地切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p>
<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障时之后，通过断路器的故障监控，直接切断原来的主逻辑调用。<strong>但是，在Hystrix中的断路器除了切断主逻辑的功能之外，还有更复杂的逻辑。</strong></p>
<p>断路器的三个重要参数：</p>
<ol>
<li><p>快照时间窗</p>
<p>断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</p>
</li>
<li><p>请求总数下限</p>
<p>在快照时间窗内，必须满足请求总数下限才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即使所有的请求都超时或其它的原因失败，断路器都不会打开。</p>
</li>
<li><p>错误百分比下限</p>
<p>当请求总数在快照时间窗内超出了下限，比如发生了30次调用，如果这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候断路器就会打开。</p>
</li>
</ol>
<h4 id="Hystrix监控面板"><a href="#Hystrix监控面板" class="headerlink" title="Hystrix监控面板"></a>Hystrix监控面板</h4><h5 id="Hystrix-Dashboard支持三种不同的监控方式："><a href="#Hystrix-Dashboard支持三种不同的监控方式：" class="headerlink" title="Hystrix Dashboard支持三种不同的监控方式："></a>Hystrix Dashboard支持三种不同的监控方式：</h5><ol>
<li>默认的集群监控</li>
<li>指定的集群监控</li>
<li>单体应用的集群监控</li>
</ol>
<h5 id="进入监控界面"><a href="#进入监控界面" class="headerlink" title="进入监控界面"></a>进入监控界面</h5><ol>
<li><p>保证服务实例引入了jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>确保在服务实例的主类中使用了注解<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>，开启了断路器功能。</p>
</li>
</ol>
<p>监控界面的一些数量指标解释：</p>
<ul>
<li><p>实心圆</p>
<p>颜色代表了实例的健康程度，健康度从绿色、黄色、橙色、红色依次递减。</p>
</li>
<li><p>曲线</p>
<p>用来记录2分钟内流量的相对变化。</p>
</li>
</ul>
<p><img src="http://wrr123.github.io/2021/03/22/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4/001.png" alt></p>
<h4 id="Hystrix监控数据聚合"><a href="#Hystrix监控数据聚合" class="headerlink" title="Hystrix监控数据聚合"></a>Hystrix监控数据聚合</h4><p>因在生产环境我们的服务都是高可用的，故引入一个新的工具，<strong>Turbine。</strong></p>
<h5 id="通过HTTP收集聚合"><a href="#通过HTTP收集聚合" class="headerlink" title="通过HTTP收集聚合"></a>通过HTTP收集聚合</h5><ul>
<li><p>创建一个turbine的项目，引入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建应用主类，加上注解<code>@EnableTurbine</code>,来开启Turbine。</p>
</li>
<li><p>在<code>application.properties</code>配置文件中，加入Eureka和Turbine的相关配置信息。</p>
<p>参数说明：</p>
<ul>
<li><code>turbine.app-config</code>参数指定了需要收集监控信息的服务名；</li>
<li><code>turbine.cluster-name-expression</code> 参数指定了集群名称为default，当我们服务数量非常多的时候，可以启动多个Turbine服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需要在Hystrix Stream的URL中通过<code>cluster</code>参数来指定；</li>
<li><code>turbine.combine-host-port</code>参数设置为<code>true</code>，可以让同一主机上的服务通过主机名与端口号的组合来进行区分，默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。</li>
</ul>
</li>
</ul>
<h5 id="通过消息代理收集聚合"><a href="#通过消息代理收集聚合" class="headerlink" title="通过消息代理收集聚合"></a>通过消息代理收集聚合</h5><p>我们也可以将所有需要收集的监控信息都输出到消息代理中，然后Turbine服务再从消息代理中异步地获取这些监控信息，最后将这些监控信息聚合并输出到Hystrix Dashboard中。</p>
<ul>
<li><p>创建工程，修改pom.xml，添加jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用主类中使用<code>@EnableTurbineStream</code>注解来启用Turbine Strean的配置。</p>
</li>
<li><p>配置<code>application.properties</code>文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">turbine-amqp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8989</span></span><br><span class="line"><span class="meta">management.port</span>=<span class="string">8990</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:1001/eureka/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>Dalston</tag>
      </tags>
  </entry>
  <entry>
    <title>服务注册和发现-Dalston</title>
    <url>/2021/03/22/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0-Dalston/</url>
    <content><![CDATA[<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>简单地说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务和服务间通过诸如<code>RESTful API</code>的方式互相调用。</p>
<h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>Spring Cloud应用中可以支持不同的服务治理框架，比如：</p>
<ul>
<li>Netflix Eureka</li>
<li>Consul</li>
<li>Zookeeper</li>
</ul>
<h5 id="Spring-Cloud-Euraka"><a href="#Spring-Cloud-Euraka" class="headerlink" title="Spring Cloud Euraka"></a>Spring Cloud Euraka</h5><ol>
<li><p>创建“服务注册中心”</p>
<ul>
<li><p>引入jar包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>@EnableEurekaServer</code>注解启动一个服务注册中心提供给其它应用进行对话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class)</span><br><span class="line">                    .web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在默认情况下，该服务注册中心也会将自己作为客户端来注册它自己，所以我们需要禁用它的客户端注册行为。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-server</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">1001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建“服务提供方”</p>
<ul>
<li><p>引入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用主类上加上注解<code>@EnableDiscoveryClient</code>，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(</span><br><span class="line">            ComputeServiceApplication.class)</span><br><span class="line">            .web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个简单的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dc&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String services = <span class="string">&quot;Services: &quot;</span> + discoveryClient.getServices();</span><br><span class="line">        System.out.println(services);</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对<code>application.properties</code>配置文件做一些配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定微服务的名称，后续在调用的时候只需要使用该名称就可以进行服务的访问</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">2001</span></span><br><span class="line"><span class="comment"># 对应服务注册中心的配置内容，指定服务注册中心的位置</span></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:1001/eureka/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h5 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h5><p>   Spring Cloud Consul项目是针对Consul的服务治理实现。Consul是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。</p>
<p>它包含下面的几个特性：</p>
<ul>
<li>服务发现</li>
<li>健康检查</li>
<li>Key/Value存储</li>
<li>多数据中心</li>
</ul>
<h6 id="Consul的服务端开启"><a href="#Consul的服务端开启" class="headerlink" title="Consul的服务端开启"></a>Consul的服务端开启</h6><p>Consul的服务端是通过命令行来直接启动的，不需要在java端启动。</p>
]]></content>
      <tags>
        <tag>Dalston</tag>
      </tags>
  </entry>
  <entry>
    <title>服务消费-Dalston</title>
    <url>/2021/03/22/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9-Dalston/</url>
    <content><![CDATA[<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="使用LoadBalancerClient"><a href="#使用LoadBalancerClient" class="headerlink" title="使用LoadBalancerClient"></a>使用LoadBalancerClient</h5><p>在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括<code>DiscoveryClient</code>，以及<code>LoadBalancerClient</code>等等。</p>
<p><code>LoadBalancerClient</code>接口就是一个负载均衡客户端的抽象定义。</p>
<ul>
<li>引入jar包</li>
<li>配置<code>application.properties</code>文件</li>
<li>创建应用主类。初始化<code>RestTemplate</code>,用来真正发起REST请求。<code>@EnableDiscoveryClient</code>注解用来将当前应用加入到服务治理体系中。</li>
<li>创建一个接口用来消费<code>eureka-client</code>提供的接口。</li>
</ul>
<span id="more"></span>
<h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><p>通过 <code>LoadBalancerClient</code> 接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。</p>
<p>因此，我们需要来看看针对客户端负载均衡的工具包：<code>Spring Cloud Ribbon</code>。</p>
<p>它是基于 Netflix Ribbon 实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置<code>RibbonServerList</code>来设置服务端列表去轮询访问以达到均衡负载的作用。</p>
<blockquote>
<p>当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。</p>
<p>而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。</p>
</blockquote>
<ul>
<li><p>引入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改应用主类。为RestTemplate增加<code>@LoadBalanced</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://eureka-client/dc&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><p>Spring Cloud Feign 是一套基于 Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务端变得更加简单。我们只需要通过创建接口并用注解来配置它，即可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。它还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p>
<h4 id="Feign实现文件上传"><a href="#Feign实现文件上传" class="headerlink" title="Feign实现文件上传"></a>Feign实现文件上传</h4>]]></content>
      <tags>
        <tag>Dalston</tag>
      </tags>
  </entry>
  <entry>
    <title>服务网关-Dalston</title>
    <url>/2021/03/23/%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3-Dalston/</url>
    <content><![CDATA[<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>我们需要将 <strong>权限控制</strong> 这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强一些的负载均衡器，就是 <strong>服务网关</strong>。</p>
<ul>
<li><p>创建项目，在pom.xml中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建应用主类，并使用<code>@EnableZuulProxy</code>注解开启Zuul的功能。</p>
</li>
<li><p>创建配置文件<code>application.yaml</code>，并加入服务名、端口号、eureka注册中心的地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka.didispace.com/eureka/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><h5 id="传统的路由配置"><a href="#传统的路由配置" class="headerlink" title="传统的路由配置"></a>传统的路由配置</h5><p>所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与路由实例的映射关系来实现API网关对外部请求的路由。</p>
<ul>
<li><p>单实例配置</p>
<p>通过一组参数对<code>zuul.routes.&lt;route&gt;.path 与 zuul.routes.&lt;route&gt;.url</code>的方式配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.url</span>=<span class="string">http://localhost:8080/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>多实例配置</p>
<p>通过一组参数对<code>zuul.routes.&lt;route&gt;.path 与 zuul.routes.&lt;route&gt;.serviceId</code>的方式配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.user-service.path</span>=<span class="string">/user-service/**</span></span><br><span class="line"><span class="meta">zuul.routes.user-service.serviceId</span>=<span class="string">user-service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">ribbon.eureka.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">user-service.ribbon.listOfServers</span>=<span class="string">http://localhost:8080/,http://localhost:8081/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ribbon.eureka.enabled</code>：由于<code>zuul.routes..serviceId</code>指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的<code>serviceId</code>是获取不到对应实例清单的。</li>
<li><code>user-service.ribbon.listOfServers</code>：该参数内容与<code>zuul.routes..serviceId</code>的配置相对应，开头的<code>user-service</code>对应了<code>serviceId</code>的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。</li>
</ul>
</li>
</ul>
<h5 id="服务路由配置"><a href="#服务路由配置" class="headerlink" title="服务路由配置"></a>服务路由配置</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">api-a:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/api-a/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">eureka-client</span></span><br></pre></td></tr></table></figure>
<p><code>serviceId</code>用来指定路由的具体服务名，<code>path</code>用来配置匹配的请求表达式。</p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。</p>
<p>通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器或拦截器了。</p>
<p>为了在API网关中实现对客户端请求的校验，我们将需要使用Spring Cloud Zuul的另一个功能，<strong>过滤器</strong>。</p>
<p>Zuul允许开发者在API网关上通过定义过滤器来实现对请求的过滤或拦截，实现的方法非常简单，我们只需要继承<code>ZuulFilter</code>抽象类并实现它定义的四个抽象方法就可以完成对请求的拦截和过滤了。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(AccessFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">      	log.info(<span class="string">&quot;send &#123;&#125; request to &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURL().toString());</span><br><span class="line"></span><br><span class="line">        Object accessToken = request.getParameter(<span class="string">&quot;accessToken&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(accessToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;access token is empty&quot;</span>);</span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;access token ok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四个方法的作用：</p>
<blockquote>
<ul>
<li><code>filterType</code>：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为<code>pre</code>，代表会在请求被路由之前执行。</li>
<li><code>filterOrder</code>：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。</li>
<li><code>shouldFilter</code>：判断该过滤器是否需要被执行。这里我们直接返回了<code>true</code>，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。</li>
<li><code>run</code>：过滤器的具体逻辑。这里我们通过<code>ctx.setSendZuulResponse(false)</code>令zuul过滤该请求，不对其进行路由，然后通过<code>ctx.setResponseStatusCode(401)</code>设置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过<code>ctx.setResponseBody(body)</code>对返回body内容进行编辑等。</li>
</ul>
</blockquote>
<h4 id="API文档汇总"><a href="#API文档汇总" class="headerlink" title="API文档汇总"></a>API文档汇总</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><h5 id="构建API网关并整合Swagger"><a href="#构建API网关并整合Swagger" class="headerlink" title="构建API网关并整合Swagger"></a>构建API网关并整合Swagger</h5><p><strong><code>@Primary</code>注解的含义：（当一个接口有多个不同实现时，添加了这个注解）此实现，优先被注入。</strong></p>
]]></content>
      <tags>
        <tag>Dalston</tag>
      </tags>
  </entry>
  <entry>
    <title>服务配置中心-Dalston</title>
    <url>/2021/03/22/%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-Dalston/</url>
    <content><![CDATA[<blockquote>
<p>Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。</p>
</blockquote>
<span id="more"></span>
<h4 id="准备配置仓库"><a href="#准备配置仓库" class="headerlink" title="准备配置仓库"></a>准备配置仓库</h4><ul>
<li>准备一个git仓库，可以在码云或者github上创建都可以。</li>
</ul>
<h4 id="构建配置中心"><a href="#构建配置中心" class="headerlink" title="构建配置中心"></a>构建配置中心</h4><ol>
<li><p>引入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建SpringBoot主类，并添加<code>@EnableConfigServer</code>注解，开启Spring Cloud Config的服务端功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>application.yml</code>中配置服务的基本信息以及Git仓库的相关信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://git.oschina.net/didispace/config-repo-demo/</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1201</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="构建客户端"><a href="#构建客户端" class="headerlink" title="构建客户端"></a>构建客户端</h4><ol>
<li><p>创建一个springBoot应用，并引入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Spring Boot的应用主类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>bootstrap.yml</code>配置，来指定获取配置文件的<code>config-server-git</code>位置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:1201/</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Dalston</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉通路</title>
    <url>/2020/08/27/%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>若一个图为欧拉图或者半欧拉图都可以通过一笔画遍历。</p>
<p>通过图（有向图或无向图）中的所有边且每条边仅通过一次的通路称为 <strong>欧拉通路</strong>， 若此通路为回路则称为 <strong>欧拉回路</strong>。</p>
<p>具有欧拉回路的图称为 <strong>欧拉图</strong>，具有欧拉通路而无欧拉回路的图称为 <strong>半欧拉图</strong>。</p>
<h5 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h5><p>无向图 G 为欧拉图: <strong>当且仅当 G 是连通的且没有奇度顶点。</strong></p>
<p>无向图 G 为半欧拉图：<strong>当且仅当 G 是连通的且恰有两个奇度顶点。</strong></p>
<span id="more"></span>]]></content>
      <tags>
        <tag>java</tag>
        <tag>每日一练</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基本语法</title>
    <url>/2020/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>正则表达式( regular expression ) 描述了一种字符串匹配的模式( pattern )，可以用来检查一个串是否含有某种字串、将匹配的子串替换或者从某个串中取出符合某个条件的字串等等。</p>
<p>几个栗子</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</span><br><span class="line"></span><br><span class="line">runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</span><br><span class="line"></span><br><span class="line">colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配</p>
</blockquote>
<span id="more"></span>
<h5 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h5><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h5 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h5><blockquote>
<p>非打印字符也可以是正则表达式的组成部分</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\cx</td>
<td style="text-align:left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td style="text-align:left">\S</td>
<td style="text-align:left">匹配任何非空白字符。等价于 <sup><a href="#fn_ \f\n\r\t\v" id="reffn_ \f\n\r\t\v"> \f\n\r\t\v</a></sup>。</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><blockquote>
<p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 <strong>*</strong>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 <strong>*</strong> 符号，则需要对 <strong>*</strong> 进行转义，即在其前加一个 <strong>\</strong>: <strong>runo*ob</strong> 匹配 runo*ob。</p>
<p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<strong>\</strong> 放在它们前面。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特别字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td style="text-align:left">( )</td>
<td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em>。</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。</td>
</tr>
<tr>
<td style="text-align:left">{</td>
<td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td>指明两项之间的一个选择。要匹配 \</td>
<td>，请使用 \</td>
<td>。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h5><blockquote>
<p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <strong>*</strong> 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td style="text-align:left">{n}</td>
<td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td style="text-align:left">{n,}</td>
<td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td style="text-align:left">{n,m}</td>
<td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="延申1：不包含某个字符串的正则表达式"><a href="#延申1：不包含某个字符串的正则表达式" class="headerlink" title="延申1：不包含某个字符串的正则表达式"></a>延申1：不包含某个字符串的正则表达式</h5><p>一个栗子：不包含字符串 abc 的正则表达式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">\b((?!abc)\w)+\b</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>\b</code> 匹配单词的开始或结束；</li>
<li><code>?!exp</code> 零宽负向先行断言，只会匹配后缀exp不存在的位置；</li>
<li><p><code>\w</code> 匹配字母或数字或下划线或汉字；</p>
<ul>
<li><code>+</code> 重复一次或更多次；</li>
<li><code>\b((?!abc)\w)+\b</code> 匹配由字母或数字或下划线或汉字组成的字串，但字串中不能出现 abc 。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>每日清单</title>
    <url>/2020/08/11/%E6%AF%8F%E6%97%A5%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<h5 id="2020-08-11"><a href="#2020-08-11" class="headerlink" title="2020-08-11"></a>2020-08-11</h5><ul>
<li>[ ] </li>
</ul>
<span id="more"></span>
<h5 id="2020-08-12"><a href="#2020-08-12" class="headerlink" title="2020-08-12"></a>2020-08-12</h5><ul>
<li>[x] 温州基地看板数据导入功能</li>
</ul>
<h5 id="2020-08-13"><a href="#2020-08-13" class="headerlink" title="2020-08-13"></a>2020-08-13</h5><ul>
<li>[ ] </li>
</ul>
<h5 id="2020-08-14"><a href="#2020-08-14" class="headerlink" title="2020-08-14"></a>2020-08-14</h5><ul>
<li>[x] 公告管理，公告内容使用富文本编辑器，首页公告展示</li>
</ul>
<h5 id="2020-08-17"><a href="#2020-08-17" class="headerlink" title="2020-08-17"></a>2020-08-17</h5><ul>
<li>[x] 首页展示，可进行 tab 页切换</li>
</ul>
<h5 id="2020-08-19"><a href="#2020-08-19" class="headerlink" title="2020-08-19"></a>2020-08-19</h5><ul>
<li>[ ] <del>主页界面，边框栏宽度和主显示区域的宽度大小可以手动拖拽</del></li>
</ul>
<h5 id="2020-08-20"><a href="#2020-08-20" class="headerlink" title="2020-08-20"></a>2020-08-20</h5><ul>
<li>[x] 前后端分离项目，登录界面迁移<ul>
<li>yarn </li>
<li>vue 中带范围的 style</li>
<li>chrome 配置 vue-dev 开发工具</li>
<li>css 背景图片实现渐变色</li>
</ul>
</li>
<li>[x] 前后端分离项目，首页界面迁移（部分）</li>
</ul>
<h5 id="2020-08-24"><a href="#2020-08-24" class="headerlink" title="2020-08-24"></a>2020-08-24</h5><ul>
<li>[x] 将 vue 项目，打包发布到 Nginx ，并测试成功。</li>
</ul>
<h5 id="2020-08-26"><a href="#2020-08-26" class="headerlink" title="2020-08-26"></a>2020-08-26</h5><ul>
<li>[x] vue 项目，主界面样式修改</li>
</ul>
<h5 id="2020-08-27"><a href="#2020-08-27" class="headerlink" title="2020-08-27"></a>2020-08-27</h5><ul>
<li>[ ] vue项目，现存界面的 UI 优化</li>
</ul>
]]></content>
      <tags>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>消息驱动的微服务</title>
    <url>/2021/03/23/%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>先了解下Spring Cloud Stream。</p>
<p>它是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独立的、可用于生产的Spring应用程序。它通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动的微服务应用。</p>
<blockquote>
<p>Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。简单的说，Spring Cloud Stream本质上就是整合了Spring Boot和Spring Integration，实现了一套轻量级的消息驱动的微服务框架。通过使用Spring Cloud Stream，可以有效地简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。</p>
</blockquote>
<p>两个著名的消息中间件的自动化配置：</p>
<ul>
<li><code>RabbitMQ</code></li>
<li><code>Kafka</code></li>
</ul>
<span id="more"></span>
<h5 id="构建一个Spring-Cloud-Stream消费者"><a href="#构建一个Spring-Cloud-Stream消费者" class="headerlink" title="构建一个Spring Cloud Stream消费者"></a>构建一个Spring Cloud Stream消费者</h5><ul>
<li><p>创建工程</p>
</li>
<li><p>在<code>pom.xml</code>文件中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用于接收来自<code>RabbitMQ</code>消息的消费者<code>SinkReceiver</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinkReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SinkReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Received: &quot;</span> + payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个正常的类似Spring Boot的应用主类。</p>
</li>
</ul>
<h4 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h4><p><code>Binder</code>绑定器是Spring Cloud Stream中一个非常重要的概念。</p>
<h5 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h5><p>相对于点对点队列实现的消息通信来说，Spring Cloud Stream采用的发布-订阅模式可以有效地降低消息生产者与消费者之间地耦合，当我们需要对同一类消息增加一种处理方式时，只需要增加一个应用程序并将输入通道绑定到既有的<code>Topic</code>中就可以实现功能的扩展，而不需要改变原来已经实现的任何内容。</p>
<h5 id="消费组"><a href="#消费组" class="headerlink" title="消费组"></a>消费组</h5><p>消费组中只会有一个实例对消息进行消费。</p>
<p>消费分区</p>
<p>当生产者将消息数据发送给多个消费者实例时，保证拥有共同特征的的消息数据始终是由同一个消费者实例接收和处理。</p>
<h4 id="使用消息组实现消息消费的负载均衡"><a href="#使用消息组实现消息消费的负载均衡" class="headerlink" title="使用消息组实现消息消费的负载均衡"></a>使用消息组实现消息消费的负载均衡</h4>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Dalston</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员之项目管理</title>
    <url>/2020/09/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="知识树"><a href="#知识树" class="headerlink" title="知识树"></a>知识树</h4><p>技术管理岗位，需要软件开发的专业知识体系图</p>
<p><img src="http://wrr123.github.io/2020/09/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/技术管理知识树.png" alt></p>
<span id="more"></span>
<p>项目流程分析图</p>
<p><img src="http://wrr123.github.io/2020/09/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%8B%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/项目分析流程.png" alt></p>
<h4 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h4><p>项目管理能力修炼的 6 个阶段：</p>
<ol>
<li>学习项目管理知识体系</li>
<li>以生活中的项目作为练习</li>
<li>观察软件项目，推演项目管理的过程</li>
<li>主动打杂，熟悉某些项目的管理过程</li>
<li>独立带小项目</li>
<li>带大项目</li>
</ol>
<h5 id="学习项目管理知识体系"><a href="#学习项目管理知识体系" class="headerlink" title="学习项目管理知识体系"></a>学习项目管理知识体系</h5><p>可以学习一下 PMBOK，考一个 PMP 认证。</p>
<h5 id="以生活中的项目作为练习"><a href="#以生活中的项目作为练习" class="headerlink" title="以生活中的项目作为练习"></a>以生活中的项目作为练习</h5><blockquote>
<p>其实项目管理并不是软件开发过程中特有的东西，它是通用的技能，可以在变通应用于任何类型的项目，比如电视生产、汽车制造、年会，各种都可以用。所以在一开始我们还是普通开发者，无缘管理项目时，可以通过生活中的项目来练习。</p>
<p>比如国庆长假的旅游，就是一个很好的练手项目，因为它牵涉到多个人、成本、线路规划、住宿、交通、饮食等等，比较复杂，几乎包含了项目管理的 10 个过程。</p>
<p>我们在生活类项目中练就的能力，比如规划、进度管理、成本控制，都可以直接拿到软件项目中使用。</p>
</blockquote>
<h5 id="观察软件项目，推演项目管理的过程"><a href="#观察软件项目，推演项目管理的过程" class="headerlink" title="观察软件项目，推演项目管理的过程"></a>观察软件项目，推演项目管理的过程</h5><blockquote>
<p>我们还不是项目经理、技术经理的时候，可以观察别人是怎么做的，把自己放在管理角色上，来推演自己会怎么做，这样也是一种有效的练习。</p>
<p>一个简单有效的练习方法，是给自己定一个目标：每天挑出一个项目管理相关的问题来琢磨解决之道。</p>
<ul>
<li>比如代码管理工具使用 svn 而不使用 git 会有什么问题；</li>
<li>比如每日站会上有些程序员每天都说“昨天改 Bug ，还没查出原因，今天接着改 Bug ”到底有无意义；</li>
<li>比如开发因为技术实现原因而选择忽略 App 的视频启动动画，需求不同意，该怎样和她沟通；</li>
<li>比如前端开发者元小二经常性地把 Bug 直接分配给后端开发袁大头，两人为此不断口角，怎么解决；</li>
<li>比如有几位程序员，提交代码时不写任何日志；</li>
<li>比如阿三提交代码十次有八次不做集成构建测试；</li>
<li>比如老板总是越过项目经理直接指挥团队的开发者新增需求；</li>
<li>……</li>
</ul>
<p>带着问题去学习，是最有效的方式。</p>
</blockquote>
<h5 id="主动打杂，熟悉某些项目的管理过程"><a href="#主动打杂，熟悉某些项目的管理过程" class="headerlink" title="主动打杂，熟悉某些项目的管理过程"></a>主动打杂，熟悉某些项目的管理过程</h5><blockquote>
<p>生活中练习，工作中代入角色，日常推演，这些方法可以让我们熟悉项目管理的知识、技能和过程，但有效的办法，还是直接做目标领域的项目管理工作。</p>
<p>有人说我不是项目经理啊，怎么做项目管理？</p>
<p>别急，你虽然不是项目经理，但你身在项目之中，承担了某个角色嘛，那自然有些工作是和你相关的。另外，更关键的是：你要跳出工作内容和岗位职责的范围，放眼全局来思考。</p>
<p>站出来，你才有机会。老想等着领导看见你给你机会，那是不可能有机会的。</p>
<p>所以，你要用心观察，发现机会，主动去做。</p>
<p>比如拔高自己，站在全局视角思考整个项目，从立项、需求、开发、测试、交付、运维、项目生产工具，分析哪个环节做得不好，哪个环节改善之后效果可以被看见，主动去做这些事情，主动成为衔接不同环节、不同人员、不同部门的桥梁；</p>
<p>比如观察项目经理、研发经理，看他们有哪些项目管理相关的事情是不愿意做的，比如组织会议、跟踪计划、分派任务、推动多干系人协作等，主动找他们表达你可以分担这部分工作的意愿，获得打杂的机会。</p>
<p>有心就可以发现很多可以发挥的机会——因为大多数开发者都嫌麻烦不想把事情揽在自己身上哦。</p>
</blockquote>
<h5 id="独立带小项目"><a href="#独立带小项目" class="headerlink" title="独立带小项目"></a>独立带小项目</h5><blockquote>
<p>如果我们在第四个阶段做出一些亮点，比如会议组织的很好、项目计划跟踪的很到位，那团队有新的项目时，经理可能就会安排你来管理。到这个时候，你就可以系统地进行项目管理了。</p>
<p>自己独立带小项目时，要注意下面这些点：</p>
<ul>
<li>充分了解项目背景、需求、目标、交付要求、时间要求、干系人等。</li>
<li>充分了解研发团队成员的情况，谁是什么性格、行为风格，擅长什么技术，有哪些项目经验。这点尤其重要，因为大多数软件项目的管理，都不是全过程的，而是集中在软件开发生命周期（产品定义、需求分析、开发、测试等），这个阶段，研发团队成员非常关键。</li>
<li>充分了解团队曾经使用过的开发过程和工具，比如迭代、精益、SCRUM、看板、Redmine、JIRA 等，选择大家熟悉的。</li>
<li>不要在项目管理过程中全面引入新方法、新过程、新工具，尽量在现有基础上来做渐进式改革。</li>
<li>建立有效的反馈渠道（会议、周报、特定的信任你的项目成员等），能适时了解项目管理的效果。很多人一开始带项目，只管推方法、推工具，不知道实际的效果如何，往往是把经念歪了还不知道。</li>
</ul>
</blockquote>
<h5 id="带大项目"><a href="#带大项目" class="headerlink" title="带大项目"></a>带大项目</h5><blockquote>
<p>经历了第五阶段若干个小项目的实践，我们对软件项目管理应该有了丰富的知识积累和实践经验，可以挑战比较大的项目了。</p>
<p>5 个人 2 个月可以完成的小项目，与 100 个人 2 年才能完成的中大型项目，不是一个概念，对项目管理能力的要求，非常不同。具体怎么不同，我没做过太大的项目，并不知道啊……</p>
<p>呃，所以，这个阶段，我没什么好说的……如果你有经验，文后留言来聊聊呀。</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法思想3</title>
    <url>/2021/03/08/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B33/</url>
    <content><![CDATA[<h4 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>枚举算法<ul>
<li>列举问题的所有状态从而寻找符合问题的解的方法</li>
<li>适合用于状态较少，比较简单的问题上</li>
</ul>
</li>
<li>广度优先搜索<ul>
<li>从初始点开始，根据规则展开第一层节点，并检查目标节点是否在这些节点上，若没有，再将所有的第一层的节点逐一展开，得到第二层节点，如没有，则扩展下去，直到发现目标节点为止。</li>
<li>比较适合求最少步骤或最短解序列的题目</li>
<li>一般设置一个队列 <strong>queue</strong>，将初始点放入队列中，然后从队列头取出一个节点，检查是否是目标节点，如不是则进行扩展，将扩展出的所有节点放到队尾，然后再从队列头取出一个节点，直至找到目标节点。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li>深度优先搜索<ul>
<li>一般先设置一个 <strong>stack</strong>，将起始点放入栈中，然后从栈中弹出一个节点，检查是否是目标节点，如不是则进行扩展，将扩展出的所有结点入栈，然后再从栈顶弹出一个节点，直到找到目标节点。</li>
<li>深度优先搜索得到的第一个解，不一定是最优解。</li>
</ul>
</li>
<li>双向广度优先搜索<ul>
<li>双向搜索：从起始节点向目标节点方向搜索，同时从目标节点向起始节点方向搜索。</li>
<li>双向搜索只能用于广度优先搜索。</li>
<li>双向搜索扩展的节点数量要比单向少得多。</li>
</ul>
</li>
<li>A * 算法<ul>
<li><strong>利用问题的规则和特点来制定一些启发规则，由此改变节点的扩展顺序，将最优希望扩展出最优解的节点优先扩展，使得尽快找到最优解。</strong></li>
<li>对每一个节点，有一个股价函数F来估算起始节点经过该节点到达目标节点的最佳路径的代价。</li>
<li>每个节点扩展的时候，总是选择具有最小的F的节点。</li>
<li>$F=G+B*H$，G为从起始节点到当前节点的实际代价，已经算出，H为从该节点到目标节点的最优路径的估计代价。F要单调递增。</li>
<li>B最好随着搜索深度成反比变化，在搜索深浅度的地方，主要让搜索依靠启发信息，尽快的逼近目标，而当搜索深的时候，逐渐变成广度优先搜索。</li>
</ul>
</li>
<li>回溯算法<ul>
<li>和深度优先相似，不同之处在于对一个节点扩展的时候，并不将所有的子节点扩展出来，而只扩展其中的一个。因而具有盲目性，但内存占用少。</li>
</ul>
</li>
</ul>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><ul>
<li>在搜索前，根据条件降低搜索规模</li>
<li>广度优先搜索中，被处理过的节点，删除掉，充分释放空间</li>
<li>根据问题的约束条件进行剪枝</li>
<li>利用搜索过程中的中间解，避免重复计算</li>
</ul>
<h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><p><code>Backtracking(回溯)</code>属于<code>DFS</code>。回溯算法实际上是一个类似枚举的搜索尝试过程，主要在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原来选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。</p>
<h5 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h5><ul>
<li>普通 DFS 主要用在 <strong>可达性问题</strong>，这种问题只需要执行到特定的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解 <strong>排列组合</strong> 问题，例如有 <code>&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</code> 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>因为 Backtracking 不是立即就返回，而要继续求解，因为在程序实现时，需要注意对元素的标记问题：</p>
<ul>
<li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li>
<li>但是在递归返回时，需要将元素标记为 <strong>未访问</strong>，因为只需要保证在一个递归链中不同时访问一个元素，<strong>可以访问已经访问过</strong>但是 <strong>不在当前递归链中的元素。</strong></li>
</ul>
<h5 id="数字键盘组合问题"><a href="#数字键盘组合问题" class="headerlink" title="数字键盘组合问题"></a>数字键盘组合问题</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.thought;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回溯算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/8 15:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Backtracking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] KEYS = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doCombination</span><span class="params">(StringBuilder prefix, List&lt;String&gt; combinations, <span class="keyword">final</span> String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == digits.length()) &#123;</span><br><span class="line">            combinations.add(prefix.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curDigits = digits.charAt(prefix.length()) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        String letters = KEYS[curDigits];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : letters.toCharArray()) &#123;</span><br><span class="line">            prefix.append(c);</span><br><span class="line">            doCombination(prefix, combinations, digits);</span><br><span class="line">            prefix.deleteCharAt(prefix.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        doCombination(<span class="keyword">new</span> StringBuilder(), combinations, digits);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = letterCombinations(<span class="string">&quot;2344&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ans = &quot;</span> + ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数</title>
    <url>/2020/09/03/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125; </span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"><span class="comment">//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当只有一个参数时，圆括号是可选的：</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有参数的函数应该写成一对圆括号。</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<h4 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加括号的函数体返回对象字面量表达式：</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持剩余参数和默认参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; </span><br><span class="line">statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样支持参数列表解构</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line">f();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>统一建模语言</title>
    <url>/2020/09/17/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h4 id="什么是-UML"><a href="#什么是-UML" class="headerlink" title="什么是 UML"></a>什么是 UML</h4><p>Unified Modeling Language （UML 又称为统一建模语言或标准建模语言）是国际对象管理组织 OMG 制定的一个通用的、可视化建模语言标准，可以用来描述（specify）、可视化（visualize）、构造（construct）和记载（document）软件密集型的各种工作（artifacts）。</p>
<p>UML 有什么用？</p>
<p>UML 的用途非常广泛，可以概括为 “描述、可视化、构造、记载” 4种基本功能，在 <strong>业务建模、需求分析、系统设计、实现和测试、数据建模、项目管理等</strong> 阶段任务中均可根据需要采用。</p>
<p>UML 由哪些元素组成</p>
<p>UML 由 3 个要素构成：UML 的基本构造块、支配这些构造块如何放置在一起的规则和运用于整个语言的公用机制。</p>
<span id="more"></span>
<h5 id="UML-基本构造块"><a href="#UML-基本构造块" class="headerlink" title="UML 基本构造块"></a>UML 基本构造块</h5><ol>
<li><p>事物</p>
<p> 构成模型图的一些基本图示符号，它们表示一些面向对象的基本概念。</p>
<p> 事物是对模型中最具代表性的成分的抽象，包括结构事物、行为事物、分组事物和注释事物。</p>
<p> 结构事物：如 类（Class）、接口（Interface）、协作（collaboration）、用例（UseCase）、主动类（ActiveClass）、组件（Component）和节点（Node）。</p>
<p> 行为事物：如交互（interaction）、态机（Statemachine）。</p>
<p> 分组事物：包（package）。</p>
<p> 注释事物：注解（Note）</p>
</li>
<li><p>关系</p>
<p> 表示基本图示符号之间的关系。</p>
<p> 关系用来把事物结合在一起，包括依赖、关联、泛华和实现关系。</p>
</li>
<li><p>图</p>
<p> 图聚集了相关的事物及其关系的结合，是软件系统在不同角度下的投影。</p>
<p> 图由代表事物的顶点和代表关系的连通图表示。特定的视角对系统所作的抽象描述。</p>
<p> UML 从考虑系统的不同角度出发，定义了 <strong>用例图、类图、对象图、状态图、活动图、序列图、协作图、构件图、部署图</strong> 等 9 种图。</p>
</li>
</ol>
<h4 id="plantUML"><a href="#plantUML" class="headerlink" title="plantUML"></a>plantUML</h4><h5 id="简单活动图"><a href="#简单活动图" class="headerlink" title="简单活动图"></a>简单活动图</h5><p>开始/结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">:Hello world;</span><br><span class="line">:This is on defined on</span><br><span class="line">several **lines**;</span><br><span class="line">stop &#x2F; end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>条件语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line"></span><br><span class="line">if (Graphviz installed?) then (yes)</span><br><span class="line">  :process all\ndiagrams;</span><br><span class="line">else (no)</span><br><span class="line">  :process only</span><br><span class="line">  __sequence__ and __activity__ diagrams;</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">if (condition A) then (yes)</span><br><span class="line">  :Text 1;</span><br><span class="line">elseif (condition B) then (yes)</span><br><span class="line">  :Text 2;</span><br><span class="line">  stop</span><br><span class="line">elseif (condition C) then (yes)</span><br><span class="line">  :Text 3;</span><br><span class="line">elseif (condition D) then (yes)</span><br><span class="line">  :Text 4;</span><br><span class="line">else (nothing)</span><br><span class="line">  :Text else;</span><br><span class="line">endif</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>重复循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line"></span><br><span class="line">repeat</span><br><span class="line">  :read data;</span><br><span class="line">  :generate diagrams;</span><br><span class="line">repeat while (more data?)</span><br><span class="line"></span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line"></span><br><span class="line">repeat :foo as starting label;</span><br><span class="line">  :read data;</span><br><span class="line">  :generate diagrams;</span><br><span class="line">backward:This is backward;</span><br><span class="line">repeat while (more data?)</span><br><span class="line"></span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>while 循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line"></span><br><span class="line">while (data available?)</span><br><span class="line">  :read data;</span><br><span class="line">  :generate diagrams;</span><br><span class="line">endwhile</span><br><span class="line"></span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">while (check filesize ?) is (not empty)</span><br><span class="line">  :read file;</span><br><span class="line">endwhile (empty)</span><br><span class="line">:close file;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>并行处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line"></span><br><span class="line">if (multiprocessor?) then (yes)</span><br><span class="line">  fork</span><br><span class="line">    :Treatment 1;</span><br><span class="line">  fork again</span><br><span class="line">    :Treatment 2;</span><br><span class="line">  end fork</span><br><span class="line">else (monoproc)</span><br><span class="line">  :Treatment 1;</span><br><span class="line">  :Treatment 2;</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">:foo1;</span><br><span class="line">floating note left: This is a note</span><br><span class="line">:foo2;</span><br><span class="line">note right</span><br><span class="line">  This note is on several</span><br><span class="line">  &#x2F;&#x2F;lines&#x2F;&#x2F; and can</span><br><span class="line">  contain &lt;b&gt;HTML&lt;&#x2F;b&gt;</span><br><span class="line">  &#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">  * Calling the method &quot;&quot;foo()&quot;&quot; is prohibited</span><br><span class="line">end note</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">:starting progress;</span><br><span class="line">#HotPink:reading configuration files</span><br><span class="line">These files should edited at this point!;</span><br><span class="line">#AAAAAA:ending of the process;</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>箭头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">:foo1;</span><br><span class="line">-&gt; You can put text on arrows;</span><br><span class="line">if (test) then</span><br><span class="line">  -[#blue]-&gt;</span><br><span class="line">  :foo2;</span><br><span class="line">  -[#green,dashed]-&gt; The text can</span><br><span class="line">  also be on several lines</span><br><span class="line">  and **very** long...;</span><br><span class="line">  :foo3;</span><br><span class="line">else</span><br><span class="line">  -[#black,dotted]-&gt;</span><br><span class="line">  :foo4;</span><br><span class="line">endif</span><br><span class="line">-[#gray,bold]-&gt;</span><br><span class="line">:foo5;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>连接器（Connector）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">:Some activity;</span><br><span class="line">(A)</span><br><span class="line">detach</span><br><span class="line">(A)</span><br><span class="line">:Other activity;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>组合（grouping）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">partition Initialization &#123;</span><br><span class="line">    :read config file;</span><br><span class="line">    :init internal variable;</span><br><span class="line">&#125;</span><br><span class="line">partition Running &#123;</span><br><span class="line">    :wait for user interaction;</span><br><span class="line">    :print information;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>泳道（Swimlanes）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">|Swimlane1|</span><br><span class="line">start</span><br><span class="line">:foo1;</span><br><span class="line">|#AntiqueWhite|Swimlane2|</span><br><span class="line">:foo2;</span><br><span class="line">:foo3;</span><br><span class="line">|Swimlane1|</span><br><span class="line">:foo4;</span><br><span class="line">|Swimlane2|</span><br><span class="line">:foo5;</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>分离（detach）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"> :start;</span><br><span class="line"> fork</span><br><span class="line">   :foo1;</span><br><span class="line">   :foo2;</span><br><span class="line"> fork again</span><br><span class="line">   :foo3;</span><br><span class="line">   detach</span><br><span class="line"> endfork</span><br><span class="line"> if (foo4) then</span><br><span class="line">   :foo5;</span><br><span class="line">   detach</span><br><span class="line"> endif</span><br><span class="line"> :foo6;</span><br><span class="line"> detach</span><br><span class="line"> :foo7;</span><br><span class="line"> stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>特殊领域语言（SDL）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">:Ready;</span><br><span class="line">:next(o)|</span><br><span class="line">:Receiving;</span><br><span class="line">split</span><br><span class="line"> :nak(i)&lt;</span><br><span class="line"> :ack(o)&gt;</span><br><span class="line">split again</span><br><span class="line"> :ack(i)&lt;</span><br><span class="line"> :next(o)</span><br><span class="line"> on several line|</span><br><span class="line"> :i :&#x3D; i + 1]</span><br><span class="line"> :ack(o)&gt;</span><br><span class="line">split again</span><br><span class="line"> :err(i)&lt;</span><br><span class="line"> :nak(o)&gt;</span><br><span class="line">split again</span><br><span class="line"> :foo&#x2F;</span><br><span class="line">split again</span><br><span class="line"> :i &gt; 5&#125;</span><br><span class="line">stop</span><br><span class="line">end split</span><br><span class="line">:finish;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<h5 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h5><h5 id="甘特图（gantt）"><a href="#甘特图（gantt）" class="headerlink" title="甘特图（gantt）"></a>甘特图（gantt）</h5><h6 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h6><p>使用 <code>last</code> 动词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Prototype design] lasts 15 days</span><br><span class="line">[Test prototype] lasts 10 days</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h6><p>使用 <code>start</code> 动词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">[Design du prototype] lasts 15 days</span><br><span class="line">[Test du prototype] lasts 10 days</span><br><span class="line"></span><br><span class="line">Project starts 2020-07-01</span><br><span class="line">[Design du prototype] starts 2020-07-01</span><br><span class="line">[Test du prototype] starts 2020-07-16</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<h6 id="End"><a href="#End" class="headerlink" title="End"></a>End</h6><p>使用 <code>end</code> 动词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">[Design du prototype] lasts 15 days</span><br><span class="line">[Test du prototype] lasts 10 days</span><br><span class="line"></span><br><span class="line">Project starts 2020-07-01</span><br><span class="line">[Design du prototype] ends 2020-07-15</span><br><span class="line">[Test du prototype] ends 2020-07-25</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<h6 id="Start-End"><a href="#Start-End" class="headerlink" title="Start/End"></a>Start/End</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">Project starts 2020-07-01</span><br><span class="line">[Design du prototype] starts 2020-07-01</span><br><span class="line">[Test du prototype] starts 2020-07-16</span><br><span class="line">[Design du prototype] ends 2020-07-15</span><br><span class="line">[Test du prototype] ends 2020-07-25</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<h6 id="One-line-declaration-with-the-‘and’-conjunction"><a href="#One-line-declaration-with-the-‘and’-conjunction" class="headerlink" title="One-line declaration (with the ‘and’ conjunction)"></a>One-line declaration (with the ‘and’ conjunction)</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Project starts 2020-07-01</span><br><span class="line">[Design du prototype] starts 2020-07-01 and ends 2020-07-15</span><br><span class="line">[Test du prototype] starts 2020-07-16 and lasts 10 days</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<h6 id="Adding-constraint"><a href="#Adding-constraint" class="headerlink" title="Adding constraint"></a>Adding constraint</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Prototype design] lasts 10 days</span><br><span class="line">[Code prototype] lasts 10 days</span><br><span class="line">[Write tests] lasts 5 days</span><br><span class="line">[Code prototype] starts at [Prototype design]&#39;s end</span><br><span class="line">[Write tests] starts at [Code prototype]&#39;s start</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Short-names"><a href="#Short-names" class="headerlink" title="Short names"></a>Short names</h6><p>使用 <code>as</code> 关键字给任务设置别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Prototype design] as [D] lasts 15 days</span><br><span class="line">[Test prototype] as [T] lasts 10 days</span><br><span class="line">[T] starts at [D]&#39;s end</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Customize-colors"><a href="#Customize-colors" class="headerlink" title="Customize colors"></a>Customize colors</h6><p>使用 <code>is colored in</code> 给任务定制颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Prototype design] lasts 13 days</span><br><span class="line">[Test prototype] lasts 4 days</span><br><span class="line">[Test prototype] starts at [Prototype design]&#39;s end</span><br><span class="line">[Prototype design] is colored in Fuchsia&#x2F;FireBrick</span><br><span class="line">[Test prototype] is colored in GreenYellow&#x2F;Green</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Completion-status"><a href="#Completion-status" class="headerlink" title="Completion status"></a>Completion status</h6><p>给任务设置完成状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[foo] lasts 21 days</span><br><span class="line">[foo] is 40% completed</span><br><span class="line">[bar] lasts 30 days and is 10% complete</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Milestone"><a href="#Milestone" class="headerlink" title="Milestone"></a>Milestone</h6><p>使用动词 <code>happen</code> 来定义里程碑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Test prototype] lasts 10 days</span><br><span class="line">[Prototype completed] happens at [Test prototype]&#39;s end</span><br><span class="line">[Setup assembly line] lasts 12 days</span><br><span class="line">[Setup assembly line] starts at [Test prototype]&#39;s end</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Hyperlinks"><a href="#Hyperlinks" class="headerlink" title="Hyperlinks"></a>Hyperlinks</h6><p>你可以给任务定义超链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[task1] lasts 10 days</span><br><span class="line">[task1] links to [[http:&#x2F;&#x2F;plantuml.com]]</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h6><p>日历</p>
<p>你可以为整个项目指定一个开始日期。默认的，第一个任务从这个日期开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">Project starts the 20th of september 2017</span><br><span class="line">[Prototype design] as [TASK1] lasts 13 days</span><br><span class="line">[TASK1] is colored in Lavender&#x2F;LightBlue</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Coloring-days"><a href="#Coloring-days" class="headerlink" title="Coloring days"></a>Coloring days</h6><p>给某些日期加上颜色也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">Project starts the 2020&#x2F;09&#x2F;01 </span><br><span class="line"></span><br><span class="line">2020&#x2F;09&#x2F;07 is colored in salmon</span><br><span class="line">2020&#x2F;09&#x2F;13 to 2020&#x2F;09&#x2F;16 are colored in lightblue</span><br><span class="line"></span><br><span class="line">[Prototype design] as [TASK1] lasts 22 days</span><br><span class="line">[TASK1] is colored in Lavender&#x2F;LightBlue</span><br><span class="line">[Prototype completed] happens at [TASK1]&#39;s end</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Changing-scale"><a href="#Changing-scale" class="headerlink" title="Changing scale"></a>Changing scale</h6><p>使用下面的变量你可以改变一个非常长的项目的范围：</p>
<ul>
<li>Printscale</li>
<li>ganttscale</li>
<li>projectscale</li>
</ul>
<p>加上使用下面的变量</p>
<ul>
<li>weekly</li>
<li>monthly</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">printscale weekly</span><br><span class="line">Project starts the 20th of september 2020</span><br><span class="line">[Prototype design] as [TASK1] lasts 130 days</span><br><span class="line">[TASK1] is colored in Lavender&#x2F;LightBlue</span><br><span class="line">[Testing] lasts 20 days</span><br><span class="line">[TASK1]-&gt;[Testing]</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Close-day"><a href="#Close-day" class="headerlink" title="Close day"></a>Close day</h6><p>关闭某些日期也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">project starts the 2018&#x2F;04&#x2F;09</span><br><span class="line">saturday are closed</span><br><span class="line">sunday are closed</span><br><span class="line">2018&#x2F;05&#x2F;01 is closed</span><br><span class="line">2018&#x2F;04&#x2F;17 to 2018&#x2F;04&#x2F;19 is closed</span><br><span class="line">[Prototype design] lasts 14 days</span><br><span class="line">[Test prototype] lasts 4 days</span><br><span class="line">[Test prototype] starts at [Prototype design]&#39;s end</span><br><span class="line">[Prototype design] is colored in Fuchsia&#x2F;FireBrick</span><br><span class="line">[Test prototype] is colored in GreenYellow&#x2F;Green</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">2020-07-07 to 2020-07-17 is closed</span><br><span class="line">2020-07-13 is open</span><br><span class="line"></span><br><span class="line">Project starts the 2020-07-01</span><br><span class="line">[Prototype design] lasts 10 days</span><br><span class="line">Then [Test prototype] lasts 10 days</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h6 id="Simplfied-task-succession"><a href="#Simplfied-task-succession" class="headerlink" title="Simplfied task succession"></a>Simplfied task succession</h6><p>简化任务交接</p>
<p>使用关键字 <code>then</code> 来表示连续性的任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Edit online</span><br><span class="line">@startgantt</span><br><span class="line">[Prototype design] lasts 14 days</span><br><span class="line">then [Test prototype] lasts 4 days</span><br><span class="line">then [Deploy prototype] lasts 6 days</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<p>也可以使用箭头 <code>➡</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Prototype design] lasts 14 days</span><br><span class="line">[Build prototype] lasts 4 days</span><br><span class="line">[Prepare test] lasts 6 days</span><br><span class="line">[Prototype design] -&gt; [Build prototype]</span><br><span class="line">[Prototype design] -&gt; [Prepare test]</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Separator"><a href="#Separator" class="headerlink" title="Separator"></a>Separator</h6><p>使用 <code>--</code> 来分隔任务集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Task1] lasts 10 days</span><br><span class="line">then [Task2] lasts 4 days</span><br><span class="line">-- Phase Two --</span><br><span class="line">then [Task3] lasts 5 days</span><br><span class="line">then [Task4] lasts 6 days</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Working-with-resources"><a href="#Working-with-resources" class="headerlink" title="Working with resources"></a>Working with resources</h6><p>使用关键字 <code>on</code> 和 方括号 <code>&#123;&#125;</code>,可以给指定具体的人。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Task1] on &#123;Alice&#125; lasts 10 days</span><br><span class="line">[Task2] on &#123;Bob:50%&#125; lasts 2 days</span><br><span class="line">then [Task3] on &#123;Alice:25%&#125; lasts 1 days</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<p>指定多个人也是可以的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Task1] on &#123;Alice&#125; &#123;Bob&#125; lasts 20 days</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<p>使用 <code>off</code> 关键字可以在指定的天数设置为缺勤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">project starts on 2020-06-19</span><br><span class="line">[Task1] on &#123;Alice&#125; lasts 10 days</span><br><span class="line">&#123;Alice&#125; is off on 2020-06-24 to 2020-06-26</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h6><p>注释</p>
<p>所有已单引号 <code>&#39;</code> 开头的都是注释。</p>
<p>你也可以设置多行注释，使用 <code>/&#39;</code> 开始，<code>&#39;/</code> 结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">&#39; This is a comment</span><br><span class="line"></span><br><span class="line">[T1] lasts 3 days</span><br><span class="line"></span><br><span class="line">&#x2F;&#39; this comment</span><br><span class="line">is on several lines &#39;&#x2F;</span><br><span class="line"></span><br><span class="line">[T2] starts at [T1]&#39;s end and lasts 1 day</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<p>Using style</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">&lt;style&gt;</span><br><span class="line">ganttDiagram &#123;</span><br><span class="line">	task &#123;</span><br><span class="line">		FontName Helvetica</span><br><span class="line">		FontColor red</span><br><span class="line">		FontSize 18</span><br><span class="line">		FontStyle bold</span><br><span class="line">		BackGroundColor GreenYellow</span><br><span class="line">		LineColor blue</span><br><span class="line">	&#125;</span><br><span class="line">	milestone &#123;</span><br><span class="line">		FontColor blue</span><br><span class="line">		FontSize 25</span><br><span class="line">		FontStyle italic</span><br><span class="line">		BackGroundColor yellow</span><br><span class="line">		LineColor red</span><br><span class="line">	&#125;</span><br><span class="line">	note &#123;</span><br><span class="line">		FontColor DarkGreen</span><br><span class="line">		FontSize 10</span><br><span class="line">		LineColor OrangeRed</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">[Task1] lasts 20 days</span><br><span class="line">note bottom</span><br><span class="line">  memo1 ...</span><br><span class="line">  memo2 ...</span><br><span class="line">  explanations1 ...</span><br><span class="line">  explanations2 ...</span><br><span class="line">end note</span><br><span class="line">[Task2] lasts 4 days</span><br><span class="line">[Task1] -&gt; [Task2]</span><br><span class="line">-- Separator title --</span><br><span class="line">[M1] happens on 5 days after [Task1]&#39;s end</span><br><span class="line">-- end --</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<h6 id="Add-notes"><a href="#Add-notes" class="headerlink" title="Add notes"></a>Add notes</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[task01] lasts 15 days</span><br><span class="line">note bottom</span><br><span class="line">  memo1 ...</span><br><span class="line">  memo2 ...</span><br><span class="line">  explanations1 ...</span><br><span class="line">  explanations2 ...</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">[task01] -&gt; [task02]</span><br><span class="line"></span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h6 id="Pause-task"><a href="#Pause-task" class="headerlink" title="Pause task"></a>Pause task</h6><p>暂停任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">Project starts the 5th of december 2018</span><br><span class="line">saturday are closed</span><br><span class="line">sunday are closed</span><br><span class="line">2018&#x2F;12&#x2F;29 is opened</span><br><span class="line">[Prototype design] lasts 17 days</span><br><span class="line">[Prototype design] pauses on 2018&#x2F;12&#x2F;13</span><br><span class="line">[Prototype design] pauses on 2018&#x2F;12&#x2F;14</span><br><span class="line">[Prototype design] pauses on monday</span><br><span class="line">[Test prototype] starts at [Prototype design]&#39;s end and lasts 2 weeks</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Change-link-colors"><a href="#Change-link-colors" class="headerlink" title="Change link colors"></a>Change link colors</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Links are colored in blue</span><br><span class="line">[Prototype design] lasts 14 days</span><br><span class="line">[Build prototype] lasts 4 days</span><br><span class="line">[Prepare test] lasts 6 days</span><br><span class="line">[Prototype design] -[#FF00FF]-&gt; [Build prototype]</span><br><span class="line">[Prototype design] -[dotted]-&gt; [Prepare test]</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<h6 id="Tasks-or-milestone-on-the-same-line"><a href="#Tasks-or-milestone-on-the-same-line" class="headerlink" title="Tasks or milestone on the same line"></a>Tasks or milestone on the same line</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">[Prototype design] lasts 13 days</span><br><span class="line">[Test prototype] lasts 4 days and 1 week</span><br><span class="line">[Test prototype] starts 1 week and 2 days after [Prototype design]&#39;s end</span><br><span class="line">[Test prototype] displays on same row as [Prototype design]</span><br><span class="line">[r1] happens on 5 days after [Prototype design]&#39;s end</span><br><span class="line">[r2] happens on 5 days after [r1]&#39;s end</span><br><span class="line">[r3] happens on 5 days after [r2]&#39;s end</span><br><span class="line">[r2] displays on same row as [r1]</span><br><span class="line">[r3] displays on same row as [r1]</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Highlightly-today"><a href="#Highlightly-today" class="headerlink" title="Highlightly today"></a>Highlightly today</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">Project starts the 20th of september 2018</span><br><span class="line">sunday are close</span><br><span class="line">2018&#x2F;09&#x2F;21 to 2018&#x2F;09&#x2F;23 are colored in salmon</span><br><span class="line">2018&#x2F;09&#x2F;21 to 2018&#x2F;09&#x2F;30 are named [Vacation in the Bahamas] </span><br><span class="line"></span><br><span class="line">today is 30 days after start and is colored in #AAF</span><br><span class="line">[Foo] happens 40 days after start</span><br><span class="line">[Dummy] lasts 10 days and starts 10 days after start</span><br><span class="line"></span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Task-between-two-milestones"><a href="#Task-between-two-milestones" class="headerlink" title="Task between two milestones"></a>Task between two milestones</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startgantt</span><br><span class="line">project starts on 2020-07-01</span><br><span class="line">[P_start] happens 2020-07-03</span><br><span class="line">[P_end]   happens 2020-07-13</span><br><span class="line">[Prototype design] occurs from [P_start] to [P_end]</span><br><span class="line">@endgantt</span><br></pre></td></tr></table></figure>
<h6 id="Add-title-header-footer-caption-or-legend-on-gantt-diagram"><a href="#Add-title-header-footer-caption-or-legend-on-gantt-diagram" class="headerlink" title="Add title,(header, footer),caption or legend on gantt diagram"></a>Add title,(header, footer),caption or legend on gantt diagram</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">&#39;header some header</span><br><span class="line"></span><br><span class="line">&#39;footer some footer</span><br><span class="line"></span><br><span class="line">title My title</span><br><span class="line"></span><br><span class="line">[Prototype design] lasts 13 days</span><br><span class="line"></span><br><span class="line">legend</span><br><span class="line">The legend</span><br><span class="line">end legend</span><br><span class="line"></span><br><span class="line">caption This is caption</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><h6 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h6><p><code>泛化、依赖、关联、实现、聚合、组合</code></p>
<ul>
<li><p>泛化关系（Generalization）</p>
<p>  也就是继承关系，也称为 <code>is-a-kind-of</code> 关系。</p>
<p>  在 UML 中，泛化关系用带 <strong>空心三角形</strong> 的直线来表示。</p>
</li>
<li><p>依赖关系（Dependency）</p>
<p>  是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。</p>
<p>  大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。</p>
<p>  在 UML 中，依赖关系用 <strong>带箭头的虚线</strong> 表示，由依赖的一方指向被依赖的一方。</p>
<p>  依赖关系有下面三种情况：</p>
<ol>
<li>A 类是 B 类中的(或某种方法中)局部变量</li>
<li>A 类是 B 类 方法当中的一个参数</li>
<li>A 类向 B 类发送信息，从而影响 B 类发生变化</li>
</ol>
</li>
<li><p>关联关系（Association）</p>
<p>  是一种结构关系，说明一个事物的对象与另一个事物的对象相联系。给定有关联的两个类，可以从一个类的对象得到另一个类的对象。</p>
<p>  关联有两元关系和多元关系。两元关系是指一种一对一的关系，多元关系是指一种一对多或多对一的关系。</p>
<p>  在 UML 图中，用 <strong>实线连接</strong> 有关联的对象所对应的类，在 Java 等编程语言中实线关联关系时，通常将一个类的对象作为另一个类的属性。</p>
</li>
<li><p>聚合关系（Aggregation）</p>
<p>  聚合关系是一个整体和部分的关系，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是 <strong>成员对象可以脱离整体对象独立存在。</strong></p>
<p>  在 UML 中，聚合关系用 <strong>带空心菱形</strong> 的直线表示</p>
</li>
<li><p>组合关系（Composition）</p>
<p>  表示类之间整体和部分的关系，但是组合关系中整体和部分具有统一的生存期。一旦整体对象不存在，那么部分对象也将不存在。</p>
<p>  在 UML 中，组合关系用 <strong>带实心菱形的直线</strong> 表示。</p>
</li>
<li><p>实现关系（Implementation）</p>
<p>  在 UML 中，类与接口之间的实现关系用 <strong>带空心三角形的虚线</strong> 来表示。</p>
</li>
</ul>
<p>​    </p>
<p>​    </p>
<p>​    </p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-uml流程图</title>
    <url>/2021/02/18/%E8%BD%AF%E8%80%83-uml%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>流程，flow，是指特定主体为了满足特定需求而进行的有特定逻辑关系的一系列操作，流程是自然而然就存在的。</p>
<p>图，chart或diagram，是将基本固化有一定规律的流程进行显性化和书面化，从而有利于传播和沉淀、流程重组参考。</p>
<span id="more"></span>
<h4 id="六大要素"><a href="#六大要素" class="headerlink" title="六大要素"></a>六大要素</h4><ol>
<li>参与者</li>
<li>活动</li>
<li>次序</li>
<li>输入</li>
<li>输出</li>
<li>标准化</li>
</ol>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li>业务流程图</li>
<li>页面流程图</li>
</ol>
<h5 id="更细的一些分类"><a href="#更细的一些分类" class="headerlink" title="更细的一些分类"></a>更细的一些分类</h5><p>按主体</p>
<ol>
<li><p>业务流程图</p>
<p>按表现形式</p>
<ol>
<li>任务流程图</li>
<li>泳道图</li>
</ol>
<p>按符号复杂程度</p>
<ol>
<li>基本流程图</li>
<li>完整流程图</li>
</ol>
</li>
<li><p>数据流程图</p>
</li>
<li><p>页面流程图</p>
</li>
</ol>
<h4 id="如何绘制业务流程图"><a href="#如何绘制业务流程图" class="headerlink" title="如何绘制业务流程图"></a>如何绘制业务流程图</h4><ol>
<li>调研</li>
<li>梳理和呈现</li>
<li>评审与确认</li>
<li>归档维护</li>
</ol>
<h5 id="在绘制流程图之前，下面的几个问题必须先清楚："><a href="#在绘制流程图之前，下面的几个问题必须先清楚：" class="headerlink" title="在绘制流程图之前，下面的几个问题必须先清楚："></a>在绘制流程图之前，下面的几个问题必须先清楚：</h5><ol>
<li>整个流程的起始点是什么？整个流程的终结点是什么？</li>
<li>在整个流程中，涉及的角色都是谁？</li>
<li>在整个流程中，都需要做什么事情？（可以是一个会议，也可以是一个任务）</li>
<li>这些会议和任务是可选还是必选的？</li>
<li>分别产出什么文档？</li>
</ol>
<h4 id="流程图的常用图示"><a href="#流程图的常用图示" class="headerlink" title="流程图的常用图示"></a>流程图的常用图示</h4><p><img src="http://wrr123.github.io/2021/02/18/%E8%BD%AF%E8%80%83-uml%E6%B5%81%E7%A8%8B%E5%9B%BE/001.png" alt></p>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-uml流程图2</title>
    <url>/2021/02/19/%E8%BD%AF%E8%80%83-uml%E6%B5%81%E7%A8%8B%E5%9B%BE2/</url>
    <content><![CDATA[<h4 id="业务流程图"><a href="#业务流程图" class="headerlink" title="业务流程图"></a>业务流程图</h4><h5 id="人员和流程图之间的关系"><a href="#人员和流程图之间的关系" class="headerlink" title="人员和流程图之间的关系"></a>人员和流程图之间的关系</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">人员</th>
<th style="text-align:center">流程图类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">产品、开发</td>
<td style="text-align:center">业务流程图</td>
</tr>
<tr>
<td style="text-align:center">交互设计师</td>
<td style="text-align:center">页面流程图</td>
</tr>
<tr>
<td style="text-align:center">系统分析师</td>
<td style="text-align:center">数据流程图</td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h5 id="uml-活动图"><a href="#uml-活动图" class="headerlink" title="uml 活动图"></a>uml 活动图</h5><p>uml中共定义了 13 种图，其中 <code>用例图、活动图和顺序图</code> 用的比较多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">图名</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类图</td>
<td style="text-align:center">描述类、类的特性以及类之间的关系</td>
</tr>
<tr>
<td style="text-align:center">对象图</td>
<td style="text-align:center">描述一个时间点上系统中各个对象的一个快照</td>
</tr>
<tr>
<td style="text-align:center">复合结构图</td>
<td style="text-align:center">描述类的运行时刻的分解</td>
</tr>
<tr>
<td style="text-align:center">构件图</td>
<td style="text-align:center">描述构件的结构和连接</td>
</tr>
<tr>
<td style="text-align:center">部署图</td>
<td style="text-align:center">描述在各个节点上的部署</td>
</tr>
<tr>
<td style="text-align:center">包图</td>
<td style="text-align:center">描述编译时的层次结构</td>
</tr>
<tr>
<td style="text-align:center">用例图</td>
<td style="text-align:center">描述用户和系统如何交互</td>
</tr>
<tr>
<td style="text-align:center">活动图</td>
<td style="text-align:center">描述过程行为和并行行为</td>
</tr>
<tr>
<td style="text-align:center">状态机图</td>
<td style="text-align:center">描述事件如何改变对象的生命周期</td>
</tr>
<tr>
<td style="text-align:center">顺序图</td>
<td style="text-align:center">描述对象之间的交互，重点在强调顺序</td>
</tr>
<tr>
<td style="text-align:center">通信图</td>
<td style="text-align:center">描述对象之间的交互，重点在于连接</td>
</tr>
<tr>
<td style="text-align:center">定时图</td>
<td style="text-align:center">描述对象之间的交互，重点在于定时</td>
</tr>
<tr>
<td style="text-align:center">交互概念图</td>
<td style="text-align:center">是一种顺序图与活动图的混合</td>
</tr>
</tbody>
</table>
</div>
<h5 id="类图中的六种关系"><a href="#类图中的六种关系" class="headerlink" title="类图中的六种关系"></a>类图中的六种关系</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">关系</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">泛化</td>
<td style="text-align:center">一种继承关系</td>
<td style="text-align:center">带三角箭头的实线，箭头指向父类</td>
</tr>
<tr>
<td style="text-align:center">实现</td>
<td style="text-align:center">一种类与接口的关系</td>
<td style="text-align:center">带三角箭头的虚线，箭头指向接口</td>
</tr>
<tr>
<td style="text-align:center">聚合</td>
<td style="text-align:center">整体和部分的关系，而且部分可以脱离整体单独存在</td>
<td style="text-align:center">带空心菱形的实线，菱形指向整体</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">整体和部分的关系，但是部分不可以脱离整体单独存在</td>
<td style="text-align:center">带实心菱形的实线，菱形指向整体</td>
</tr>
<tr>
<td style="text-align:center">关联</td>
<td style="text-align:center">一种拥有的关系，它使一个类知道另一个类的属性和方法</td>
<td style="text-align:center">带普通箭头的实线，指向被拥有者</td>
</tr>
<tr>
<td style="text-align:center">依赖</td>
<td style="text-align:center">一种使用的关系，即一个类的实现需要另一个类的协助</td>
<td style="text-align:center">带普通箭头的虚线，指向被使用者</td>
</tr>
</tbody>
</table>
</div>
<h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>Data Flow Diagram，它用于表示业务信息系统中的数据流，它表达了系统中的数据从输入到存储间所涉及到的程序。</p>
<p>数据流图可以分为逻辑形和物理形。逻辑数据流图描述了用以完成某业务功能所涉及的、业务层面的数据流动，物理数据流图则描述系统层面的数据流动。</p>
<h5 id="为什么需要绘画数据流图？"><a href="#为什么需要绘画数据流图？" class="headerlink" title="为什么需要绘画数据流图？"></a>为什么需要绘画数据流图？</h5><ol>
<li>用于表达系统的逻辑信息流</li>
<li>用于寻找系统需求</li>
<li>简单、易理解的图形符号</li>
<li>建立手动和自动系统需求</li>
</ol>
<h5 id="数据流图的符号"><a href="#数据流图的符号" class="headerlink" title="数据流图的符号"></a>数据流图的符号</h5><p>数据流图有四个基本符号。</p>
<ol>
<li><p>程序</p>
<p>符号：圆角矩形</p>
</li>
<li><p>数据流</p>
<p>符号：带输入/输出箭头的直线</p>
</li>
<li><p>数据存储</p>
<p>符号：直角矩形</p>
</li>
<li><p>外部实体</p>
<p>符号：矩形</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-排序算法1</title>
    <url>/2021/02/26/%E8%BD%AF%E8%80%83-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951/</url>
    <content><![CDATA[<h4 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h4><ul>
<li>冒泡排序</li>
<li>快速排序</li>
<li>插入排序</li>
<li>Shell排序</li>
<li>选择排序</li>
<li>堆排序</li>
<li>归并排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
<span id="more"></span>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止。</p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>它的基本思想是：<strong>选择一个基准数，</strong>通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序数列。</p>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>直接插入排序（Straight Insertion Sort）的基本思想是：把 n 个待排序的元素看成一个有序表和一个无序表。开始时有序表中只包含 1 个元素，无序表中含有 n - 1 个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表的适当位置，使之成为新的有序表，重复 n - 1 次即可完成排序过程。</p>
<p>注意：</p>
<p><span style="color:red;">它主要的就是比较和后移，但是要将待排序的元素多存一份，因为后移时，会占据该元素的位置。</span></p>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-排序算法2</title>
    <url>/2021/03/01/%E8%BD%AF%E8%80%83-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952/</url>
    <content><![CDATA[<h4 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h4><p>希尔排序实质上是一种分组插入方法。它的基本思想是：对于 n 个待排序的数列，取一个小于 n 的整数 gap（gap 被称为步长）将待排序元素分成若干组子序列，所有距离为 gap 的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。这一趟排序完成之后，每一组的元素都是有序的。然后减小 gap 的值，并重复执行上述的分组和排序。重复这样的操作，当 gap = 1 时，整个数列就是有序的。</p>
<span id="more"></span>
<h5 id="希尔排序的时间复杂度和稳定性"><a href="#希尔排序的时间复杂度和稳定性" class="headerlink" title="希尔排序的时间复杂度和稳定性"></a>希尔排序的时间复杂度和稳定性</h5><p>希尔排序的时间复杂度与增量（即，步长 gap）的选取有关。</p>
<p>例如，当增量为 1 时，希尔排序退化成了直接插入排序，此时的时间复杂度为 $O(N^2)$，而 <code>Hibbard</code> 增量的希尔排序的时间复杂度为 $O(N^3 / 2)$ 。</p>
<h5 id="希尔排序的稳定性"><a href="#希尔排序的稳定性" class="headerlink" title="希尔排序的稳定性"></a>希尔排序的稳定性</h5><p>希尔排序是不稳定的算法，它满足稳定算法的定义。对于不同的两个数，可能由于分在不同的组中而导致它们的顺序发生变化。</p>
<p><code>算法稳定性</code> — 假设在数列中存在 <code>a[i] = a[j]</code>，若在排序之前，<code>a[i]</code>在<code>a[j]</code>的前面；并且排序之后，<code>a[i]</code> 仍然在 <code>a[j]</code> 的前面。则这个排序算法是稳定的。</p>
<h5 id="java代码实现："><a href="#java代码实现：" class="headerlink" title="java代码实现："></a><code>java</code>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shell sort （希尔排序）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-03-01 14:49:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-01 14:51:12</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort1</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// gap 为步长，每次减为原来的一半</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 共 gap 个组，对每一组都执行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gap; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + gap; j &lt; n; j += gap) &#123;</span><br><span class="line">                    <span class="comment">// 如果 a[j] &lt; a[j - gap],则寻找a[j]位置，并将前面数据的位置都后移</span></span><br><span class="line">                    <span class="keyword">if</span> (a[j] &lt; a[j - gap]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                        <span class="keyword">int</span> k = j - gap;</span><br><span class="line">                        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; a[k] &gt; temp) &#123;</span><br><span class="line">                            a[k + gap] = a[k];</span><br><span class="line">                            k -= gap;</span><br><span class="line">                        &#125;</span><br><span class="line">                        a[k + gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>, <span class="number">17</span>, <span class="number">6</span>, <span class="number">25</span>, <span class="number">14</span>, <span class="number">21</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        shellSort1(nums, nums.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;nums = &quot;</span> + Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>它(Selection Sort)的基本思想是：首先在未排序的数列中找到最小(or 最大)的元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or 最大)的元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h5 id="选择排序实现过程"><a href="#选择排序实现过程" class="headerlink" title="选择排序实现过程"></a>选择排序实现过程</h5><p><img src="http://wrr123.github.io/2021/03/01/%E8%BD%AF%E8%80%83-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952/001.png" alt></p>
<h5 id="选择排序的时间复杂度和稳定性"><a href="#选择排序的时间复杂度和稳定性" class="headerlink" title="选择排序的时间复杂度和稳定性"></a>选择排序的时间复杂度和稳定性</h5><p>选择排序的时间复杂度是 $ O(N^2) $。</p>
<p>选择排序是稳定的算法，它满足稳定算法的定义。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/3/1 15:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 带排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-01 15:52:52</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分别定义 有序区的末尾位置、 无序区的起始位置、无序区中最小元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> i, j, min;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            min = i;</span><br><span class="line">            <span class="comment">// 找出&quot;a[i + 1] ... a[n]&quot;之间的最小元素，并赋值给 min</span></span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若 min != i,则交换 a[i] 和 a[min]。</span></span><br><span class="line">            <span class="comment">// 交换之后，保证了 a[0] ... a[i] 之间的元素是有序的。</span></span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                a[i] = a[min];</span><br><span class="line">                a[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">19</span>, <span class="number">28</span>, <span class="number">88</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">33</span>, <span class="number">999</span>, <span class="number">1231</span>&#125;;</span><br><span class="line">        selectionSort(a, a.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆分为 “最大堆” 和 “最小堆”。最大堆通常被用来进行“升序”排序，而最小堆通常被用来进行“降序”排序。</p>
<p>最大堆进行升序排序的基本思想：</p>
<ol>
<li><p>初始化堆</p>
<p>将数列 <code>a[1...n]</code> 构造成最大堆。</p>
</li>
<li><p>交换数据</p>
<p>将<code>a[1]</code> 和<code>a[n]</code>交换，使<code>a[n]</code> 是<code>a[1...n]</code>中的最大值；</p>
<p>然后将<code>a[1...n-1]</code>重新调整为最大堆。</p>
<p>接着，将 a[1] 和 a[n - 1]交换，使 a[n - 1]是a[1…n-1]中的最大值；</p>
<p>然后，将 a[1…n-2]重新调整为最大值。以此类推，直到整个数列都是有序的。</p>
</li>
</ol>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/1 16:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-01 16:44:14</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 数组的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 数组的最后一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapDown</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> c = start;</span><br><span class="line">        <span class="comment">// 左孩子的位置</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">2</span> * c + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前节点的大小</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[c];</span><br><span class="line">        <span class="keyword">for</span> (;l &lt;= end; c = l,l = <span class="number">2</span> * l + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// &quot;l&quot; 是左孩子，&quot;l + 1&quot;是右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; end &amp;&amp; a[l] &lt; a[l + <span class="number">1</span>]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt;= a[l]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                a[c] = a[l];</span><br><span class="line">                a[l] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-01 16:50:55</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSortAsc</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, temp;</span><br><span class="line">        <span class="comment">// 从 (n / 2 - 1) ---&gt; 0 逐次遍历，得到的数组实际上是一个（最大）二叉堆</span></span><br><span class="line">        <span class="keyword">for</span> (i = n / <span class="number">2</span> - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            maxHeapDown(a, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="comment">// 交换 a[0] 和 a[i]。交换后，a[i]是a[0...i]中最大的</span></span><br><span class="line">            temp = a[<span class="number">0</span>];</span><br><span class="line">            a[<span class="number">0</span>] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line">            <span class="comment">// 调整 a[0...n-1],使得a[0...n-1]仍然是一个最大堆</span></span><br><span class="line">            <span class="comment">// 即，保证a[i - 1]是a[0...i-1]中的最大值</span></span><br><span class="line">            maxHeapDown(a, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">11</span>, <span class="number">99</span>, <span class="number">23</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">67</span>&#125;;</span><br><span class="line">        heapSortAsc(a, a.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-排序算法3</title>
    <url>/2021/03/02/%E8%BD%AF%E8%80%83-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953/</url>
    <content><![CDATA[<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>它叫”Merge Sort”。</p>
<p>根据具体的实现，<strong>归并排序</strong> 包括“从上往下”和“从下往上”两种方式。</p>
<span id="more"></span>
<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><h6 id="从下往上的归并排序"><a href="#从下往上的归并排序" class="headerlink" title="从下往上的归并排序"></a>从下往上的归并排序</h6><p>将待排序的数列分成若干个长度为 1 的子数列，然后将这些数列两两合并；得到若干个长度为 2 的有序数列，再将这些数列两两合并；依次类推，直到合成一个数列为止。这样就得到了我们想要的结果。</p>
<h6 id="从上往下的归并排序"><a href="#从上往下的归并排序" class="headerlink" title="从上往下的归并排序"></a>从上往下的归并排序</h6><p>它与“从下往上”在排序上是 <strong>反方向的</strong>。它基本包括 3 步：</p>
<ul>
<li><code>分解</code> — 将当前区间一分为二，即求分裂点 <code>mid = (low + high) / 2</code>；</li>
<li><code>求解</code> — 递归地对两个子区间 <code>a[low...mid]</code> 和 <code>a[mid + 1...high]</code> 进行归并排序。递归地终结条件为子区间长度为 1。</li>
<li><code>合并</code> — 将已排序地两个子区间 <code>a[low...mid]</code> 和 <code>a[mid+1...high]</code>归并成一个有序的区间<code>a[low...high]</code>。</li>
</ul>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><h6 id="从下往上"><a href="#从下往上" class="headerlink" title="从下往上"></a>从下往上</h6><p><img src="http://wrr123.github.io/2021/03/02/%E8%BD%AF%E8%80%83-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953/002.png" alt></p>
<h6 id="从上往下"><a href="#从上往下" class="headerlink" title="从上往下"></a>从上往下</h6><p><img src="http://wrr123.github.io/2021/03/02/%E8%BD%AF%E8%80%83-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953/001.png" alt></p>
<h5 id="归并排序的的时间复杂度和稳定性"><a href="#归并排序的的时间复杂度和稳定性" class="headerlink" title="归并排序的的时间复杂度和稳定性"></a>归并排序的的时间复杂度和稳定性</h5><h6 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>归并排序的时间复杂度为 $O(N*\lg{N})$。</p>
<p>假设被排列的数列中有 N 个数。遍历一趟的时间复杂度是 <code>O(N)</code>，需要遍历多少次呢？</p>
<p>归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树可以得出它的时间复杂度为 $O(N*\lg{N})$。</p>
<h6 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h6><p>归并排序是稳定的算法，它满足稳定算法的定义。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/2 16:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-02 16:40:55</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 第一个有序区间的起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid 第一个有序区间的结束位置，也是第二个有序区间的起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 第二个有序区间的结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// temp是汇总 2 个有序区间的临时区域</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 分别为第1个有序区间的起始索引、第2个有序区间的起始索引、临时区域的起始索引</span></span><br><span class="line">        <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">                temp[k++] = a[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++]  = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= end) &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将排序后的数组，全部整合到数组a中</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            a[start + i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序（从上往下）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-02 16:43:25</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 数组的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 数组的结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortUp2Down</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        mergeSortUp2Down(a, start, mid);</span><br><span class="line">        mergeSortUp2Down(a, mid + <span class="number">1</span>, end);</span><br><span class="line">        merge(a, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">19</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">18</span>, <span class="number">3</span>, <span class="number">22</span>&#125;;</span><br><span class="line">        mergeSortUp2Down(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>假设待排序的数组<code>a</code>中共有 N 个整数，并且已知数组<code>a</code>中数据的范围<code>[0, max)</code>。在桶排序时，创建容量为 Max 的桶数组<code>r</code>,并将桶数组元素都初始化为<code>0</code>；将容量为Max的桶数组中的每一个单元都看作一个”桶”。</p>
<p>在排序时，逐个遍历数组<code>a</code>，将数组<code>a</code>的值，作为<code>桶数组r</code>的下标。当 <code>a</code> 中数据被读取时，就将桶的值加<code>1</code>。</p>
<h5 id="桶排序实现"><a href="#桶排序实现" class="headerlink" title="桶排序实现"></a>桶排序实现</h5><p><img src="http://wrr123.github.io/2021/03/02/%E8%BD%AF%E8%80%83-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953/003.png" alt> </p>
<h5 id="桶排序复杂度和稳定性"><a href="#桶排序复杂度和稳定性" class="headerlink" title="桶排序复杂度和稳定性"></a>桶排序复杂度和稳定性</h5><h6 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h6><ul>
<li>平均时间复杂度：$O(n+k)$</li>
<li>最佳时间复杂度：$O(n+k)$</li>
<li>最差时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(n*k)$</li>
</ul>
<p>桶排序最好情况下使用线性时间$O(n)$，桶排序的时间复杂度，取决于对各个桶之间数据进行排序的时间复杂度，因为其他部分的时间复杂度为$O(n)$。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。<strong>但相应的空间消耗就会增大。</strong></p>
<h5 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h5><p><u>稳定。</u></p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/2 17:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-02 17:08:22</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 数组a中最大值的范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || max &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0</span></span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="comment">// 1. 计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            buckets[a[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (buckets[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                a[j++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        bucketSort(a, <span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p>具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成之后，数列就变成一个有序数列。</p>
<h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><p><img src="http://wrr123.github.io/2021/03/02/%E8%BD%AF%E8%80%83-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953/004.png" alt></p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/2 17:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-02 17:25:53</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组中的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组按照&quot;某个位数&quot;进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-02 17:28:23</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exp 指数 exp = 1，按照个位数排序，exp = 10，按照十位数排序，exp = 100，按照百位数排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> exp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储被排序数据的临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="comment">// 定义一个桶数组</span></span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 将数据出现的次数存储在buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            buckets[(a[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改buckets[i].目的是让更改后的buckets[i]的值，是该数据在output[]中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数据存储到临时数组output[]中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            output[buckets[(a[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = a[i];</span><br><span class="line">            buckets[(a[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将排序好的数组赋值给a[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = output[i];</span><br><span class="line">        &#125;</span><br><span class="line">        output = <span class="keyword">null</span>;</span><br><span class="line">        buckets = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-02 17:39:01</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = getMax(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> exp = <span class="number">1</span>;max / exp &gt; <span class="number">0</span>;exp *= <span class="number">10</span>) &#123;</span><br><span class="line">            countSort(a, exp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        radixSort(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-数据结构1</title>
    <url>/2021/02/20/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/</url>
    <content><![CDATA[<h4 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>它是一种很常见的数据结构，它由相同类型的元素组成，并且是使用一块连续的内存来存储。</p>
<p>我们可以直接利用元素的索引（index）来计算出该元素对应的存储地址。</p>
<p>它的特点：<span style="color:red;">提供随机访问且容量有限。</span></p>
<span id="more"></span>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>它（LinkedList）虽然是一种线性表，但是不会按照线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p>
<p>它的插入和删除操作的复杂度为 <code>O(1)</code>，只需要知道目标的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候，复杂度为 <code>O(n)</code>。</p>
<p>它的分类：</p>
<ol>
<li>单链表</li>
<li>双向链表</li>
<li>循环链表</li>
<li>双向循环链表</li>
</ol>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>它（stack）只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照<span style="color:red;">后进先出（LIFO, Last In First Out）</span>的原理运作。在栈中，push和pop的操作都发生在栈顶。</p>
<p>栈常用一维数组或者链表来实现，用数组实现的叫顺序栈，用链表实现的叫链式栈。</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>它的分类：</p>
<ol>
<li>单队列</li>
<li>循环队列</li>
</ol>
<h6 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h6><p>它是最常见的队列，每次添加元素都是添加到队尾。</p>
<p>它也可以分为顺序队列（数组实现）和链式队列（链表实现）。</p>
<p><strong>顺序队列存在“假溢出”的问题，也就是命名有位置却不能添加的情况。</strong></p>
<h6 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h6><p>循环队列可以解决顺序队列的假溢出问题。</p>
<p>解决办法就是:从头开始，这样就会形成头尾相接的循环。</p>
<p><img src="http://wrr123.github.io/2021/02/20/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/001.png" alt></p>
<h4 id="非线性数据结构"><a href="#非线性数据结构" class="headerlink" title="非线性数据结构"></a>非线性数据结构</h4><h5 id="逻辑结构：树"><a href="#逻辑结构：树" class="headerlink" title="逻辑结构：树"></a>逻辑结构：树</h5><h6 id="基本的overview"><a href="#基本的overview" class="headerlink" title="基本的overview"></a>基本的overview</h6><p><img src="http://wrr123.github.io/2021/02/20/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/002.png" alt></p>
<h6 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h6><ul>
<li>二叉搜索树（BST）</li>
<li>平衡二叉树（AVL）</li>
<li>红黑树（R-B Tree）</li>
<li>哈夫曼树</li>
<li>前缀树（Tire）</li>
</ul>
<h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>树是一种数据结构，它是n（n&gt;=0）个节点的有限集。n=0时，称为空树；n&gt;0时，有限集的元素构成一个具有层次感的数据结构。</p>
<p><span style="color:red;">区别于线性表一对一的元素关系，树中的节点是一对多的关系。</span></p>
<h6 id="树具有如下的特点："><a href="#树具有如下的特点：" class="headerlink" title="树具有如下的特点："></a>树具有如下的特点：</h6><ol>
<li>n &gt; 0 时，根节点是唯一的，不可能存在多个根节点。</li>
<li>每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。</li>
</ol>
<h6 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h6><ul>
<li>子树：除了根节点外，每个子节点都可以分为多个不相交的子树。</li>
<li>孩子与双亲：若一个节点有子树，那么该节点称为子树根的“双亲”，子树的根是该节点的“孩子”。</li>
<li>兄弟：具有相同双亲的节点互为兄弟。</li>
<li>叶子：没有子树，也即是度为 0 的节点。</li>
<li>分支节点：除了叶子节点之外的节点，也即是度不为 0 的节点。</li>
<li>内部节点：除了根节点之外的分支节点。</li>
<li>层次：根节点为第一层，其余节点的层次等于其“双亲”节点的层次加一。</li>
<li>树的高度：也成为树的深度，树种节点的最大层次。</li>
<li>有序树：树中节点各子树之间的次序是重要的，不可以随意交换位置。</li>
<li>无序树：树中节点各子树之间的次序是不重要的，可以随意交换位置。</li>
<li>森林：零或多课互不相交的树的集合。</li>
</ul>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-数据结构2</title>
    <url>/2021/02/22/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/</url>
    <content><![CDATA[<h4 id="数据结构基础知识系统性梳理"><a href="#数据结构基础知识系统性梳理" class="headerlink" title="数据结构基础知识系统性梳理"></a>数据结构基础知识系统性梳理</h4><p><img src="http://wrr123.github.io/2021/02/22/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/001.png" alt></p>
<span id="more"></span>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="完-全二叉树与-完美-满二叉树之间的区别"><a href="#完-全二叉树与-完美-满二叉树之间的区别" class="headerlink" title="(完)全二叉树与(完美)满二叉树之间的区别"></a>(完)全二叉树与(完美)满二叉树之间的区别</h5><p>什么叫满&lt;完美&gt;二叉树？</p>
<ul>
<li>二叉树所有非叶子节点的度都是 2，且叶子节点都在同一层次；</li>
</ul>
<p>什么叫全二叉树？</p>
<ul>
<li>从根节点到倒数第二层满足完美二叉树，最后一层可以不完全填充，但其叶子节点都必须靠左对齐。</li>
</ul>
<p><span style="color:red;">可以说，满二叉树是一种特殊的全二叉树。</span></p>
<h5 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h5><p>它叫 <code>Binary Search Tree</code>。</p>
<h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>在二叉查找树中：</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ul>
<h6 id="BST的相关题目"><a href="#BST的相关题目" class="headerlink" title="BST的相关题目"></a>BST的相关题目</h6><ol>
<li>修剪二叉查找树（Trim a Binary Search Tree）</li>
<li>寻找二叉查找树的第 <code>K</code> 个元素（<code>Kth Smallest Element in a BST</code>）</li>
<li>把二叉查找树每个节点的值都加上比它大的节点的值（<code>Convert BST to Greater Tree</code>）</li>
<li>二叉查找树的最近公共祖先（<code>Lowest Common ancestor of a Binary Search Tree</code>）</li>
<li>从有序数组中构造二叉查找树（<code>Convert Sorted Array to Binary Search Tree</code>）</li>
<li>根据有序链表构造平衡的二叉查找树（<code>Convert Sorted List to Binary Search Tree</code>）</li>
<li>在二叉查找树中寻找两个节点，使它们的和为一个给定值（<code>Two Sum IV - Input is a BST</code>）</li>
<li>在二叉查找树中查找两个节点之差的最小绝对值（<code>Minimum Absolute Difference in BST</code>）</li>
<li>寻找二叉查找树中出现次数最多的值（<code>Find Mode in BST</code>）</li>
</ol>
<h5 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h5><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><p>它叫 <code>Balanced Binary Tree</code>。</p>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过 <code>1</code>,并且左右两个子树都是一棵平衡二叉树。</p>
<p>它的特点是：AVL树中任何节点的两个子树的高度最大差别为 <code>1</code>。</p>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-数据结构3</title>
    <url>/2021/02/23/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/</url>
    <content><![CDATA[<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>它（<code>Red Black Tree</code>）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组，是平衡二叉树和<code>AVL</code>树的折中。</p>
<h6 id="红黑树与AVL树的比较："><a href="#红黑树与AVL树的比较：" class="headerlink" title="红黑树与AVL树的比较："></a>红黑树与AVL树的比较：</h6><ol>
<li>AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异；</li>
<li>红黑树的插入删除比AVL树更便于控制操作；</li>
<li>红黑树的整体性能略优于AVL树（红黑树旋转情况少于AVL树）</li>
</ol>
<span id="more"></span>
<h6 id="具体的性质："><a href="#具体的性质：" class="headerlink" title="具体的性质："></a>具体的性质：</h6><ul>
<li>每个节点的颜色不是黑色，就是红色；</li>
<li>根节点是黑色的；</li>
<li>如果一个节点是红色，那么它的两个子节点就是黑色的（没有连续的红节点）；</li>
<li>对于每个节点，从该节点到其后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li>
</ul>
<h5 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h5><p>它又称最优二叉树，是一种带权路径长度最短的二叉树。</p>
<h6 id="几个名词的解释："><a href="#几个名词的解释：" class="headerlink" title="几个名词的解释："></a>几个名词的解释：</h6><ul>
<li><code>路径与路径长度</code>：从树中一个节点到另一个节点之间的分支构成了两个节点之间的路径，路径上的分支数目称作路径长度。若规定根节点位于第一层，则根节点到第<code>H</code>层的节点的路径长度为<code>H - 1</code>。</li>
<li><code>节点的权</code> ：将树中的节点赋予一个某种含义的数值作为该节点的权值，该值称为节点的权；</li>
<li><code>带权路径长度</code>：从根节点到某个节点之间的路径长度与该节点的权的乘积。</li>
<li><code>树的带权路径长度</code>：树的带权路径长度为所有叶子节点的带权路径长度之和，称为 <code>WPL</code>。</li>
</ul>
<h6 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h6><p>假设有 <code>n</code> 个权值，则构造出的哈夫曼树有 <code>n</code> 个叶子节点。<code>n</code> 个权值分别为 <code>w1, w2, w3, ..., wn</code>，哈夫曼树的构造规则如下：</p>
<ul>
<li>将<code>w1, w2, ..., wn</code> 看成是有 <code>n</code> 棵树的森林（每棵树仅有一个节点）</li>
<li>在森林中选出根节点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根节点权值为其左、右子树根节点权值之和；</li>
<li>从森林中删除选取的两棵树，并将新树加入森林；</li>
<li>重复上面两步，直到森林只剩一棵树为止，该树即为所求得的哈夫曼树。</li>
</ul>
<h6 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h6><p>从根节点到每一个叶子节点的路径上，左分支记为 <code>0</code>，右分支记为 <code>1</code>，将这些 <code>0</code> 和 <code>1</code> 连起来即为叶子节点的哈夫曼编码。</p>
<h5 id="前缀树（Trie-Tree）"><a href="#前缀树（Trie-Tree）" class="headerlink" title="前缀树（Trie Tree）"></a>前缀树（Trie Tree）</h5><p>它又称为字典树、单词查找树或键树，是一种树形结构，是一种哈希表的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p>
<p>它的优点是：利用字符串的公共前缀来减少查找时间，最大限度地减少无谓地字符串比较，查询效率比哈希树高。</p>
<h6 id="基本性质："><a href="#基本性质：" class="headerlink" title="基本性质："></a>基本性质：</h6><ul>
<li>根节点不包含字符，除根节点之外的每一个子节点都包含一个字符；</li>
<li>从根节点到某一个节点，路径上所经过的字符连接起来，为该节点对应的字符串；</li>
<li>每个节点的所有子节点包含的字符互不相同；</li>
<li>从第一个字符开始有连续重复的字符只占用一个节点，比如单词<code>to, ten</code>中重复的字符 <code>t</code> 只占用一个节点。</li>
</ul>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>图（graph）是由顶点和连接顶点的边构成的离散结构。在计算机科学中，图是最灵活的数据结构之一，很多问题都可以通过图模型进行建模求解。例如：</p>
<ul>
<li>生态环境中不同物种的互相竞争</li>
<li>人与人之间的社交与关系网络</li>
<li>化学上用图区分结构不同但分子式相同的同分异构体</li>
<li>分析计算机网络的拓扑结构确定两台计算机是否可以通信</li>
<li>找到两个城市之间的最短路径等等。</li>
</ul>
<h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为:<code>G(V, E)</code>，其中 <code>G</code> 表示一个图，<code>V</code>是图<code>G</code>中顶点的集合，<code>E</code>是图<code>G</code>中边的集合。</p>
<p>与线性表、树的差异：</p>
<ul>
<li>线性表中我们把数据元素叫做元素，树中将数据元素叫做节(结)点，在图中数据元素，我们称之为顶点（<code>Vertex</code>）；</li>
<li>线性表可以没有元素，称为空表；树中可以没有节点，称为空树；<span style="color:red;">但是，在图中不允许没有顶点（有穷非空性）</span>；</li>
<li>线性表中的各元素是线性关系，树中的各节点是层次关系，而图中各顶点的关系是用边来表示（边集可以为空）</li>
</ul>
<h6 id="相关的术语"><a href="#相关的术语" class="headerlink" title="相关的术语"></a>相关的术语</h6><ul>
<li><code>顶点的度</code>：顶点<code>Vi</code>的度（<code>Degree</code>）是指在图中与<code>Vi</code>相关联的边的条数。对于有向图来说，有入度（In-Degree）和出度(Out-Degree)之分，有向图顶点的度等于该顶点的入度和出度之和。</li>
<li><code>邻接</code>：若无向图中的两个顶点<code>V1</code>和<code>V2</code>存在一条边<code>(V1, V2)</code>，则称顶点 <code>V1</code> 和 <code>V2</code> 邻接(Adjacent)。若有向图中存在一条边<code>&lt;V3, V2&gt;</code>，则称顶点 <code>V3</code>与顶点<code>V2</code>邻接，且是<code>V3</code>邻接到<code>V2</code>或<code>V2</code>邻接至<code>V3</code>。</li>
<li><code>路径</code>：在无向图中，若从顶点<code>Vi</code>出发有一组边可到达顶点 <code>Vj</code>，则称顶点<code>Vi</code>到顶点<code>Vj</code>的顶点序列为从顶点<code>Vi</code>到顶点<code>Vj</code>的路径（Path）。</li>
<li><code>连通</code>：若从 <code>Vi</code>到<code>Vj</code>有路径可通，则称顶点 <code>Vi</code>和顶点<code>Vj</code>是连通(Connected)的。</li>
<li><code>权(Weight)</code>：有些图的边会弧具有与它相关的数字，这种与图的边或弧相关的数叫做权(weight)。</li>
</ul>
<h6 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h6><ul>
<li><p>无向图</p>
<p>如果图中任意两个顶点之间的边都是无向边（简而言之就是没有方向的边），则称该图为无向图（Undirected graphs）.</p>
<p>无向图中的边使用小括号<code>()</code>表示,比如 <code>(V1, V2)</code>。</p>
</li>
<li><p>有向图</p>
<p>如果图中任意两个顶点之间的边是有向边（简而言之就是有方向的边），则称该图为有向图（Directed graphs）。</p>
<p>有向图中的边使用尖括号<code>&lt;&gt;</code>表示，比如<code>&lt;V1, V2&gt;</code>。</p>
</li>
<li><p>完全图</p>
<p><code>无向完全边</code>：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图（含有<code>n</code>各个顶点的无向完全图有<code>(n x (n - 1)) / 2</code>）条边）。</p>
<p><code>有向完全图</code>：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。（含有 <code>n</code> 个顶点的有向完全图有<code>n x (n - 1)</code> 条边）。</p>
</li>
</ul>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><h6 id="深度优先搜索（Depth-First-Search）"><a href="#深度优先搜索（Depth-First-Search）" class="headerlink" title="深度优先搜索（Depth First Search）"></a>深度优先搜索（Depth First Search）</h6><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点<code>v</code>出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和<code>v</code>有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p>
<p>显然，深度优先搜索是一个递归的过程。</p>
<h6 id="广度优先搜索（Breadth-First-Search）"><a href="#广度优先搜索（Breadth-First-Search）" class="headerlink" title="广度优先搜索（Breadth First Search）"></a>广度优先搜索（Breadth First Search）</h6><p>又称为”宽度优先搜索“或”横向优先搜索“。</p>
<p>它的思想是：从图中某顶点<code>v</code>出发，在访问了<code>v</code>之后依次访问<code>v</code>的各个未曾访问过的邻接点，然后从这些邻接点出发依次访问它们的邻接点，并使得”先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直到图中所有已被访问的顶点的邻接点都被访问到“。如果此时图中尚有顶点未被访问，则需要另选一个未被访问的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-数据结构4</title>
    <url>/2021/02/24/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/</url>
    <content><![CDATA[<h4 id="图-最小生成树"><a href="#图-最小生成树" class="headerlink" title="图 - 最小生成树"></a>图 - 最小生成树</h4><h5 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h5><ul>
<li><p><code>连通图</code>：在无向图中，若任意两个顶点<code>Vi</code>与<code>Vj</code>都有路径相通，则称该无向图为连通图。</p>
</li>
<li><p><code>强连通图</code>：在有向图中，若任意两个顶点<code>Vi</code>与<code>Vj</code>都有路径相通，则称该 <strong>有向图</strong> 为 <strong>强连通图</strong>。</p>
</li>
<li><p><code>连通网</code>：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为 <strong>权</strong>；权代表着连接两个顶点的代价，这种 <strong>连通图</strong> 被称为 <strong>连通网</strong>。</p>
</li>
<li><p><code>生成树</code>：一个连通网的生成树是指一个子连通网，它包含图中全部 n 个顶点，但只有足以构成一棵树的 <code>n - 1</code> 条边。</p>
<p>一棵有 n 个顶点的生成树有且仅有 <code>n - 1</code> 条边，如果生成树中再添加一条边，则必定成环。</p>
</li>
<li><p><code>最小生成树</code>：在连通网的所有生成树中，所有边的 <strong>代价和最小</strong> 的生成树，称为最小生成树。</p>
</li>
</ul>
<span id="more"></span>
<h5 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h5><h6 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a><code>Kruskal</code>算法</h6><p>它可以称为 <strong>“加边法”</strong>，初始最小生成树边数为 <strong>0</strong>， 每迭代一次就选择一条满足条件的最小代价边，加入在最小生成树的边集合里。</p>
<h6 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a><code>Prim</code>算法</h6><p>它可以称为 <strong>“加点法”</strong>，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一顶点 <strong>s</strong> 开始，逐渐长大覆盖整个连通网的所有顶点。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>因为 <strong>Kruskal</strong> 涉及大量对边的操作，所以它适用于稀疏图；<strong>普通的Prim算法</strong>适用于稠密图，但对有堆优化的 <strong>Prim算法</strong> 更适用于稀疏图，因为其时间复杂度是由边的数量决定的。</p>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-数据结构5</title>
    <url>/2021/02/25/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/</url>
    <content><![CDATA[<h4 id="图-最短路径"><a href="#图-最短路径" class="headerlink" title="图 - 最短路径"></a>图 - 最短路径</h4><p>最短路径有着广泛的应用，比如 <strong>地图两点间的距离计算，公交查询系统，路由选择等</strong>。</p>
<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（<strong>由结点和路径组成</strong>）中两结点之间的最短路径。最短路径不一定是经过边最少的路径，但在这些最短路径中，长度最短的那一条路径上只有一条边，且它的权值在从源点出发的所有边的权值最小。</p>
<span id="more"></span>
<h5 id="路径长度最短的最短路径的特点："><a href="#路径长度最短的最短路径的特点：" class="headerlink" title="路径长度最短的最短路径的特点："></a>路径长度最短的最短路径的特点：</h5><ul>
<li>在这条路径上，必定只含一条弧，并且这条弧的权值最小。</li>
</ul>
<h5 id="下一条路径长度次短的最短路径的特点："><a href="#下一条路径长度次短的最短路径的特点：" class="headerlink" title="下一条路径长度次短的最短路径的特点："></a>下一条路径长度次短的最短路径的特点：</h5><p>它只可能有两种情况：</p>
<ol>
<li>直接从源点到该点（只含一条弧）</li>
<li>从源点经过顶点 <code>V1</code>，再到达该顶点（由两条弧组成）</li>
</ol>
<h5 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h5><h6 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h6><ol>
<li><p>定义概览</p>
<p>Dijkstra（缔结斯特拉）算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，它有很多代表课程，如 <strong>数据结构、图论、运筹学等等</strong>，注意 <strong>该算法要求图中不存在负权边。</strong></p>
<p>问题描述：在无向图 <code>G = (V, E)</code>中，假设每条边 <code>E[i]</code> 的长度为 <code>W[i]</code>，找到由顶点 <code>V0</code> 到其余各顶点的最短路径（单源最短路径）。</p>
</li>
<li><p>算法描述</p>
<ol>
<li><p>算法思想</p>
<p>设 <code>G = (V, E)</code> 是一个带权有向图，把图中顶点集合 <code>V</code> 分成两组，第一组为已求出最短路径的顶点集合（用 S 表示，初始 S 中只有一个源点，以后每求得一条最短路径，就将加入到集合 S 中，直至全部顶点都加入到 S 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。在加入的过程中，总保持源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S 中的顶点的距离就是从 V 到此顶点的最短路径长度，U 中的顶点的距离，是从V到此顶点只包含 S 中的顶点为中间顶点的当前最短路径长度。</p>
</li>
<li><p>算法步骤</p>
<ol>
<li>初始时，S 只包含源点，即 S = {v}, v 的距离为 0。U 包含除 v 外的其余顶点，即：U = {其余顶点}，若v 与 U 中顶点 u 有边，则 <code>&lt;u, v&gt;</code> 正常有权值，若 u 不是 v 的出边邻接点，则 <code>&lt;u, v&gt;</code> 权值为 <code>∞</code>。</li>
<li>从 U 中选取一个距离 v 最小的顶点 k， 把 k， 加入 S 中（该选定的距离就是 v 到 k 的最短路径长度）。</li>
<li>以 k 为新考虑的中间点，修改 U 中各顶点的距离；若从源点 v 到顶点 u 的距离 （经过顶点 k）比原来距离（不经过顶点 k）<strong>短</strong>，则修改顶点 u 的距离值，修改后的距离值的顶点 k 的距离加上边上的权。</li>
<li>重复步骤 2 和 3 直至所有顶点都包含在 S 中。</li>
</ol>
</li>
</ol>
<p><img src="http://wrr123.github.io/2021/02/25/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/001.gif" alt></p>
</li>
</ol>
<h6 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h6><p>…</p>
<h4 id="图-拓扑排序"><a href="#图-拓扑排序" class="headerlink" title="图 - 拓扑排序"></a>图 - 拓扑排序</h4><p>拓扑排序主要用来解决有向图中的依赖解析（dependency resolution）问题。</p>
<h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>对于任何有向图而言，其拓扑排序为其所有顶点的一个线性排序（对于同一个有向图而言可能存在多个这样的顶点排序）。该排序满足这样的条件 — 对于图中的任意两个顶点 u 和 v，若存在一条有向边从 u 指向 v，则在 <strong>拓扑排序中 u 一定出现在 v 前面。</strong></p>
<h5 id="拓扑排序的前提"><a href="#拓扑排序的前提" class="headerlink" title="拓扑排序的前提"></a>拓扑排序的前提</h5><p>当且仅当一个有向图为 <strong>有向无环图（directed acyclic graph, 或称 DAG）</strong>时，才能得到对应于该图的拓扑排序。</p>
<p>这里有两点需要注意：</p>
<ul>
<li>对于有环图，必然会造成循环依赖（circular dependency），不符号拓扑排序定义；</li>
<li>对于每一个有向无环图都至少存在一种拓扑排序；</li>
</ul>
<h4 id="图-AOE-amp-关键路径"><a href="#图-AOE-amp-关键路径" class="headerlink" title="图 - AOE &amp; 关键路径"></a>图 - AOE &amp; 关键路径</h4><blockquote>
<p>关键路径在项目管理计算工期等方面有广泛的应用，提升工期就是所见缩减所有关键路径上的工期，并且在实现时，需要应用到之前拓扑排序的算法（前提：有向无环图，有依赖关系）。</p>
</blockquote>
<h5 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h5><ul>
<li><code>AOV网络（Activity On Vertex Network）</code>：有向图，用顶点表示活动，用弧表示活动的先后顺序。</li>
<li><code>AOE网络（Activity On Edge）</code>： 有向图，用顶点表示事件，用弧表示活动，用权值表示活动消耗时间（带权的有向无环图）。</li>
<li><code>活动</code>：业务逻辑中的行为，用边表示。</li>
<li><code>事件</code>：活动的结果或触发条件。</li>
<li><code>关键路径</code>：具有最大路径长度（权重）的路径，可能不止一条。</li>
<li><code>活动的两个属性</code>：<code>e(i)</code> 最早开始时间，<code>l(i)</code>最晚开始时间。</li>
<li><code>事件的两个属性</code>：<code>ve(i)</code> 最早开始时间，<code>vl(i)</code>最晚开始时间。</li>
</ul>
<h6 id="AOE-和-AOV-的对比："><a href="#AOE-和-AOV-的对比：" class="headerlink" title="AOE 和 AOV 的对比："></a>AOE 和 AOV 的对比：</h6><ul>
<li>AOV 网是顶点表示活动的网，它只描述活动之间的制约更新；</li>
<li>AOE 网是用边表示活动的网，边上的权值表示活动持续的时间；</li>
</ul>
<h5 id="关键路径的实现"><a href="#关键路径的实现" class="headerlink" title="关键路径的实现"></a>关键路径的实现</h5><h6 id="4-个关键概念"><a href="#4-个关键概念" class="headerlink" title="4 个关键概念"></a>4 个关键概念</h6><ol>
<li><p>事件最早发生时间</p>
<p>事件最早发生时间 etv(earliest time of vertex)，即顶点 Vk 的最早发生时间。</p>
</li>
<li><p>事件最晚发生时间</p>
<p>事件最晚发生时间 <code>ltv(lastest time of vertex)</code>，即顶点 <code>Vk</code>的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的事件，超出此事件将会延误整个工期。</p>
</li>
<li><p>活动的最早开工时间</p>
<p>活动的最早开工时间 <code>ete（earliest time of edge）</code>,即弧  <code>ak</code> 的最早发生时间。</p>
</li>
<li><p>活动的最晚开工时间</p>
<p>活动的最晚开工时间 <code>lte(lastest time of edge)</code>，即弧的最晚发生时间，也就是不推迟工期的最晚开工时间。</p>
</li>
</ol>
<h6 id="4-个时间的关系"><a href="#4-个时间的关系" class="headerlink" title="4 个时间的关系"></a>4 个时间的关系</h6><p>我们可以 <strong>由事件的最早发生时间和事件的最晚发生时间求出活动的最早和最晚开工时间。</strong></p>
<p>由 <code>1, 2</code> 可以求得  <code>3, 4</code>,然后再根据 <code>ete[k]</code> 是否与 <code>lte[k]</code> 相等来判断 <code>ak</code> 是否是关键活动。</p>
<h6 id="两个原则："><a href="#两个原则：" class="headerlink" title="两个原则："></a>两个原则：</h6><ul>
<li>只有某顶点所代表的事件发生后，从该顶点出发的各活动才能开始；</li>
<li>只有进入某顶点的各活动都结束，该顶点所代表的事件才发生。</li>
</ul>
<h6 id="顶点-事件最早发生时间"><a href="#顶点-事件最早发生时间" class="headerlink" title="(顶点)事件最早发生时间"></a>(顶点)事件最早发生时间</h6><p>从前往后，前驱结点到当前结点所需时间，取最大值。</p>
<h6 id="（顶点）事件最迟发生时间"><a href="#（顶点）事件最迟发生时间" class="headerlink" title="（顶点）事件最迟发生时间"></a>（顶点）事件最迟发生时间</h6><p>从后往前，后继结点的最迟发生时间 <code>(减去)-</code>  边权值，取最小值。</p>
<h6 id="（边）活动最早发生时间"><a href="#（边）活动最早发生时间" class="headerlink" title="（边）活动最早发生时间"></a>（边）活动最早发生时间</h6><p>活动最早发生时间 = 事件的最早发生事件</p>
<h6 id="（边）活动最迟发生时间"><a href="#（边）活动最迟发生时间" class="headerlink" title="（边）活动最迟发生时间"></a>（边）活动最迟发生时间</h6><p>活动最迟发生时间 = 下一事件最迟发生时间 - 活动的持续时间</p>
<h6 id="活动的剩余时间"><a href="#活动的剩余时间" class="headerlink" title="活动的剩余时间"></a>活动的剩余时间</h6><p>活动的最迟发生时间 <code>减去(-)</code> 活动的最早发生时间</p>
<h6 id="关键活动"><a href="#关键活动" class="headerlink" title="关键活动"></a>关键活动</h6><p>活动的剩余时间为 <code>0</code>的活动</p>
<h6 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h6><p>由关键路径所连接的路径即为关键路径。</p>
<p><strong>关键路径可能不止一条。</strong></p>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><h6 id="推演图"><a href="#推演图" class="headerlink" title="推演图"></a>推演图</h6><p><img src="http://wrr123.github.io/2021/02/25/%E8%BD%AF%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/002.png" alt></p>
<h6 id="etv-从左向右-从前往后-推导"><a href="#etv-从左向右-从前往后-推导" class="headerlink" title="etv 从左向右(从前往后)推导"></a><code>etv</code> 从左向右(从前往后)推导</h6><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">顶点（事件）</th>
<th style="text-align:center"><code>etv</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">v0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">v1</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">v2</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">v3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">v4</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">v5</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">v6</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">v7</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">v8</td>
<td style="text-align:center">16</td>
</tr>
</tbody>
</table>
</div>
<h6 id="ltv-从右向左（从后往前）推导"><a href="#ltv-从右向左（从后往前）推导" class="headerlink" title="ltv 从右向左（从后往前）推导"></a><code>ltv</code> 从右向左（从后往前）推导</h6><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">顶点（事件）</th>
<th style="text-align:center"><code>ltv</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">v0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">v1</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">v2</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">v3</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">v4</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">v5</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">v6</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">v7</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">v8</td>
<td style="text-align:center">16</td>
</tr>
</tbody>
</table>
</div>
<h6 id="活动的最早发生时间ete和最迟发生时间lte"><a href="#活动的最早发生时间ete和最迟发生时间lte" class="headerlink" title="活动的最早发生时间ete和最迟发生时间lte"></a>活动的最早发生时间<code>ete</code>和最迟发生时间<code>lte</code></h6><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">弧（边）（活动）</th>
<th style="text-align:center"><code>ete</code></th>
<th style="text-align:center"><code>lte</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">a1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">a2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">a3</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">a4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">a5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">a6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">a7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">a8</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">a9</td>
<td style="text-align:center">14</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">a10</td>
<td style="text-align:center">12</td>
<td style="text-align:center">12</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-算法思想1</title>
    <url>/2021/03/03/%E8%BD%AF%E8%80%83-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B31/</url>
    <content><![CDATA[<h4 id="算法思想的概览"><a href="#算法思想的概览" class="headerlink" title="算法思想的概览"></a>算法思想的概览</h4><p><img src="http://wrr123.github.io/2021/03/03/%E8%BD%AF%E8%80%83-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B31/001.png" alt></p>
<span id="more"></span>
<h4 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的问题…直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<h5 id="基本思想和策略"><a href="#基本思想和策略" class="headerlink" title="基本思想和策略"></a>基本思想和策略</h5><p>分治法的设计思想是：<span style="color:red;">将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</span></p>
<p>分治策略是：<span style="color:red;">对于一个规模为<code>n</code>的问题，将其分解成<code>k</code>个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归的解决这些子问题，然后将各子问题的解合并得到原问题的解。</span></p>
<h5 id="分治法的基本步骤"><a href="#分治法的基本步骤" class="headerlink" title="分治法的基本步骤"></a>分治法的基本步骤</h5><ul>
<li>分解：将原问题分解为若干个规模较小，互相独立，与原问题形式相同的子问题；</li>
<li>解决：若子问题规模较小而容易被解决则直接解决，否则递归的解各个子问题；</li>
<li>合并：将各个子问题的解合并为原问题的解。</li>
</ul>
<h5 id="代码实现demo"><a href="#代码实现demo" class="headerlink" title="代码实现demo"></a>代码实现demo</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.thought;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/3 10:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivideConquer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ways = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l: left) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> r: right) &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                                ways.add(l - r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                                ways.add(l + r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                                ways.add(l * r);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ways.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            ways.add(Integer.valueOf(input));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ways;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String input = <span class="string">&quot;2-11+99*12&quot;</span>;</span><br><span class="line">        List&lt;Integer&gt; ans = diffWaysToCompute(input);</span><br><span class="line">        System.out.println(<span class="string">&quot;ans = &quot;</span> + ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>它通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应一个值，我们希望找到具有最优值的解。</p>
<p>动态规划算法和分治法类似，其基本思想也是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<h5 id="分治和动态规划的区别"><a href="#分治和动态规划的区别" class="headerlink" title="分治和动态规划的区别"></a>分治和动态规划的区别</h5><ul>
<li>分治法往往用到递归计算，自上而下计算；而动态规划则直接自底向上计算；</li>
<li>分治法的小问题在递归的过程中可能会被反复计算，动态规划中的小问题计算后被存储，下次碰到时直接调用；</li>
<li>分治法的小问题的解只使用一次，动态规划的小问题的解可以作为上一级最优解的基础。</li>
</ul>
<h5 id="代码实现demo-1"><a href="#代码实现demo-1" class="headerlink" title="代码实现demo"></a>代码实现demo</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.thought;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划思想</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/3 14:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgramming</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 爬楼梯</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-03 14:19:56</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 楼梯的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 多少种上楼梯的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分治的思想</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairsTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划的思想</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">2</span>, pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">44</span>;</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        <span class="keyword">int</span> climbAns = climbStairs(n);</span><br><span class="line">        watch.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;climbStairs耗时：&quot;</span> + watch.getNanoTime());</span><br><span class="line">        watch.reset();</span><br><span class="line">        watch.start();</span><br><span class="line">        <span class="keyword">int</span> climbTwoAns = climbStairs(n);</span><br><span class="line">        watch.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;climbStairsTwo耗时：&quot;</span> + watch.getNanoTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;climbAns = &quot;</span> + climbAns);</span><br><span class="line">        System.out.println(<span class="string">&quot;climbTwoAns = &quot;</span> + climbTwoAns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="其他的一些动态规划的题目"><a href="#其他的一些动态规划的题目" class="headerlink" title="其他的一些动态规划的题目"></a>其他的一些动态规划的题目</h5><ul>
<li>强盗抢劫</li>
<li>强盗在环形街抢劫</li>
<li>信件错排</li>
<li>母牛生产</li>
<li>矩阵路径<ul>
<li>矩阵的最小路径和</li>
<li>矩阵的总路径数</li>
</ul>
</li>
<li>数组区间<ul>
<li>数组区间和</li>
<li>子数组最大的和</li>
<li>数组中等差递增子区间的个数</li>
</ul>
</li>
<li>分割整数<ul>
<li>分割整数的最大乘积</li>
<li>按平方数来分割整数</li>
<li>分割整数构成字母字符串</li>
</ul>
</li>
<li>最长递增子序列<ul>
<li>最长递增子序列</li>
<li>一组整数能够构成的最长链</li>
<li>最长摆动子序列</li>
</ul>
</li>
<li>最长公共子序列</li>
<li>背包<ul>
<li>划分数组为相等的两部分</li>
<li>改变一组数的正负号使得它们的和为一给定数</li>
<li>字符串按单词列表分割</li>
<li>字符构成最多的字符串</li>
<li>找零钱的最小硬币数</li>
<li>组合总和</li>
</ul>
</li>
<li>股票交易<ul>
<li>需要冷却期的股票交易</li>
<li>需要交易费用的股票交易</li>
<li>买入和售出股票最大的收益</li>
<li>只能进行两次的股票交易</li>
<li>只能进行K次的股票交易</li>
</ul>
</li>
<li>字符串编辑<ul>
<li>删除两个字符串的字符使它们相等</li>
<li>编辑距离</li>
<li>复制粘贴字符</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考-算法思想2</title>
    <url>/2021/03/04/%E8%BD%AF%E8%80%83-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B32/</url>
    <content><![CDATA[<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><p>思想：保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>
<h5 id="一个栗子："><a href="#一个栗子：" class="headerlink" title="一个栗子："></a>一个栗子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.thought;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 贪心算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/4 16:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greedy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配饼干</span></span><br><span class="line"><span class="comment">     * 每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会满足。</span></span><br><span class="line"><span class="comment">     * 求解最多可以获得满足的孩子数量.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-04 16:38:39</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> g 孩子的满足度的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 饼干大小的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最多可以获得满足的孩子数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> gi = <span class="number">0</span>, si = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (gi &lt; g.length &amp;&amp; si &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[gi] &lt;= s[si]) &#123;</span><br><span class="line">                gi++;</span><br><span class="line">            &#125;</span><br><span class="line">            si++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] g = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = findContentChildren(g, s);</span><br><span class="line">        System.out.println(<span class="string">&quot;ans = &quot;</span> + ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>分治算法重要的二分法，比如二分查找；二分查找也称折半查找（binary search），它是一种效率较高的查找方法。但是，<span style="color:red;">折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排序。</span></p>
<h5 id="正常实现"><a href="#正常实现" class="headerlink" title="正常实现"></a>正常实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.soft.examination.data.structure.algorithm.thought;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> william</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/5 9:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找正常实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021-03-05 09:48:24</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待查询的数组(要求是已经排好序的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 需要查询的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询到的key值在数组中的索引位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; key) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">28</span>, <span class="number">39</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = binarySearch(nums, <span class="number">28</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ans = &quot;</span> + ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>二分查找也称折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为$O(\log{N})$。</p>
<h6 id="mid值的计算"><a href="#mid值的计算" class="headerlink" title="mid值的计算"></a>mid值的计算</h6><p>有两种方式计算mid值的方式：</p>
<ul>
<li>$m = (l + h) / 2$</li>
<li>$ m = l + (h -l) / 2$</li>
</ul>
<p>$l + h$ 可能出现加法溢出，最好使用第二种方式。</p>
<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><p>循环退出时如果仍然没有查找到key，那么表示查找失败。可以有两种返回值：</p>
<ul>
<li><code>-1</code>：以一个错误码表示没有查找到<code>key</code></li>
<li><code>l</code>：将<code>key</code>插入到<code>nums</code>中的正确位置</li>
</ul>
<h5 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h5><ul>
<li>求开方</li>
<li>大于给定元素的最小元素</li>
<li>有序数组的<code>single element</code></li>
<li>第一个错误的版本</li>
<li>旋转数组的最小数字</li>
<li>查找区间</li>
</ul>
]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法</title>
    <url>/2020/08/17/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>递归算法是一种直接或间接调用自身函数或方法的算法。</p>
<p>Java 递归算法是基于 Java 语言实现的递归算法。</p>
<p>递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。</p>
<p>递归算法对解决一大类问题很有效，它可以使算法简洁和易于理解。</p>
<blockquote>
<p>递归算法，其实说白了，就是程序的自身调用。它表现在一段程序中往往会遇到调用自身的那样一种coding策略，这样我们就可以利用大道至简的思想，把一个大的复杂的问题层层转换为一个小的和原问题相似的问题来求解的这样一种策略。递归往往能给我们带来非常简洁非常直观的代码形势，从而使我们的编码大大简化，然而递归的思维确实很我们的常规思维相逆的，我们通常都是从上而下的思维问题， 而递归趋势从下往上的进行思维。这样我们就能看到我们会用很少的语句解决了非常大的问题，所以递归策略的最主要体现就是小的代码量解决了非常复杂的问题。</p>
</blockquote>
<span id="more"></span>
<h5 id="递归算法解决问题的特点："><a href="#递归算法解决问题的特点：" class="headerlink" title="递归算法解决问题的特点："></a>递归算法解决问题的特点：</h5><ol>
<li>递归就是方法里调用自身；</li>
<li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口；</li>
<li>递归算法解题通常显得很简洁，但递归算法解题的运行效率极低。所以一般不提倡用递归算法来设计程序；</li>
<li>在递归调用的过程中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等；</li>
</ol>
<p><strong>在做递归算法的时候，一定要把握住出口，也就是做递归算法必须要有一个明确的递归结束条件，这一点是非常重要的。</strong></p>
<h4 id="几个栗子"><a href="#几个栗子" class="headerlink" title="几个栗子"></a>几个栗子</h4><h5 id="①-斐波那契数列"><a href="#①-斐波那契数列" class="headerlink" title="① 斐波那契数列"></a>① 斐波那契数列</h5><p>一个栗子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ④ 由于斐波纳挈数列是以兔子的繁殖引入的，因此也叫“兔子数列”。它指的是这样一个数列：0,1,1,2,3,5,8,13......从这组数可以很明显看出这样一个规律：从第三个数开始，后边一个数一定是在其之前两个数的和。在数学上，斐波纳挈数列可以以这样的公式表示：F(0) = 0 F(1) = 1 F(n) = F(n-1) + F(n-2),(n&gt;=2)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibo</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibo(num - <span class="number">1</span>) + fibo(num - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="②-n-的阶乘"><a href="#②-n-的阶乘" class="headerlink" title="② n 的阶乘"></a>② n 的阶乘</h5><p><strong>0 的阶乘是 1</strong></p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorialOfN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// 递归</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(n == 0) &#123;</span></span><br><span class="line"><span class="comment">            return 1;</span></span><br><span class="line"><span class="comment">        &#125;else &#123;</span></span><br><span class="line"><span class="comment">            return n * factorialOfN(n - 1);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">// 非递归</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result *= n;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="③-列出某个目录下的所有子目录和文件"><a href="#③-列出某个目录下的所有子目录和文件" class="headerlink" title="③ 列出某个目录下的所有子目录和文件"></a>③ 列出某个目录下的所有子目录和文件</h5><p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">listAllFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; allFileList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(file.isFile()) &#123;</span><br><span class="line">        allFileList.add(file.getParent() + <span class="string">&quot;[&quot;</span> + file.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        File[] childFiles = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File childFile : childFiles) &#123;</span><br><span class="line">            List&lt;String&gt; childFileList = listAllFile(childFile);</span><br><span class="line">            allFileList.addAll(childFileList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allFileList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="④-汉诺塔问题"><a href="#④-汉诺塔问题" class="headerlink" title="④ 汉诺塔问题"></a>④ 汉诺塔问题</h5><blockquote>
<p>有n个大小不等的盘子放在一个塔A上面，自底向上按照从小到大的顺序排列。要求将所有n个盘子搬到另一个塔C上面，可以借助一个塔B中转，但是要满足任何时刻大盘子不能放在小盘子上面。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hanNuoTa</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n1 = hanNuoTa(a, c, b, n - <span class="number">1</span>);</span><br><span class="line">    move(a, c);</span><br><span class="line">    result++;</span><br><span class="line">    <span class="keyword">int</span> n2 = hanNuoTa(b, a, c, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n1 + result + n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;从&quot;</span> + a + <span class="string">&quot;移动到&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="递归算法转换成非递归算法"><a href="#递归算法转换成非递归算法" class="headerlink" title="递归算法转换成非递归算法"></a>递归算法转换成非递归算法</h4><blockquote>
<p> 递归算法实际上是一种分而治之的方法，它把复杂问题分解为简单问题来求解。对于某些复杂问题(例如hanio塔问题)，递归算法是一种自然且合乎逻辑的解决问题的方式，但是递归算法的执行效率通常比较差。因此，在求解某些问题时，常采用递归算法来分析问题，用非递归算法来求解问题；另外，有些程序设计语言不支持递归，这就需要把递归算法转换为非递归算法。将递归算法转换为非递归算法有两种方法，一种是直接求值，不需要回溯；另一种是不能直接求值，需要回溯。前者使用一些变量保存中间结果，称为直接转换法；后者使用栈保存中间结果，称为间接转换法</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>项目构建工具之maven</title>
    <url>/2020/06/30/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%B9%8Bmaven/</url>
    <content><![CDATA[<h5 id="阿里云maven仓库配置"><a href="#阿里云maven仓库配置" class="headerlink" title="阿里云maven仓库配置"></a>阿里云maven仓库配置</h5><ul>
<li>修改用户目录下的或者maven软件根目录conf文件下的settings.xml文件, 添加以下内容</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在项目的pom.xml文件中直接添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>element-ui常用组件详解</title>
    <url>/2020/07/01/element-ui%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="文件上传-uplaod"><a href="#文件上传-uplaod" class="headerlink" title="文件上传 uplaod"></a>文件上传 uplaod</h4><h5 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:center">说明</th>
<th>类型</th>
<th style="text-align:center">可选值</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">action</td>
<td style="text-align:center">必选参数，上传的地址</td>
<td>string</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">headers</td>
<td style="text-align:center">设置上传的请求头部</td>
<td>object</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">multiple</td>
<td style="text-align:center">是否支持多选文件</td>
<td>Boolean</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">data</td>
<td style="text-align:center">上传时附带的额外参数</td>
<td>object</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:center">上传的文件字段名</td>
<td>string</td>
<td style="text-align:center">-</td>
<td style="text-align:center">file</td>
</tr>
<tr>
<td style="text-align:left">with-credentials</td>
<td style="text-align:center">支持发送cookie凭证信息</td>
<td>boolean</td>
<td style="text-align:center">-</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:left">show-file-list</td>
<td style="text-align:center">是否显示已上传文件列表</td>
<td>boolean</td>
<td style="text-align:center">-</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:left">drag</td>
<td style="text-align:center">是否启用拖拽上传</td>
<td>boolean</td>
<td style="text-align:center">-</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:left">accept</td>
<td style="text-align:center">接受上传的文件类型（thumbnail-mode模式下此参数无效）</td>
<td>string</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">on-preview</td>
<td style="text-align:center">点击文件列表中已上传文件时的钩子</td>
<td>function(file)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">on-remove</td>
<td style="text-align:center">文件列表移除文件时的钩子</td>
<td>function(file, fileList)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">on-success</td>
<td style="text-align:center">文件上传成功时的钩子</td>
<td>function(response, file, fileList)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">on-error</td>
<td style="text-align:center">文件上传失败时的钩子</td>
<td>function(err, file, fileList)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">on-progress</td>
<td style="text-align:center">文件上传时的钩子</td>
<td>function(event, file, fileList)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">before-upload</td>
<td style="text-align:center">文件上传之前的钩子，参数为上传的文件，若返回false或者返回Promise且被reject，则停止上传</td>
<td>function(file)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">before-remove</td>
<td style="text-align:center">文件删除之前的钩子，参数为上传的文件和文件列表，若返回false或者返回Promise且被reject，则停止删除</td>
<td>function(file, fileList)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">list-type</td>
<td style="text-align:center">文件列表的类型</td>
<td>string</td>
<td style="text-align:center">text/picture/picture-card</td>
<td style="text-align:center">text</td>
</tr>
<tr>
<td style="text-align:left">auto-upload</td>
<td style="text-align:center">是否在选取文件之后立即进行上传</td>
<td>boolean</td>
<td style="text-align:center">-</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:left">file-list</td>
<td style="text-align:center">上传的文件列表</td>
<td>array</td>
<td style="text-align:center">-</td>
<td style="text-align:center">[]</td>
</tr>
<tr>
<td style="text-align:left">http-request</td>
<td style="text-align:center">覆盖默认的上传行为，可以自定义上传的实现</td>
<td>function</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">disabled</td>
<td style="text-align:center">是否禁用</td>
<td>boolean</td>
<td style="text-align:center">-</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:left">limit</td>
<td style="text-align:center">最大允许上传的个数</td>
<td>number</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">on-exceed</td>
<td style="text-align:center">文件超出个数限制时的钩子</td>
<td>function(file, fileList)</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h5><div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>trigger</td>
<td>触发文件选择框的内容</td>
</tr>
<tr>
<td>tip</td>
<td>提示说明文字</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h5><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>clearFiles</td>
<td>清空已上传的文件列表(该方法不支持在before-uplaod中调用)</td>
<td>-</td>
</tr>
<tr>
<td>abort</td>
<td>取消上传请求</td>
<td>（file: fileList中的file对象）</td>
</tr>
<tr>
<td>submit</td>
<td>手动上传文件列表</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Message-消息提示"><a href="#Message-消息提示" class="headerlink" title="Message 消息提示"></a>Message 消息提示</h4><p>常用于主动操作后的反馈提示。与Notification的区别是后者更多用于系统级通知的被动提醒。</p>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>从顶部出现，3秒后自动消失</p>
<p><code>this.$message(&#39;这是一个消息提示&#39;)</code></p>
<hr>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><h5 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-divider</span>&gt;</span><span class="tag">&lt;/<span class="name">el-divider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="设置文案"><a href="#设置文案" class="headerlink" title="设置文案"></a>设置文案</h5><p>可以在分割线上自定义文案内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>头上一片晴天，心中一个想念<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-divider</span> <span class="attr">content-position</span>=<span class="string">&quot;left&quot;</span>&gt;</span>少年包青天<span class="tag">&lt;/<span class="name">el-divider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>饿了别叫妈, 叫饿了么<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-divider</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-mobile-phone&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">el-divider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>为了无法计算的价值<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-divider</span> <span class="attr">content-position</span>=<span class="string">&quot;right&quot;</span>&gt;</span>阿里云<span class="tag">&lt;/<span class="name">el-divider</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>雨纷纷<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-divider</span> <span class="attr">direction</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-divider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>旧故里<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-divider</span> <span class="attr">direction</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-divider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>草木深<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="divider-attributes"><a href="#divider-attributes" class="headerlink" title="divider attributes"></a>divider attributes</h4><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>可选值</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>direction</td>
<td>设置分割线方向</td>
<td>string</td>
<td>horizontal、vertical</td>
<td>horizontal</td>
</tr>
<tr>
<td>content-position</td>
<td>设置分割线文案的位置</td>
<td>string</td>
<td>left/right/center</td>
<td>center</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="Form表单"><a href="#Form表单" class="headerlink" title="Form表单"></a>Form表单</h4><h5 id="典型表单"><a href="#典型表单" class="headerlink" title="典型表单"></a>典型表单</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-form ref&#x3D;&quot;form&quot; :model&#x3D;&quot;form&quot; label-width&#x3D;&quot;80px&quot;&gt;</span><br><span class="line">  &lt;el-form-item label&#x3D;&quot;活动名称&quot;&gt;</span><br><span class="line">    &lt;el-input v-model&#x3D;&quot;form.name&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;el-form-item label&#x3D;&quot;活动区域&quot;&gt;</span><br><span class="line">    &lt;el-select v-model&#x3D;&quot;form.region&quot; placeholder&#x3D;&quot;请选择活动区域&quot;&gt;</span><br><span class="line">      &lt;el-option label&#x3D;&quot;区域一&quot; value&#x3D;&quot;shanghai&quot;&gt;&lt;&#x2F;el-option&gt;</span><br><span class="line">      &lt;el-option label&#x3D;&quot;区域二&quot; value&#x3D;&quot;beijing&quot;&gt;&lt;&#x2F;el-option&gt;</span><br><span class="line">    &lt;&#x2F;el-select&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;el-form-item label&#x3D;&quot;活动时间&quot;&gt;</span><br><span class="line">    &lt;el-col :span&#x3D;&quot;11&quot;&gt;</span><br><span class="line">      &lt;el-date-picker type&#x3D;&quot;date&quot; placeholder&#x3D;&quot;选择日期&quot; v-model&#x3D;&quot;form.date1&quot; style&#x3D;&quot;width: 100%;&quot;&gt;&lt;&#x2F;el-date-picker&gt;</span><br><span class="line">    &lt;&#x2F;el-col&gt;</span><br><span class="line">    &lt;el-col class&#x3D;&quot;line&quot; :span&#x3D;&quot;2&quot;&gt;-&lt;&#x2F;el-col&gt;</span><br><span class="line">    &lt;el-col :span&#x3D;&quot;11&quot;&gt;</span><br><span class="line">      &lt;el-time-picker placeholder&#x3D;&quot;选择时间&quot; v-model&#x3D;&quot;form.date2&quot; style&#x3D;&quot;width: 100%;&quot;&gt;&lt;&#x2F;el-time-picker&gt;</span><br><span class="line">    &lt;&#x2F;el-col&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;el-form-item label&#x3D;&quot;即时配送&quot;&gt;</span><br><span class="line">    &lt;el-switch v-model&#x3D;&quot;form.delivery&quot;&gt;&lt;&#x2F;el-switch&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;el-form-item label&#x3D;&quot;活动性质&quot;&gt;</span><br><span class="line">    &lt;el-checkbox-group v-model&#x3D;&quot;form.type&quot;&gt;</span><br><span class="line">      &lt;el-checkbox label&#x3D;&quot;美食&#x2F;餐厅线上活动&quot; name&#x3D;&quot;type&quot;&gt;&lt;&#x2F;el-checkbox&gt;</span><br><span class="line">      &lt;el-checkbox label&#x3D;&quot;地推活动&quot; name&#x3D;&quot;type&quot;&gt;&lt;&#x2F;el-checkbox&gt;</span><br><span class="line">      &lt;el-checkbox label&#x3D;&quot;线下主题活动&quot; name&#x3D;&quot;type&quot;&gt;&lt;&#x2F;el-checkbox&gt;</span><br><span class="line">      &lt;el-checkbox label&#x3D;&quot;单纯品牌曝光&quot; name&#x3D;&quot;type&quot;&gt;&lt;&#x2F;el-checkbox&gt;</span><br><span class="line">    &lt;&#x2F;el-checkbox-group&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;el-form-item label&#x3D;&quot;特殊资源&quot;&gt;</span><br><span class="line">    &lt;el-radio-group v-model&#x3D;&quot;form.resource&quot;&gt;</span><br><span class="line">      &lt;el-radio label&#x3D;&quot;线上品牌商赞助&quot;&gt;&lt;&#x2F;el-radio&gt;</span><br><span class="line">      &lt;el-radio label&#x3D;&quot;线下场地免费&quot;&gt;&lt;&#x2F;el-radio&gt;</span><br><span class="line">    &lt;&#x2F;el-radio-group&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;el-form-item label&#x3D;&quot;活动形式&quot;&gt;</span><br><span class="line">    &lt;el-input type&#x3D;&quot;textarea&quot; v-model&#x3D;&quot;form.desc&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;el-form-item&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onSubmit&quot;&gt;立即创建&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button&gt;取消&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">&lt;&#x2F;el-form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        form: &#123;</span><br><span class="line">          name: &#39;&#39;,</span><br><span class="line">          region: &#39;&#39;,</span><br><span class="line">          date1: &#39;&#39;,</span><br><span class="line">          date2: &#39;&#39;,</span><br><span class="line">          delivery: false,</span><br><span class="line">          type: [],</span><br><span class="line">          resource: &#39;&#39;,</span><br><span class="line">          desc: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSubmit() &#123;</span><br><span class="line">        console.log(&#39;submit!&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="DatePicker-时间选择器"><a href="#DatePicker-时间选择器" class="headerlink" title="DatePicker 时间选择器"></a>DatePicker 时间选择器</h4><p>用于选择或输入日期</p>
<h5 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式"></a>日期格式</h5><p>使用<code>format</code>属性指定输入框的格式；使用<code>value-format</code>指定绑定值的格式。</p>
<p><strong>请区分大小写</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">格式</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">备注</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>yyyy</code></td>
<td style="text-align:left">年</td>
<td style="text-align:left"></td>
<td style="text-align:left">2017</td>
</tr>
<tr>
<td style="text-align:left"><code>M</code></td>
<td style="text-align:left">月</td>
<td style="text-align:left">不补0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><code>MM</code></td>
<td style="text-align:left">月</td>
<td style="text-align:left"></td>
<td style="text-align:left">01</td>
</tr>
<tr>
<td style="text-align:left"><code>W</code></td>
<td style="text-align:left">周</td>
<td style="text-align:left">仅周选择器的 <code>format</code> 可用；不补0</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><code>WW</code></td>
<td style="text-align:left">周</td>
<td style="text-align:left">仅周选择器的 <code>format</code> 可用</td>
<td style="text-align:left">01</td>
</tr>
<tr>
<td style="text-align:left"><code>d</code></td>
<td style="text-align:left">日</td>
<td style="text-align:left">不补0</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><code>dd</code></td>
<td style="text-align:left">日</td>
<td style="text-align:left"></td>
<td style="text-align:left">02</td>
</tr>
<tr>
<td style="text-align:left"><code>H</code></td>
<td style="text-align:left">小时</td>
<td style="text-align:left">24小时制；不补0</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><code>HH</code></td>
<td style="text-align:left">小时</td>
<td style="text-align:left">24小时制</td>
<td style="text-align:left">03</td>
</tr>
<tr>
<td style="text-align:left"><code>h</code></td>
<td style="text-align:left">小时</td>
<td style="text-align:left">12小时制，须和 <code>A</code> 或 <code>a</code> 使用；不补0</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><code>hh</code></td>
<td style="text-align:left">小时</td>
<td style="text-align:left">12小时制，须和 <code>A</code> 或 <code>a</code> 使用</td>
<td style="text-align:left">03</td>
</tr>
<tr>
<td style="text-align:left"><code>m</code></td>
<td style="text-align:left">分钟</td>
<td style="text-align:left">不补0</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left"><code>mm</code></td>
<td style="text-align:left">分钟</td>
<td style="text-align:left"></td>
<td style="text-align:left">04</td>
</tr>
<tr>
<td style="text-align:left"><code>s</code></td>
<td style="text-align:left">秒</td>
<td style="text-align:left">不补0</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left"><code>ss</code></td>
<td style="text-align:left">秒</td>
<td style="text-align:left"></td>
<td style="text-align:left">05</td>
</tr>
<tr>
<td style="text-align:left"><code>A</code></td>
<td style="text-align:left">AM/PM</td>
<td style="text-align:left">仅 <code>format</code> 可用，大写</td>
<td style="text-align:left">AM</td>
</tr>
<tr>
<td style="text-align:left"><code>a</code></td>
<td style="text-align:left">am/pm</td>
<td style="text-align:left">仅 <code>format</code> 可用，小写</td>
<td style="text-align:left">am</td>
</tr>
<tr>
<td style="text-align:left"><code>timestamp</code></td>
<td style="text-align:left">JS时间戳</td>
<td style="text-align:left">仅 <code>value-format</code> 可用；组件绑定值为<code>number</code>类型</td>
<td style="text-align:left">1483326245000</td>
</tr>
<tr>
<td style="text-align:left"><code>[MM]</code></td>
<td style="text-align:left">不需要格式化字符</td>
<td style="text-align:left">使用方括号标识不需要格式化的字符 (如 [A] [MM])</td>
<td style="text-align:left">MM</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Loading加载"><a href="#Loading加载" class="headerlink" title="Loading加载"></a>Loading加载</h4><p>加载数据时显示功效</p>
<h5 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h5><ul>
<li><p>指令加载</p>
<p><img src="http://wrr123.github.io/2020/07/01/element-ui%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/11.png" alt></p>
</li>
<li><p>服务加载</p>
<p><img src="http://wrr123.github.io/2020/07/01/element-ui%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/22.png" alt></p>
</li>
</ul>
<h4 id="Switch-开关"><a href="#Switch-开关" class="headerlink" title="Switch 开关"></a>Switch 开关</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>绑定 <code>v-model</code> 到一个 <code>Boolean</code> 类型的变量。可以使用 <code>active-color</code> 属性与 <code>inactive-color</code> 属性来设置开关的背景颜色。</p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-switch</span><br><span class="line">  v-model&#x3D;&quot;value2&quot;</span><br><span class="line">  active-color&#x3D;&quot;#13ce66&quot;</span><br><span class="line">  inactive-color&#x3D;&quot;#ff4949&quot;         </span><br><span class="line">  &gt;</span><br><span class="line">&lt;&#x2F;el-switch&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">      data () &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">              value1: true,</span><br><span class="line">              value2: true</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="文字描述"><a href="#文字描述" class="headerlink" title="文字描述"></a>文字描述</h5><p>使用 <code>active-text</code> 属性与 <code>inactive-text</code> 属性来设置开关的文字描述。</p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-switch</span><br><span class="line">  v-model&#x3D;&quot;value3&quot;</span><br><span class="line">  active-text&#x3D;&quot;按月付费&quot;</span><br><span class="line">  inactive-text&#x3D;&quot;按年付费&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-switch&gt;</span><br><span class="line">&lt;el-switch</span><br><span class="line">  style&#x3D;&quot;display: block&quot;</span><br><span class="line">  v-model&#x3D;&quot;value4&quot;</span><br><span class="line">  active-color&#x3D;&quot;#13ce66&quot;</span><br><span class="line">  inactive-color&#x3D;&quot;#ff4949&quot;</span><br><span class="line">  active-text&#x3D;&quot;按月付费&quot;</span><br><span class="line">  inactive-text&#x3D;&quot;按年付费&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-switch&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        value3: true,</span><br><span class="line">        value4: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="扩展的-value-类型"><a href="#扩展的-value-类型" class="headerlink" title="扩展的 value 类型"></a>扩展的 value 类型</h5><p>设置 <code>active-value</code> 与 <code>inactive-value</code> 属性，接受 <code>Boolean</code>, <code>String</code> 或 <code>Number</code> 类型的值。</p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-tooltip :content&#x3D;&quot;&#39;Switch value: &#39; + value5&quot; placement&#x3D;&quot;top&quot;&gt;</span><br><span class="line">  &lt;el-switch</span><br><span class="line">    v-model&#x3D;&quot;value5&quot;</span><br><span class="line">    active-color&#x3D;&quot;#13ce66&quot;</span><br><span class="line">    inactive-color&#x3D;&quot;#ff4949&quot;</span><br><span class="line">    active-value&#x3D;&quot;100&quot;</span><br><span class="line">    inactive-value&#x3D;&quot;0&quot;&gt;</span><br><span class="line">  &lt;&#x2F;el-switch&gt;</span><br><span class="line">&lt;&#x2F;el-tooltip&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        value5: &#39;100&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="禁用状态"><a href="#禁用状态" class="headerlink" title="禁用状态"></a>禁用状态</h5><p>设置 <code>disabled</code> 属性，接受一个 <code>Boolean</code> ,设置 <code>true</code> 即可禁用。</p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-switch</span><br><span class="line">  v-model&#x3D;&quot;value6&quot;</span><br><span class="line">  disabled&gt;</span><br><span class="line">&lt;&#x2F;el-switch&gt;</span><br><span class="line">&lt;el-switch</span><br><span class="line">  v-model&#x3D;&quot;value7&quot;</span><br><span class="line">  disabled&gt;</span><br><span class="line">&lt;&#x2F;el-switch&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        value6: true,</span><br><span class="line">        value7: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">可选值</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">disabled</td>
<td style="text-align:left">是否禁用</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">—</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">switch 的宽度（像素）</td>
<td style="text-align:left">number</td>
<td style="text-align:left">—</td>
<td style="text-align:left">40</td>
</tr>
<tr>
<td style="text-align:left">active-icon-class</td>
<td style="text-align:left">switch 打开时所显示图标的类名，设置此项会忽略 <code>active-text</code></td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">inactive-icon-class</td>
<td style="text-align:left">switch 关闭时所显示图标的类名，设置此项会忽略 <code>inactive-text</code></td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">active-text</td>
<td style="text-align:left">switch 打开时的文字描述</td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">inactive-text</td>
<td style="text-align:left">switch 关闭时的文字描述</td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">active-value</td>
<td style="text-align:left">switch 打开时的值</td>
<td style="text-align:left">boolean / string / number</td>
<td style="text-align:left">—</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">inactive-value</td>
<td style="text-align:left">switch 关闭时的值</td>
<td style="text-align:left">boolean / string / number</td>
<td style="text-align:left">—</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">active-color</td>
<td style="text-align:left">switch 打开时的背景色</td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">#409EFF</td>
</tr>
<tr>
<td style="text-align:left">inactive-color</td>
<td style="text-align:left">switch 关闭时的背景色</td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">#C0CCDA</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">switch 对应的 name 属性</td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">—</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">事件名称</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">回调参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">change</td>
<td style="text-align:left">switch 状态发生变化时的回调函数</td>
<td style="text-align:left">新状态的值</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Methods-1"><a href="#Methods-1" class="headerlink" title="Methods"></a>Methods</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">focus</td>
<td style="text-align:left">使 Switch 获取焦点</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Tabs-标签页"><a href="#Tabs-标签页" class="headerlink" title="Tabs 标签页"></a>Tabs 标签页</h4><p>分割内容上有关联但属于不同类别的数据集合。</p>
<h5 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h5><p>基础的、简洁的标签页。</p>
<p>一个栗子</p>
<p><strong>Tabs 组件提供了选项卡功能，默认选中第一个标签页，你也可以通过 <code>value</code> 属性来指定当前选中的标签页。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-tabs v-model&#x3D;&quot;activeName&quot; @tab-click&#x3D;&quot;handleClick&quot;&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;用户管理&quot; name&#x3D;&quot;first&quot;&gt;用户管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;配置管理&quot; name&#x3D;&quot;second&quot;&gt;配置管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;角色管理&quot; name&#x3D;&quot;third&quot;&gt;角色管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;定时任务补偿&quot; name&#x3D;&quot;fourth&quot;&gt;定时任务补偿&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;&#x2F;el-tabs&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        activeName: &#39;second&#39;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick(tab, event) &#123;</span><br><span class="line">        console.log(tab, event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="选项卡样式"><a href="#选项卡样式" class="headerlink" title="选项卡样式"></a>选项卡样式</h5><p>选项卡样式的标签页</p>
<p><strong>只需要设置 <code>type</code> 属性为 <code>card</code> 就可以使选项卡改变为标签风格。</strong></p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-tabs v-model&#x3D;&quot;activeName2&quot; type&#x3D;&quot;card&quot; @tab-click&#x3D;&quot;handleClick&quot;&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;用户管理&quot; name&#x3D;&quot;first&quot;&gt;用户管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;配置管理&quot; name&#x3D;&quot;second&quot;&gt;配置管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;角色管理&quot; name&#x3D;&quot;third&quot;&gt;角色管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;定时任务补偿&quot; name&#x3D;&quot;fourth&quot;&gt;定时任务补偿&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;&#x2F;el-tabs&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        activeName2: &#39;first&#39;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick(tab, event) &#123;</span><br><span class="line">        console.log(tab, event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="卡片化"><a href="#卡片化" class="headerlink" title="卡片化"></a>卡片化</h5><p>卡片化的标签。</p>
<p><strong>将 <code>type</code> 设置为 <code>border-card</code> 。</strong></p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-tabs type&#x3D;&quot;border-card&quot;&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;用户管理&quot;&gt;用户管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;配置管理&quot;&gt;配置管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;角色管理&quot;&gt;角色管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">&lt;&#x2F;el-tabs&gt;</span><br></pre></td></tr></table></figure>
<h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h5><p>可以通过 <code>top-position</code> 设置标签的位置。</p>
<p><strong>标签一共有四个方向的设置 <code>tabPosition=&quot;left|right|top|bottom&quot;</code></strong></p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-radio-group v-model&#x3D;&quot;tabPosition&quot; style&#x3D;&quot;margin-bottom: 30px;&quot;&gt;</span><br><span class="line">    &lt;el-radio-button label&#x3D;&quot;top&quot;&gt;top&lt;&#x2F;el-radio-button&gt;</span><br><span class="line">    &lt;el-radio-button label&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;el-radio-button&gt;</span><br><span class="line">    &lt;el-radio-button label&#x3D;&quot;bottom&quot;&gt;bottom&lt;&#x2F;el-radio-button&gt;</span><br><span class="line">    &lt;el-radio-button label&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;el-radio-button&gt;</span><br><span class="line">  &lt;&#x2F;el-radio-group&gt;</span><br><span class="line"></span><br><span class="line">  &lt;el-tabs :tab-position&#x3D;&quot;tabPosition&quot; style&#x3D;&quot;height: 200px;&quot;&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;用户管理&quot;&gt;用户管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;配置管理&quot;&gt;配置管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;角色管理&quot;&gt;角色管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">    &lt;el-tab-pane label&#x3D;&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;&#x2F;el-tabs&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        tabPosition: &#39;top&#39;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="自定义标签页"><a href="#自定义标签页" class="headerlink" title="自定义标签页"></a>自定义标签页</h5><p>可以通过具名 <code>slot</code> 来实现自定义标签页的内容。</p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-tabs type&#x3D;&quot;border-card&quot;&gt;</span><br><span class="line">  &lt;el-tab-pane&gt;</span><br><span class="line">    &lt;span slot&#x3D;&quot;label&quot;&gt;&lt;i class&#x3D;&quot;el-icon-date&quot;&gt;&lt;&#x2F;i&gt; 我的行程&lt;&#x2F;span&gt;</span><br><span class="line">    我的行程</span><br><span class="line">  &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;消息中心&quot;&gt;消息中心&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;角色管理&quot;&gt;角色管理&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">&lt;&#x2F;el-tabs&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://wrr123.github.io/2020/07/01/element-ui%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/001.png" alt></p>
<h5 id="动态增减标签页"><a href="#动态增减标签页" class="headerlink" title="动态增减标签页"></a>动态增减标签页</h5><p>增减标签页按钮只能在选项卡样式的标签下使用</p>
<p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-tabs v-model&#x3D;&quot;editableTabsValue&quot; type&#x3D;&quot;card&quot; editable @edit&#x3D;&quot;handleTabsEdit&quot;&gt;</span><br><span class="line">  &lt;el-tab-pane</span><br><span class="line">    :key&#x3D;&quot;item.name&quot;</span><br><span class="line">    v-for&#x3D;&quot;(item, index) in editableTabs&quot;</span><br><span class="line">    :label&#x3D;&quot;item.title&quot;</span><br><span class="line">    :name&#x3D;&quot;item.name&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123;item.content&#125;&#125;</span><br><span class="line">  &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">&lt;&#x2F;el-tabs&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        editableTabsValue: &#39;2&#39;,</span><br><span class="line">        editableTabs: [&#123;</span><br><span class="line">          title: &#39;Tab 1&#39;,</span><br><span class="line">          name: &#39;1&#39;,</span><br><span class="line">          content: &#39;Tab 1 content&#39;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          title: &#39;Tab 2&#39;,</span><br><span class="line">          name: &#39;2&#39;,</span><br><span class="line">          content: &#39;Tab 2 content&#39;</span><br><span class="line">        &#125;],</span><br><span class="line">        tabIndex: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleTabsEdit(targetName, action) &#123;</span><br><span class="line">        if (action &#x3D;&#x3D;&#x3D; &#39;add&#39;) &#123;</span><br><span class="line">          let newTabName &#x3D; ++this.tabIndex + &#39;&#39;;</span><br><span class="line">          this.editableTabs.push(&#123;</span><br><span class="line">            title: &#39;New Tab&#39;,</span><br><span class="line">            name: newTabName,</span><br><span class="line">            content: &#39;New Tab content&#39;</span><br><span class="line">          &#125;);</span><br><span class="line">          this.editableTabsValue &#x3D; newTabName;</span><br><span class="line">        &#125;</span><br><span class="line">        if (action &#x3D;&#x3D;&#x3D; &#39;remove&#39;) &#123;</span><br><span class="line">          let tabs &#x3D; this.editableTabs;</span><br><span class="line">          let activeName &#x3D; this.editableTabsValue;</span><br><span class="line">          if (activeName &#x3D;&#x3D;&#x3D; targetName) &#123;</span><br><span class="line">            tabs.forEach((tab, index) &#x3D;&gt; &#123;</span><br><span class="line">              if (tab.name &#x3D;&#x3D;&#x3D; targetName) &#123;</span><br><span class="line">                let nextTab &#x3D; tabs[index + 1] || tabs[index - 1];</span><br><span class="line">                if (nextTab) &#123;</span><br><span class="line">                  activeName &#x3D; nextTab.name;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          this.editableTabsValue &#x3D; activeName;</span><br><span class="line">          this.editableTabs &#x3D; tabs.filter(tab &#x3D;&gt; tab.name !&#x3D;&#x3D; targetName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="自定义增加标签页触发器"><a href="#自定义增加标签页触发器" class="headerlink" title="自定义增加标签页触发器"></a>自定义增加标签页触发器</h5><p>一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;margin-bottom: 20px;&quot;&gt;</span><br><span class="line">  &lt;el-button</span><br><span class="line">    size&#x3D;&quot;small&quot;</span><br><span class="line">    @click&#x3D;&quot;addTab(editableTabsValue2)&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    add tab</span><br><span class="line">  &lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;el-tabs v-model&#x3D;&quot;editableTabsValue2&quot; type&#x3D;&quot;card&quot; closable @tab-remove&#x3D;&quot;removeTab&quot;&gt;</span><br><span class="line">  &lt;el-tab-pane</span><br><span class="line">    v-for&#x3D;&quot;(item, index) in editableTabs2&quot;</span><br><span class="line">    :key&#x3D;&quot;item.name&quot;</span><br><span class="line">    :label&#x3D;&quot;item.title&quot;</span><br><span class="line">    :name&#x3D;&quot;item.name&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123;item.content&#125;&#125;</span><br><span class="line">  &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">&lt;&#x2F;el-tabs&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        editableTabsValue2: &#39;2&#39;,</span><br><span class="line">        editableTabs2: [&#123;</span><br><span class="line">          title: &#39;Tab 1&#39;,</span><br><span class="line">          name: &#39;1&#39;,</span><br><span class="line">          content: &#39;Tab 1 content&#39;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          title: &#39;Tab 2&#39;,</span><br><span class="line">          name: &#39;2&#39;,</span><br><span class="line">          content: &#39;Tab 2 content&#39;</span><br><span class="line">        &#125;],</span><br><span class="line">        tabIndex: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      addTab(targetName) &#123;</span><br><span class="line">        let newTabName &#x3D; ++this.tabIndex + &#39;&#39;;</span><br><span class="line">        this.editableTabs2.push(&#123;</span><br><span class="line">          title: &#39;New Tab&#39;,</span><br><span class="line">          name: newTabName,</span><br><span class="line">          content: &#39;New Tab content&#39;</span><br><span class="line">        &#125;);</span><br><span class="line">        this.editableTabsValue2 &#x3D; newTabName;</span><br><span class="line">      &#125;,</span><br><span class="line">      removeTab(targetName) &#123;</span><br><span class="line">        let tabs &#x3D; this.editableTabs2;</span><br><span class="line">        let activeName &#x3D; this.editableTabsValue2;</span><br><span class="line">        if (activeName &#x3D;&#x3D;&#x3D; targetName) &#123;</span><br><span class="line">          tabs.forEach((tab, index) &#x3D;&gt; &#123;</span><br><span class="line">            if (tab.name &#x3D;&#x3D;&#x3D; targetName) &#123;</span><br><span class="line">              let nextTab &#x3D; tabs[index + 1] || tabs[index - 1];</span><br><span class="line">              if (nextTab) &#123;</span><br><span class="line">                activeName &#x3D; nextTab.name;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        this.editableTabsValue2 &#x3D; activeName;</span><br><span class="line">        this.editableTabs2 &#x3D; tabs.filter(tab &#x3D;&gt; tab.name !&#x3D;&#x3D; targetName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Tabs-Attributes"><a href="#Tabs-Attributes" class="headerlink" title="Tabs Attributes"></a>Tabs Attributes</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">可选值</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">风格类型</td>
<td style="text-align:left">string</td>
<td style="text-align:left">card/border-card</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">closable</td>
<td style="text-align:left">标签是否可关闭</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">—</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">addable</td>
<td style="text-align:left">标签是否可增加</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">—</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">editable</td>
<td style="text-align:left">标签是否同时可增加和关闭</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">—</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">绑定值，选中选项卡的 name</td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">第一个选项卡的 name</td>
</tr>
<tr>
<td style="text-align:left">tab-position</td>
<td style="text-align:left">选项卡所在位置</td>
<td style="text-align:left">string</td>
<td style="text-align:left">top/right/bottom/left</td>
<td style="text-align:left">top</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Tabs-Events"><a href="#Tabs-Events" class="headerlink" title="Tabs Events"></a>Tabs Events</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">事件名称</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">回调参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">tab-click</td>
<td style="text-align:left">tab 被选中时触发</td>
<td style="text-align:left">被选中的标签 tab 实例</td>
</tr>
<tr>
<td style="text-align:left">tab-remove</td>
<td style="text-align:left">点击 tab 移除按钮后触发</td>
<td style="text-align:left">被删除的标签的 name</td>
</tr>
<tr>
<td style="text-align:left">tab-add</td>
<td style="text-align:left">点击 tabs 的新增按钮后触发</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">edit</td>
<td style="text-align:left">点击 tabs 的新增按钮或 tab 被关闭后触发</td>
<td style="text-align:left">(targetName, action)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Tab-pane-Attribute"><a href="#Tab-pane-Attribute" class="headerlink" title="Tab-pane Attribute"></a>Tab-pane Attribute</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">可选值</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">label</td>
<td style="text-align:left">选项卡标题</td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">disabled</td>
<td style="text-align:left">是否禁用</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">—</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">与选项卡 activeName 对应的标识符，表示选项卡别名</td>
<td style="text-align:left">string</td>
<td style="text-align:left">—</td>
<td style="text-align:left">该选项卡在选项卡列表中的顺序值，如第一个选项卡则为’1’</td>
</tr>
<tr>
<td style="text-align:left">closable</td>
<td style="text-align:left">标签是否可关闭</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">—</td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
</div>
<h4 id="el-input-输入框"><a href="#el-input-输入框" class="headerlink" title="el-input 输入框"></a>el-input 输入框</h4><p>通过鼠标或键盘输入字符</p>
<h5 id="带-icon-的输入框"><a href="#带-icon-的输入框" class="headerlink" title="带 icon 的输入框"></a>带 icon 的输入框</h5><blockquote>
<p><strong>可以通过 <code>prefix-icon</code> 和 <code>suffix-icon</code> 属性在 input 组件首部和尾部增加显示图标，也可以通过 slot 来放置图标。</strong></p>
</blockquote>
<h6 id="使用属性方式"><a href="#使用属性方式" class="headerlink" title="使用属性方式"></a>使用属性方式</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;demo-input-suffix&quot;&gt;</span><br><span class="line">  属性方式：</span><br><span class="line">  &lt;el-input</span><br><span class="line">    placeholder&#x3D;&quot;请选择日期&quot;</span><br><span class="line">    suffix-icon&#x3D;&quot;el-icon-date&quot;</span><br><span class="line">    v-model&#x3D;&quot;input1&quot;&gt;</span><br><span class="line">  &lt;&#x2F;el-input&gt;</span><br><span class="line">  &lt;el-input</span><br><span class="line">    placeholder&#x3D;&quot;请输入内容&quot;</span><br><span class="line">    prefix-icon&#x3D;&quot;el-icon-search&quot;</span><br><span class="line">    v-model&#x3D;&quot;input2&quot;&gt;</span><br><span class="line">  &lt;&#x2F;el-input&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h6 id="使用-slot-方式"><a href="#使用-slot-方式" class="headerlink" title="使用 slot 方式"></a>使用 slot 方式</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;demo-input-suffix&quot;&gt;</span><br><span class="line">  slot 方式：</span><br><span class="line">  &lt;el-input</span><br><span class="line">    placeholder&#x3D;&quot;请选择日期&quot;</span><br><span class="line">    v-model&#x3D;&quot;input3&quot;&gt;</span><br><span class="line">    &lt;i slot&#x3D;&quot;suffix&quot; class&#x3D;&quot;el-input__icon el-icon-date&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;&#x2F;el-input&gt;</span><br><span class="line">  &lt;el-input</span><br><span class="line">    placeholder&#x3D;&quot;请输入内容&quot;</span><br><span class="line">    v-model&#x3D;&quot;input4&quot;&gt;</span><br><span class="line">    &lt;i slot&#x3D;&quot;prefix&quot; class&#x3D;&quot;el-input__icon el-icon-search&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;&#x2F;el-input&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h4 id="layout-布局"><a href="#layout-布局" class="headerlink" title="layout 布局"></a>layout 布局</h4><p>通过 row 和 col 组件，并通过 col 组件的 <code>span</code> 属性，我们就可以自由的组合布局.<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>常用的一些属性介绍：</p>
<ul>
<li><p>分栏间隔</p>
<p>row 组件提供 <code>gutter</code> 属性来指定每一栏之间的间隔，默认间隔为 0 。</p>
</li>
<li><p>分栏偏移 支持偏移指定的栏数</p>
<p>通过制定 col 组件的 <code>offset</code> 属性可以指定分栏偏离的栏数。</p>
</li>
<li><p>对齐方式 通过 <code>flex</code> 布局来对分栏进行灵活的对齐   </p>
<p>将 <code>type</code> 属性赋值为 ‘flex’, 可以启用 flex 布局，并可通过 <code>justify</code> 属性来指定 ‘start, center, end, space-between, space-around’ 其中的值来定义子元素的排版方式。</p>
</li>
<li><p>响应式布局   </p>
<p>参照了 Bootstrap 的响应式设计，预设了五个响应尺寸，<code>xs, sm, md, lg, 和 xl</code> 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2021/03/11/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><h5 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h5><p>常见的基本操作符有 <code>+ - * / %</code>，自增自减（<code>++ --</code>）。</p>
<p><strong>如果有任何运算单元的长度超过<code>int</code>，那么运算结果就按照最长的长度计算。</strong></p>
<p><strong>如果任何运算单元的长度都不超过<code>int</code>，那么运算结果就按照<code>int</code>来计算。</strong></p>
<h6 id="i-i的区别"><a href="#i-i的区别" class="headerlink" title="i++, ++i的区别"></a><code>i++, ++i的区别</code></h6><ul>
<li><code>i++</code>：先取值，再运算。</li>
<li><code>++i</code>：先运算，再取值。</li>
</ul>
<h5 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h5><p>比较两个变量之间的关系</p>
<p>常见的关系操作符有<code>&gt;, &gt;=, &lt;, &lt;=, ==, !=</code>等等。</p>
<h5 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h5><p>常见的逻辑操作符有<code>&amp;, &amp;&amp;(短路与), |, ||(短路或), !, ^(异或)</code>。</p>
<p><code>^（异或）</code>：两边不同，返回真；两边相同，返回假。</p>
<h5 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>`</td>
<td>`</td>
<td>位或</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>位与</td>
</tr>
<tr>
<td><code>^</code></td>
<td>异或</td>
</tr>
<tr>
<td><code>~</code></td>
<td>取非</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>无符号右移</td>
</tr>
</tbody>
</table>
</div>
<h5 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值操作</td>
</tr>
<tr>
<td>+=</td>
<td>对本身进行运算，并赋值</td>
</tr>
<tr>
<td>-=</td>
<td></td>
</tr>
<tr>
<td>*=</td>
<td></td>
</tr>
<tr>
<td>/=</td>
<td></td>
</tr>
<tr>
<td>%=</td>
<td></td>
</tr>
<tr>
<td>……</td>
</tr>
</tbody>
</table>
</div>
<h5 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h5><p><code>? :</code></p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k = i &lt; j ? <span class="number">99</span> : <span class="number">88</span>;</span><br></pre></td></tr></table></figure>
<h4 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h4><h5 id="条件判断if"><a href="#条件判断if" class="headerlink" title="条件判断if"></a>条件判断<code>if</code></h5><p>一个<code>if</code>的坑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (b);</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，无论<code>b</code>为true还是false，<code>yes</code>都会被打印出来。</p>
<h5 id="条件判断switch"><a href="#条件判断switch" class="headerlink" title="条件判断switch"></a>条件判断<code>switch</code></h5><p><code>switch</code>可以使用<code>byte, short, int, char, String, enum</code>。</p>
<h5 id="循环判断while"><a href="#循环判断while" class="headerlink" title="循环判断while"></a>循环判断<code>while</code></h5><ul>
<li>while</li>
<li>do…while (至少执行一次循环体)</li>
</ul>
<h5 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句<code>for</code></h5><p>一个无限循环的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="关键字continue-break"><a href="#关键字continue-break" class="headerlink" title="关键字continue break"></a>关键字<code>continue</code> <code>break</code></h5><ul>
<li>continue：当次循环的后面代码停止执行，继续下一次循环。</li>
<li>break：结束当前的循环</li>
</ul>
<h5 id="结束外部循环"><a href="#结束外部循环" class="headerlink" title="结束外部循环"></a>结束外部循环</h5><ul>
<li><p>使用boolean变量结束外部循环</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> breakout = <span class="keyword">false</span>; <span class="comment">//是否终止外部循环的标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">&quot;:&quot;</span> + j);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == j % <span class="number">2</span>) &#123;</span><br><span class="line">                    breakout = <span class="keyword">true</span>; <span class="comment">//终止外部循环的标记设置为true</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (breakout) <span class="comment">//判断是否终止外部循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用标签结束外部循环</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//打印单数    </span></span><br><span class="line">        outloop: <span class="comment">//outloop这个标示是可以自定义的比如outloop1,ol2,out5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.println(i+<span class="string">&quot;:&quot;</span>+j);</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span>==j%<span class="number">2</span>) </span><br><span class="line">                    <span class="keyword">break</span> outloop; <span class="comment">//如果是双数，结束外部循环</span></span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>定义：数组是一个固定长度的，包含了相同类型数据的容器。</p>
<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><ul>
<li>分配空间和赋值分布进行</li>
<li>分配空间的同时赋值</li>
</ul>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><ul>
<li>选择排序</li>
<li>冒泡排序</li>
</ul>
<h5 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h5><p><strong>注意：增强for循环只能用来取值，不能用来修改数组里的值。</strong></p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values [] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">18</span>,<span class="number">62</span>,<span class="number">68</span>,<span class="number">82</span>,<span class="number">65</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//常规遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> each = values[i];</span><br><span class="line">            System.out.println(each);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//增强型for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> each : values) &#123;</span><br><span class="line">            System.out.println(each);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h5><p>数组的长度是不可变的，一旦分配好空间，是多长，就是多长，不能增加也不能减少。</p>
<p>把一个数组的值复制到另一个数组中：</p>
<p><code>System.arraycopy(src, srcPos, dest, destPos, length)</code></p>
<ul>
<li>src: 源数组</li>
<li>srcPos: 从源数组复制数据的起始位置</li>
<li>dest: 目标数组</li>
<li>destPos: 复制到目标数组的起始位置</li>
<li>length: 复制的长度</li>
</ul>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>又叫数组的数组，即二维数组中的每一个元素，也是一个（一维）数组。</p>
<h6 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//初始化二维数组，</span></span><br><span class="line">       <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//有两个一维数组，每个一维数组的长度是3</span></span><br><span class="line">       a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">5</span>;  <span class="comment">//可以直接访问一维数组，因为已经分配了空间</span></span><br><span class="line">          </span><br><span class="line">       <span class="comment">//只分配了二维数组</span></span><br><span class="line">       <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][]; <span class="comment">//有两个一维数组，每个一维数组的长度暂未分配</span></span><br><span class="line">       b[<span class="number">0</span>]  =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//必须事先分配长度，才可以访问</span></span><br><span class="line">       b[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//指定内容的同时，分配空间</span></span><br><span class="line">       <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">               &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">               &#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">               &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">       &#125;;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h5><p>Arrays是针对数组的工具类，可以进行排序、查找、复制填充等功能。</p>
<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p><code>引用</code>的概念:如果一个变量的类型是<code>类类型</code>，而非基本类型，那么该变量又叫做引用。</p>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><ol>
<li><p>多个引用，一个对象</p>
</li>
<li><p>一个引用，多个对象</p>
<p><strong>一个引用，同一时间，只能指向一个对象。</strong></p>
</li>
</ol>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>将多个类中共性的东西提取出来，作为一个统一的父类。</p>
<h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><p>定义：方法名一样，但是参数的类型不一样，或参数的个数不一样。</p>
<h6 id="可变数量的参数"><a href="#可变数量的参数" class="headerlink" title="可变数量的参数"></a>可变数量的参数</h6><p>一个栗子：</p>
<p><code>public void attack(String ..strs)</code>,在方法里面，可使用操作<code>数组</code>的方式来处理参数<code>strs</code>。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>this代表当前对象。</p>
<h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><p>因变量有基本类型和类类型两种类型，故参数也分为基本类型传参和类类型传参。</p>
<h6 id="引用与"><a href="#引用与" class="headerlink" title="引用与="></a>引用与=</h6><p>基本类型之间的<code>=</code>叫做赋值；</p>
<p>类类型之间的<code>=</code>叫做引用。</p>
<h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>私有的</td>
</tr>
<tr>
<td>“package”（friendly、default）</td>
<td>不写</td>
</tr>
<tr>
<td>protected</td>
<td>受保护的</td>
</tr>
<tr>
<td>public</td>
<td>公共的</td>
</tr>
</tbody>
</table>
</div>
<p><img src="http://wrr123.github.io/2021/03/11/java%E5%9F%BA%E7%A1%80/001.png" alt></p>
<h5 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h5><p>当一个属性被<code>static</code>修饰的时候，就叫做<code>类属性</code>，又叫做<code>静态属性</code>。</p>
<p>当一个属性被声明成类属性，那么所有的对象，都共享一个值。</p>
<p>与对象属性对比：</p>
<ul>
<li>不同对象的 <strong>对象属性</strong> 的值可能不一样；</li>
<li>但是所有对象的类属性的值，都是一样的。</li>
</ul>
<p>类属性，又叫静态属性。</p>
<p>对象属性，又叫实例属性，非静态属性。</p>
<h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><p>类方法又叫静态方法；</p>
<p>对象方法又叫实例方法，非静态方法。</p>
<p>访问一个对象方法，必须建立在有一个对象的基础上，</p>
<p>访问类方法，不需要对象的存在，直接就可以访问。</p>
<h5 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h5><ul>
<li>声明该属性的时候初始化</li>
<li>构造方法中初始化</li>
<li>初始化块</li>
</ul>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>定义：又叫做<code>Singleton</code>模式，指的是一个类，在一个JVM中，只有一个实例存在。</p>
<h6 id="饿汉式和懒汉式"><a href="#饿汉式和懒汉式" class="headerlink" title="饿汉式和懒汉式"></a>饿汉式和懒汉式</h6><ul>
<li>饿汉式：是立即加载的方式，无论是否会用到这个对象，都会加载。</li>
<li>懒汉式：是延迟加载的方式，只有使用的时候才会加载。</li>
</ul>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>枚举（menu）是一种特殊的 <strong>类</strong>，使用枚举可以很方便的定义常量。</p>
<h4 id="接口和继承"><a href="#接口和继承" class="headerlink" title="接口和继承"></a>接口和继承</h4><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口就像是一种约定。</p>
<h5 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h5><ol>
<li><p>明确引用类型和对象类型的概念</p>
<p>通常情况下，引用类型和对象类型的类型是一致的。</p>
</li>
<li><p>子类转父类（向上转型）</p>
<p>将子类转换为父类，总是成功的。</p>
</li>
<li><p>父类转子类（向下转型）</p>
<p>需要强制类型转换，不一定能转换成功。</p>
</li>
<li><p>没有继承关系的两个类，互相转换，<span style="color:red;">一定会失败。</span></p>
</li>
<li><p>实现类转接口（向上转型）</p>
</li>
<li><p>接口转实现类（向下转型）</p>
</li>
<li><p><code>instanceof</code>关键字</p>
<p><code>instanceof Map</code> 判断一个引用所指向的对象，是否为Map类型，或者Map类型的子类。</p>
</li>
</ol>
<h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p>子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，也叫覆盖。</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul>
<li><p>操作符的多态</p>
<p><code>+</code>可以作为算数运算，也可以作为字符串连接。</p>
</li>
<li><p>类的多态</p>
<p>父类引用指向子类的对象。</p>
</li>
</ul>
<h5 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h5><p>它与重写类似，方法的重写是子类覆盖父类的<code>对象方法</code>，</p>
<p><code>隐藏</code>就是子类覆盖父类的<code>类方法</code>。</p>
<h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h5><p><strong>实例化子类，父类的构造方法一定会被调用。</strong></p>
<h5 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h5><p>它是所有类的父类。</p>
<ul>
<li>toString()</li>
<li>finalize()</li>
<li>equals()</li>
<li>==</li>
<li>hashCode()</li>
<li>getClass()</li>
</ul>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><div class="table-container">
<table>
<thead>
<tr>
<th>修饰什么</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>不能被继承</td>
</tr>
<tr>
<td>方法</td>
<td>不能被重写</td>
</tr>
<tr>
<td>基本类型变量</td>
<td>该变量只有一次赋值机会</td>
</tr>
<tr>
<td>引用</td>
<td>该引用只有一次指向对象的机会</td>
</tr>
</tbody>
</table>
</div>
<p><strong>常量指可以公开，直接访问，不会变化的值。</strong></p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>在类中声明一个方法，这个方法没有方法体，是一个“空”方法。</p>
<p>这样的方法就叫抽象方法，使用修饰符<code>abstract</code>，</p>
<p>当一个类中有抽象方法的时候，该类必须被声明为抽象类。</p>
<p><strong>抽象类可以没有抽象方法。</strong></p>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>分为四种：</p>
<ol>
<li><p>非静态内部类</p>
<p>非静态内部类可以在类中直接定义。</p>
</li>
<li><p>静态内部类</p>
<p>在一个类里面声明一个静态内部类，在静态内部类中 <strong>不可以访问外部类的实例属性和方法。</strong></p>
</li>
<li><p>匿名类</p>
<p>指声明一个类的同时实例化它，使代码更加简洁精炼。</p>
</li>
<li><p>本地类</p>
<p>本地类可以理解为有名字的匿名类。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//与匿名类的区别在于，本地类有了自定义的类名</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">SomeHero</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println( name+ <span class="string">&quot; 新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        SomeHero h  =<span class="keyword">new</span> SomeHero();</span><br><span class="line">        h.name =<span class="string">&quot;地卜师&quot;</span>;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>在匿名类使用外部的局部变量，外部的局部变量必须修饰为<code>final</code>的。</strong></p>
<blockquote>
<p><strong>注：</strong>在jdk8中，已经不需要强制修饰成final了，如果没有写final，不会报错，因为编译器<strong>偷偷的</strong>帮你加上了看不见的final</p>
</blockquote>
<h5 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h5><p>默认方法是jdk1.8的新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mortal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本英雄复活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="为什么会有默认方法？"><a href="#为什么会有默认方法？" class="headerlink" title="为什么会有默认方法？"></a>为什么会有默认方法？</h6><blockquote>
<p>假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动。</p>
<p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法</p>
<p>通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</p>
</blockquote>
<h4 id="数字和字符串"><a href="#数字和字符串" class="headerlink" title="数字和字符串"></a>数字和字符串</h4><h5 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h5><p>封装类：所有的基本类型，都有对应的类类型。</p>
<p>比如int对应的类是Integer，这种类就叫做封装类。</p>
<h5 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h5><h6 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h6><ol>
<li>使用String类的静态方法<code>valueOf</code></li>
<li>先把基本类型装箱为对象，然后调用对象的<code>toString</code>方法</li>
</ol>
<h6 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h6><p>调用Integer的静态方法<code>parseInt</code></p>
<h5 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h5><p><code>java.lang.Math</code>提供一些常用的数学运算方法，并且都是以静态方法的形式存在。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.round(1.9)</td>
<td>四舍五入</td>
</tr>
<tr>
<td>Math.random()</td>
<td>得到一个0到1的随机数<code>[0, 1)</code></td>
</tr>
<tr>
<td>Math.sqrt(9)</td>
<td>开方$\sqrt{9}$</td>
</tr>
<tr>
<td>Math.pow(2, 5)</td>
<td>次方$2^5$</td>
</tr>
<tr>
<td>Math.PI</td>
<td>常数π</td>
</tr>
<tr>
<td>Math.E</td>
<td>自然常数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5><p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String name =<span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> kill = <span class="number">8</span>;</span><br><span class="line">        String title=<span class="string">&quot;超神&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差</span></span><br><span class="line">        String sentence = name+ <span class="string">&quot; 在进行了连续 &quot;</span> + kill + <span class="string">&quot; 次击杀后，获得了 &quot;</span> + title +<span class="string">&quot; 的称号&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(sentence);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//使用格式化输出</span></span><br><span class="line">        <span class="comment">//%s表示字符串，%d表示数字,%n表示换行</span></span><br><span class="line">        String sentenceFormat =<span class="string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;</span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="printf和format"><a href="#printf和format" class="headerlink" title="printf和format"></a>printf和format</h6><h6 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h6><div class="table-container">
<table>
<thead>
<tr>
<th>系统</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>DOS和Windows</td>
<td><code>\r\n</code></td>
</tr>
<tr>
<td>Linux</td>
<td><code>\n</code></td>
</tr>
<tr>
<td>Mac</td>
<td><code>\r</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>为了使得同一个java程序的换行符在所有的操作系统都有一样的表现，使用<code>%n</code>，就可以做到平台无关的换行。</strong></p>
<p>一个栗子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        System.out.printf(<span class="string">&quot;这是换行符%n&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;这是换行符%n&quot;</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达"><a href="#总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达" class="headerlink" title="总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达"></a>总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line">        <span class="comment">//总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//直接打印数字</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,默认右对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,左对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%-8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,不够补0</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%08d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//千位分隔符</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%,8d%n&quot;</span>,year*<span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//小数点位数</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%.2f%n&quot;</span>,Math.PI);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//不同国家的千位分隔符</span></span><br><span class="line">        System.out.format(Locale.FRANCE,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.US,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.UK,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>创建字符串的手段：</p>
<ul>
<li>每当有一个 <strong>字面值</strong> 出现的时候，虚拟机就会创建一个字符串。</li>
<li>调用 String 的构造方法创建一个字符串对象。</li>
<li>通过 <code>+</code> 加号进行字符串拼接也会创建新的字符串对象。</li>
</ul>
<p><strong>String类是final修改的，故不能被继承。</strong></p>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><h5 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h5><p><strong>注意：指的是<code>java.util.Date</code></strong></p>
<p>时间原点概念</p>
<blockquote>
<p>所有的数据类型，无论是整数，布尔，浮点数还是字符串，最后都需要以数字的形式表现出来。</p>
<p>日期类型也不例外，换句话说，一个日期，比如2020年10月1日，在计算机里，会用一个数字来代替。</p>
<p>那么最特殊的一个数字，就是零. 零这个数字，就代表Java中的时间原点，其对应的日期是1970年1月1日 8点0分0秒 。 (为什么是8点，因为中国的太平洋时区是UTC-8，刚好和格林威治时间差8个小时)</p>
<p>为什么对应1970年呢？ 因为1969年发布了第一个 UNIX 版本：AT&amp;T，综合考虑，当时就把1970年当做了时间原点。</p>
<p>所有的日期，都是以为这个0点为基准，每过一毫秒，就+1</p>
</blockquote>
<h5 id="日期的格式化"><a href="#日期的格式化" class="headerlink" title="日期的格式化"></a>日期的格式化</h5><h5 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h5>]]></content>
      <tags>
        <tag>how2j</tag>
      </tags>
  </entry>
  <entry>
    <title>springCloud-basis</title>
    <url>/2021/03/17/springCloud-basis/</url>
    <content><![CDATA[<h4 id="5个SpringCloud注释"><a href="#5个SpringCloud注释" class="headerlink" title="5个SpringCloud注释"></a>5个SpringCloud注释</h4><ol>
<li><p><code>@EnableConfigServer</code></p>
<p>它将你的应用程序转换为一个服务器，其他应用程序可以使用它来获取配置。这是一个非常有用的注释，用于使用Spring云开发Java中的服务，在那里可以有一个专用Java服务来配置。</p>
</li>
<li><p><code>@EnableEurekaServer</code></p>
<p>它使你的应用程序成为<code>Eureka</code>发现服务，其他应用程序可以使用它来定位服务。</p>
</li>
<li><p><code>@EnableDiscoveryClient</code></p>
<p>它使你的应用程序注册到服务发现中，并通过它发现其他服务。</p>
</li>
<li><p><code>@EnableCircuitBreaker</code></p>
<p>它配置了<code>Hystrix</code>断路器协议。</p>
<p>如果你必须构建一个使用断路器模式的微服务器应用程序，那么你直到当方法调用失败时，它可以适当地降低功能。</p>
<p>使用断路器模式还允许微服务在相关服务发生故障时继续运行，防止级联故障，从而给故障服务时间恢复。</p>
</li>
<li><p><code>@HystrixCommand(fallbackMethod=&quot;fallbackMethodName&quot;)</code></p>
<p>如果方法不能正常成功，那么这个注解将标记这些方法返回到另一个方法。</p>
<p><strong>目前，这只适用于标记有<code>@Component</code> 或 <code>@Service</code> 注释的类。</strong></p>
</li>
</ol>
<span id="more"></span>
<h4 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h4><h5 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h5><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<p>Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：</p>
<ul>
<li>Spring Cloud Config</li>
<li>Spring Cloud Netflix</li>
<li>Spring Cloud CloudFoundry</li>
<li>Spring Cloud AWS</li>
<li>Spring Cloud Security</li>
<li>Spring Cloud Commons</li>
<li>Spring Cloud Zookeeper</li>
<li>Spring Cloud CLI</li>
<li>…</li>
</ul>
<h5 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h5><p>简单地说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务之间通过诸如<code>RESTful API</code>的方式互相调用。</p>
<h5 id="服务注册和发现-1"><a href="#服务注册和发现-1" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h5><p>这里我们会用到Spring Cloud的一个子项目，<code>Spring Cloud Netflix</code>，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。</p>
<p>通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p>
<p>它主要提供的模块包括：服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）、客户端负载均衡（Ribbon）等。</p>
<h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><h5 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h5><p>Ribbon是一个基于HTTP和TCP客户端的负载均衡器。Feign中也会适用Ribbon。</p>
<p>Ribbon可以在通过客户端中配置的<code>ribbonServerList</code>服务端列表去轮询访问以达到负载均衡的作用。</p>
<p>当Ribbon和Eureka联合使用时，ribbonServerList会被<code>DiscoveryEnabledNIWSServerList</code>重写，扩展成从Eureka注册中心获取服务端列表。同时它也会用<code>NIWSDiscoveryPing</code>来取代<code>Ping</code>，它将职责委托给Eureka来确定服务端是否已经启动。</p>
<h6 id="注解-LoadBalanced"><a href="#注解-LoadBalanced" class="headerlink" title="注解@LoadBalanced"></a>注解<code>@LoadBalanced</code></h6><p>开启负载均衡能力</p>
<h5 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h5><p>Feign是一个声明式的Web Service客户端，它使得编写Web Service客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它即可完成。它具备可插拔的注解支持，包括Feign注解和JAX-RS注解。Feign也支持可插拔的编码器和解码器。Spring Cloud为Feign增加了Spring MVC注解的支持，还整合了Ribbon和Eureka来提供负载均衡的HTTP的客户端实现。</p>
<h4 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h4><p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，最终导致自身服务的瘫痪。</p>
<blockquote>
<p>举个例子，在一个电商网站中，我们可能会将系统拆分成，用户、订单、库存、积分、评论等一系列的服务单元。用户创建一个订单的时候，在调用订单服务创建订单的时候，会向库存服务来请求出货（判断是否有足够库存来出货）。此时若库存服务因网络原因无法被访问到，导致创建订单服务的线程进入等待库存申请服务的响应，在漫长的等待之后用户会因为请求库存失败而得到创建订单失败的结果。如果在高并发情况之下，因这些等待线程在等待库存服务的响应而未能释放，使得后续到来的创建订单请求被阻塞，最终导致订单服务也不可用。</p>
</blockquote>
<p>在微服务架构中，存在着那么多的服务单元，若一个单元出现故障，就会因依赖关系形成故障蔓延，最终导致整个系统的瘫痪，这样的架构相较传统架构就更加的不稳定。为了解决这个问题，因此产生了断路器模式。</p>
<h5 id="什么是断路器"><a href="#什么是断路器" class="headerlink" title="什么是断路器"></a>什么是断路器</h5><blockquote>
<p>“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p>
</blockquote>
<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h5 id="Netflix-Hystrix"><a href="#Netflix-Hystrix" class="headerlink" title="Netflix Hystrix"></a>Netflix Hystrix</h5><p>在Spring Cloud 中使用了Hystrix来实现断路器的功能。</p>
<p>Hystrix是NetFlix开源的微服务框架套件之一，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。</p>
<p>Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</p>
<ul>
<li>Robbin中引入Hystrix</li>
<li>Feign使用Hystrix</li>
</ul>
<h4 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h4><p>Spring Cloud Config 为服务端和客户端提供了分布式系统的外部化配置支持。配置服务器为各应用的所有环境提供了一个中心化的外部配置。它实现了对服务端和客户端对Spring Environment和PropertySource抽象的映射，所以它除了适用于Spring构建的应用程序，也可以在任何其他语言运行的应用程序中使用。作为一个应用可以通过部署管道来进行测试或投入生产，我们可以分别为这些环境创建配置，并且在需要迁移环境的时候获取对应环境的配置来运行。</p>
<p><strong>它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库。</strong></p>
<h5 id="构建Config-Server"><a href="#构建Config-Server" class="headerlink" title="构建Config Server"></a>构建Config Server</h5><p>通过Spring Cloud来构建一个Config Server，需要三步：</p>
<ol>
<li><p>pom.xml引入 <code>spring-cloud-config-server</code>依赖</p>
</li>
<li><p>创建Spring Boot的程序主类，并添加<code>@EnableConfigServer</code>注解，开启Config Server</p>
</li>
<li><p><code>application.properties</code>中配置服务信息以及git信息</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.application.name=config-server</span><br><span class="line">server.port=<span class="number">7001</span></span><br><span class="line"></span><br><span class="line"># git管理配置</span><br><span class="line">spring.cloud.config.server.git.uri=http:<span class="comment">//git.oschina.net/didispace/SpringBoot-Learning/</span></span><br><span class="line">spring.cloud.config.server.git.searchPaths=Chapter9-<span class="number">1</span>-<span class="number">4</span>/config-repo</span><br><span class="line">spring.cloud.config.server.git.username=username</span><br><span class="line">spring.cloud.config.server.git.password=password</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="服务端验证"><a href="#服务端验证" class="headerlink" title="服务端验证"></a>服务端验证</h5><p><img src="http://wrr123.github.io/2021/03/17/springCloud-basis/001.png" alt></p>
<h5 id="微服务端映射配置"><a href="#微服务端映射配置" class="headerlink" title="微服务端映射配置"></a>微服务端映射配置</h5><h6 id="在微服务应用中获取配置信息"><a href="#在微服务应用中获取配置信息" class="headerlink" title="在微服务应用中获取配置信息"></a>在微服务应用中获取配置信息</h6><ul>
<li><p>创建一个Spring Boot应用，在pom.xml中引入spring-cloud-starter-config依赖</p>
</li>
<li><p>创建最基本的spring-boot启动主类</p>
</li>
<li><p>创建<code>bootstrap.properties</code>配置，来指定config server</p>
<p>一个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.application.name=didispace</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">spring.cloud.config.label=master</span><br><span class="line">spring.cloud.config.uri=http:<span class="comment">//localhost:7001/</span></span><br><span class="line">server.port=<span class="number">7002</span></span><br></pre></td></tr></table></figure>
<p><strong>这里需要格外注意：上面这些属性必须配置在<code>bootstrap.properties</code>中，config部分内容才能被正确加载。因为config的相关配置会先于<code>application.properties</code>，而<code>bootstrap.properties</code>的加载也是先于<code>application.properties</code>。</strong></p>
</li>
<li><p>创建一个REST API来返回配置中心的 <code>form</code> 属性</p>
</li>
</ul>
<h4 id="分布式配置中心（续）"><a href="#分布式配置中心（续）" class="headerlink" title="分布式配置中心（续）"></a>分布式配置中心（续）</h4><h5 id="上一章spring-cloud-config的使用"><a href="#上一章spring-cloud-config的使用" class="headerlink" title="上一章spring cloud config的使用"></a>上一章spring cloud config的使用</h5><ul>
<li>构建了config-server，连接到Git仓库</li>
<li>在Git上创建了一个config-repo目录，用来存储配置信息</li>
<li>构建了config-client，来获取git中的配置信息</li>
</ul>
<h5 id="高可用问题"><a href="#高可用问题" class="headerlink" title="高可用问题"></a>高可用问题</h5><h6 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h6><p>通常在生产环境，Config Server与服务注册中心一样，我们也需要将其扩展为高可用的集群。</p>
<p><img src="http://wrr123.github.io/2021/03/17/springCloud-basis/002.png" alt></p>
<h6 id="注册为服务"><a href="#注册为服务" class="headerlink" title="注册为服务"></a>注册为服务</h6><p>虽然通过服务器负载均衡已经能够实现，但是作为架构内的配置管理，本身其实也是可以看作架构中的一个微服务。所以，另外一种更为简单的方法就是把config-server也注册为服务，这样所有客户端就能以服务的方式进行访问。通过这种方法，只需要启动多个指向同一个Git仓库位置的config-server就能实现高可用了。</p>
<p><strong>注解@RefreshScope的含义</strong></p>
<ul>
<li>在类上实现对象属性的动态更新</li>
</ul>
<h4 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h4><h5 id="now："><a href="#now：" class="headerlink" title="now："></a>now：</h5><p>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hyxtrix的熔断机制来避免在微服务架构中，个别服务出现异常时引起的故障蔓延。</p>
<h5 id="服务网关-1"><a href="#服务网关-1" class="headerlink" title="服务网关"></a>服务网关</h5><p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，他还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>
<h5 id="开始使用Zuul"><a href="#开始使用Zuul" class="headerlink" title="开始使用Zuul"></a>开始使用Zuul</h5><ul>
<li><p>引入jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>这里用了<code>@SpringCloudApplication</code>注解，之前没有提过，通过源码我们看到，它整合了<code>@SpringBootApplication</code>、<code>@EnableDiscoveryClient</code>、<code>@EnableCircuitBreaker</code>，主要目的还是简化配置。</strong></p>
<h5 id="Zuul配置"><a href="#Zuul配置" class="headerlink" title="Zuul配置"></a>Zuul配置</h5><h6 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h6><p>在Zuul中提供了两种映射方式：</p>
<ol>
<li><p>通过url直接映射</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># routes to url</span></span><br><span class="line"><span class="meta">zuul.routes.api-a-url.path</span>=<span class="string">/api-a-url/**</span></span><br><span class="line"><span class="meta">zuul.routes.api-a-url.url</span>=<span class="string">http://localhost:2222/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将Zuul注册到eureka server上去发现其他服务，就可以实现对ServerId的映射</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">zuul.routes.api-a.path</span>=<span class="string">/api-a/**</span></span><br><span class="line"><span class="meta">zuul.routes.api-a.serviceId</span>=<span class="string">service-A</span></span><br><span class="line"></span><br><span class="line"><span class="meta">zuul.routes.api-b.path</span>=<span class="string">/api-b/**</span></span><br><span class="line"><span class="meta">zuul.routes.api-b.serviceId</span>=<span class="string">service-B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:1111/eureka/</span></span><br></pre></td></tr></table></figure>
<p><strong>推荐使用serviceId的映射方式，除了对Zuul维护上更加友好之外，serviceId映射方式还支持了断路器，对于服务故障的情况下，可以有效的防止故障蔓延到服务网关上而影响整个系统的对外服务</strong></p>
</li>
</ol>
<h6 id="服务过滤"><a href="#服务过滤" class="headerlink" title="服务过滤"></a>服务过滤</h6><p>在完成服务路由之后，我们对外开发服务还需要一些安全措施来保护客户端只能访问它应该访问到的资源。</p>
<p>所以我们需要利用Zuul的过滤器来实现我们对外服务的安全控制。</p>
<p>在服务网关中定义过滤器只需要继承<code>ZuulFilter</code>抽象类实现其定义的四个抽象函数就可对请求进行拦截与过滤。</p>
<p>需要重写实现下面的四个方法：</p>
<ul>
<li><code>filterType</code>：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：<ul>
<li><code>pre</code>：可以在请求被路由之前调用</li>
</ul>
</li>
<li><code>routing</code>：在路由请求时候被调用<ul>
<li><code>post</code>：在routing和error过滤器之后被调用</li>
</ul>
</li>
<li><p><code>error</code>：处理请求时发生错误时被调用</p>
</li>
<li><p><code>filterOrder</code>：通过int值来定义过滤器的执行顺序</p>
</li>
<li><p><code>shouldFilter</code>：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可实现过滤器的开关。在上例中，我们直接返回true，所以该过滤器总是生效。</p>
</li>
<li><p><code>run</code>：过滤器的具体逻辑。需要注意，这里我们通过<code>ctx.setSendZuulResponse(false)</code>令zuul过滤该请求，不对其进行路由，然后通过<code>ctx.setResponseStatusCode(401)</code>设置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过<code>ctx.setResponseBody(body)</code>对返回body内容进行编辑等。</p>
</li>
</ul>
<h5 id="为什么服务网关是微服务架构的重要部分？"><a href="#为什么服务网关是微服务架构的重要部分？" class="headerlink" title="为什么服务网关是微服务架构的重要部分？"></a>为什么服务网关是微服务架构的重要部分？</h5><ul>
<li>不仅仅实现了路由功能来屏蔽诸多服务细节，更实现了服务级别、均衡负载的路由。</li>
<li>实现了接口权限校验与微服务业务逻辑的解耦。通过服务网关中的过滤器，在各生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，保证了微服务的无状态性，同时降低了微服务的测试难度，让服务本身更集中关注业务逻辑的处理。</li>
<li>实现了断路器，不会因为具体微服务的故障而导致服务网关的阻塞，依然可以对外服务。</li>
</ul>
<h4 id="高可用的服务注册中心"><a href="#高可用的服务注册中心" class="headerlink" title="高可用的服务注册中心"></a>高可用的服务注册中心</h4><p>我们之前的服务注册中心是单点的，并不是适用于线上生产环境，因此构建高可用的Eureka Server集群就显得很重要了。</p>
<h5 id="Eureka-Server的高可用"><a href="#Eureka-Server的高可用" class="headerlink" title="Eureka Server的高可用"></a>Eureka Server的高可用</h5><p>Eureka Server除了单点运行之外，还可以通过运行多个实例，并进行互相注册的方式来实现高可用的部署，所以我们只需要将Eureka Server配置其他可用的serviceUrl就能实现高可用部署。</p>
<h5 id="服务注册和发现-2"><a href="#服务注册和发现-2" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.application.name=compute-service</span><br><span class="line">server.port=2222</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的配置主要对<code>eureka.client.serviceUrl.defaultZone</code>属性做了改动，将注册中心指向了之前我们搭建的peer1与peer2。</p>
<h5 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h5><p>Eureka Server的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。</p>
<p><strong>两两注册的方式可以实现集群中节点完全对等的效果，实现最高可用性集群，任何一台注册中心故障都不会影响服务的注册和发现。</strong></p>
<h4 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h4><p>一个问题：如何实现对配置信息的实时更新。</p>
<p>虽然我们已经可以通过<code>/refresh</code>接口和GIT仓库的web hook来实现Git仓库中的内容修改触发应用程序的属性更新。但是随着系统的不断扩张，会变得越来越难以维护，而消息代理中间件是解决这个问题的最佳方案。</p>
<p><strong>消息中间代理件可以将消息路由到一个或多个目的地。</strong></p>
<h5 id="RabbitMQ实现"><a href="#RabbitMQ实现" class="headerlink" title="RabbitMQ实现"></a>RabbitMQ实现</h5><ul>
<li><p>添加jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件中增加关于RabbitMQ的连接和用户信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">springcloud</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动config-server-eureka，再启动两个config-client-eureka（分别在不同的端口上，比如7002、7003），我们可以在config-client-eureka中的控制台中看到如下内容，在启动时候，客户端程序多了一个<code>/bus/refresh</code>请求</p>
</li>
<li><p>先访问两个config-client-eureka的<code>/from</code>请求，会返回当前<code>config-repo/didispace-dev.properties</code>中的from属性。</p>
</li>
<li>接着，我们修改<code>config-repo/didispace-dev.properties</code>中的from属性值，并发送POST请求到其中的一个<code>/bus/refresh</code>。</li>
<li>最后，我们再分别访问启动的两个config-client-eureka的<code>/from</code>请求，此时这两个请求都会返回最新的<code>config-repo/didispace-dev.properties</code>中的from属性。</li>
</ul>
<h4 id="消息总线（续：Kafka）"><a href="#消息总线（续：Kafka）" class="headerlink" title="消息总线（续：Kafka）"></a>消息总线（续：Kafka）</h4><h5 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h5><p>Kafka是一个由LinkedIn开发的分布式消息系统。</p>
<p>Kafka是基于消息发布、订阅模式实现的消息系统，其主要设计目标如下：</p>
<ul>
<li>消息持久化：以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。</li>
<li>高吞吐：在廉价的商用机器上也能支持单机每秒100K条以上的吞吐量</li>
<li>分布式：支持消息分区以及分布式消费，并保证分区内的消息顺序</li>
<li>跨平台：支持不同技术平台的客户端（如：Java、PHP、Python等）</li>
<li>实时性：支持实时数据处理和离线数据处理</li>
<li>伸缩性：支持水平扩展</li>
</ul>
<p>Kafka中涉及的一些概念：</p>
<ul>
<li>Broker：Kafka集群包含一个或多个服务器，这些服务器被称为Broker。</li>
<li>Topic：逻辑上同Rabbit的Queue队列相似，每条发布到Kafka集群的消息都必须有一个Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个Broker上，但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li>Partition：Partition是物理概念上的分区，为了提供系统吞吐率，在物理上每个Topic会分成一个或多个Partition，每个Partition对应一个文件夹（存储对应分区的消息内容和索引文件）。</li>
<li>Producer：消息生产者，负责生产消息并发送到Kafka Broker。</li>
<li>Consumer：消息消费者，向Kafka Broker读取消息并处理的客户端。</li>
<li>Consumer Group：每个Consumer属于一个特定的组（可为每个Consumer指定属于一个组，若不指定则属于默认组），组可以用来实现一条消息被组内多个成员消费等功能。</li>
</ul>
<h5 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h5><ol>
<li>启动ZooKeeper</li>
<li>启动Kafka</li>
<li>创建Topic</li>
<li>创建消息生产者</li>
<li>创建消息消费者</li>
</ol>
<h5 id="整合Spring-Cloud-Bus"><a href="#整合Spring-Cloud-Bus" class="headerlink" title="整合Spring Cloud Bus"></a>整合Spring Cloud Bus</h5>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java开发手册</title>
    <url>/2021/01/11/java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h4 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h4><ol>
<li><p><span style="color:brown;">【强制】</span> 使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>,传入的是类型完全一致、长度为<code style="color: olive;"> 0 </code>的数组。</p>
<p><span style="color:red;">反例：</span> 直接使用 <code>toArray</code> 无参方法存在问题，此方法返回值只能是 <code>Object[]</code> 类，若强转其它类型数组将出现 <code>ClassCastException</code> 错误。</p>
<p><span style="color:green;">正例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;guan&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bao&quot;</span>);</span><br><span class="line">String[] arrat = list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p><span style="color:gray;">说明：</span> 使用 <code>toArray</code> 带参方法，数组空间大小的 <code>length</code>：</p>
<ol>
<li><p><span style="color:blue;">等于 0， </span> 动态创建与 size 相同的数组，性能最好。</p>
</li>
<li><p><span style="color:blue;">大于 0 但小于 size， </span>重新创建大小等于 size 的数组，增加 GC 负担。</p>
</li>
<li><p><span style="color:blue;">等于 size，</span> 在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 <code>2</code> 相同。</p>
</li>
<li><p><span style="color:blue;">大于 size，</span> 空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。</p>
<span id="more"></span>
</li>
</ol>
</li>
<li><p><span style="color:brown;">【强制】</span> 在使用 <code>COllection</code> 接口任何实现类的 <code>addAll()</code> 方法时，都要对输入的集合参数进行 NPE 判断。</p>
<p><span style="color:gray;">说明：</span> 在 <code>ArrayList#addAll</code> 方法的第一行代码即 <code>Object[] a = c.toArray();</code> 其中 c 为输入集合参数，如果为 null，则直接抛出异常。</p>
</li>
<li><p><span style="color:brown;">【强制】</span> 使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法，它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</p>
<p><span style="color:gray;">说明：</span> <code>asList</code> 的返回对象是一个 <code>Arrays</code> 内部类，并没有实现集合的修改方法。<code>Arrays.asList</code> 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;chen&quot;</span>, <span class="string">&quot;yang&quot;</span>, <span class="string">&quot;hao&quot;</span>&#125;;</span><br><span class="line">List list = Arrays.asList(str);</span><br></pre></td></tr></table></figure>
<p>第一种情况：<code>list.add(&quot;yang111&quot;);</code>  运行时异常。</p>
<p>第二种情况：<code>str[0] = &quot;change&quot;;</code> 也会随之修改，反之亦然。</p>
</li>
<li><p><span style="color:brown;">【强制】</span> 泛型通配符<code>&lt;? extends T&gt;</code> 来接收返回的数据，此写法的泛型集合不能使用<code>add</code> 方法，而 <code>&lt;? super T&gt;</code> 不能使用 <code style="color:red;">get</code> 方法，两者在接口调用赋值的场景中容易出错。</p>
<p><span style="color:gray;">说明：</span> 扩展说一下 <code>PECS(Producer EXtends Consumer Super)</code> 原则：</p>
<ol>
<li>频繁往外读取内容的，适合用 <code>&lt;? extends T&gt;</code>。</li>
<li>经常往里插入的，适合用 <code>&lt;? super T&gt;</code>。</li>
</ol>
</li>
<li><p><span style="color:brown;">【强制】</span> 在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 <code>instanceOf</code> 判断，避免抛出 <code>ClassCastException</code> 异常。</p>
<p><span style="color:gray;">说明：</span> 毕竟泛型是在 JDK5 后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。</p>
<p><span style="color:red;">反例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; generics = <span class="keyword">null</span>;</span><br><span class="line">List notGenerics = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br><span class="line">notGenerics.add(<span class="keyword">new</span> Object());</span><br><span class="line">notGenerics.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">generics = notGenerics;</span><br><span class="line"><span class="comment">// 此处抛出 ClassCastException</span></span><br><span class="line">String string = generics.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color:brown;">【强制】</span> 不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code style="color:red;">Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p>
<p><span style="color:green;">正例：</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String item = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:red;">反例：</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String item: list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(item)) &#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color:brown;">【强制】</span> 在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然 <code>Arrays.sort, Collections.sort</code> 会抛 <code>IllegalArgumentException</code> 异常。</p>
<p><span style="color:gray;">说明：</span> 三个条件如下</p>
<ol>
<li>x, y 的比较结果和 y, x 的比较结果相反。</li>
<li>x &gt; y, y &gt; z, 则 x &gt; z。</li>
<li>x = y,则 x，z 比较结果和y，z 比较结果相同。</li>
</ol>
<p><span style="color:red;">反例：</span> 下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中可能出现异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color:tan;">【推荐】</span> 集合泛型定义时，在 JDK7 及以上，使用 <code>diamond</code> 语法或全省略。</p>
<p><span style="color:gray;">说明：</span> 菱形泛型，即 <code>diamond</code>, 直接使用 <code>&lt;&gt;</code> 来指代前边已经指定的类型。</p>
<p><span style="color:green;">正例：</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diamond 方式，即 &lt;&gt;</span></span><br><span class="line">Map&lt;String, String&gt; userCache = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 全省略方式</span></span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color:tan;">【推荐】</span> 集合初始化时，指定集合初始值大小。</p>
<p><span style="color:gray;">说明：</span> HashMap 使用 <code>HashMap(int initialCapacity)</code> 初始化，如果暂时无法确定集合大小，那么指定默认值<code>(16)</code> 即可。</p>
<p><span style="color:green;">正例：</span> initialCapacity = （需要存储的元素个数 / 负载因子）+ 1。注意负载因子（即 loader factor）默认为 <code>0.75</code>，如果暂时无法确定初始值大小，请设置为 <code>16</code>（即默认值）。</p>
<p><span style="color:red;">反例：</span> HashMap需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，resize() 方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序性能。</p>
</li>
<li><p><span style="color:tan;">【推荐】</span> 使用 <code>entrySet</code> 遍历 Map 类集合 KV，而不是 <code>keySet</code> 方式进行遍历。</p>
<p><span style="color:gray;">说明：</span> keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，可使用 <code>Map.forEach</code> 方法。</p>
<p><span style="color:green;">正例：</span> values() 返回的是 V 值集合，是一个 list 集合对象；<code>keySet()</code> 返回的是 K 值集合，是一个 Set 集合对象；<code>entrySet()</code> 返回的是 K-V 值组合集合。</p>
</li>
<li><p><span style="color:tan;">【推荐】</span> 高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：</p>
<p>|      集合类       |                     Key                      |                    Value                     |    Super    |          说明           |<br>| :———————-: | :—————————————————————: | :—————————————————————: | :————-: | :——————————-: |<br>|     HashTable     | <span style="color:red;">不允许为null</span> | <span style="color:red;">不允许为null</span> | Dictionary  |        线程安全         |<br>| ConcurrentHashMap | <span style="color:red;">不允许为null</span> | <span style="color:red;">不允许为null</span> | AbstractMap | 锁分段技术（JDK8：CAS） |<br>|      TreeMap      | <span style="color:red;">不允许为null</span> | <span style="color:blue;">允许为null</span>  | AbstractMap |       线程不安全        |<br>|      HashMap      | <span style="color:blue;">允许为null</span>  | <span style="color:blue;">允许为null</span>  | AbstractMap |       线程不安全        |</p>
<p><span style="color:red;">反例：</span> 由于 HashMap 的干扰，很多人认为 <code>ConcurrentHashMap</code> 是可以置入 null 值，而事实上，存储 null 值时会抛出 <code>NPE</code> 异常。</p>
</li>
<li><p><span style="color:green;">【参考】</span> 合理利用好集合的有序性（sort）和稳定性（order），避免集合的无序性（unsort）和不稳定性（unorder）带来的负面影响。</p>
<p><span style="color:gray;">说明：</span> 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性是指集合每次遍历的元素次序是一定的。</p>
<p>如：<code>ArrayList</code> 是 <code>order/unsort</code>;<code>HashMap</code> 是 <code>unorder/unsort</code>;<code>TreeSet</code> 是 <code>order/sort</code>。</p>
</li>
<li><p><span style="color:green;">【参考】</span> 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</p>
</li>
</ol>
<h4 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h4><h5 id="1-【强制】-获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"><a href="#1-【强制】-获取单例对象需要保证线程安全，其中的方法也要保证线程安全。" class="headerlink" title="1. 【强制】 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"></a>1. <span style="color:brown;">【强制】</span> 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h5><p><span style="color: sienna;">说明：</span> 资源驱动类、工具类、单例工厂类都需要注意。</p>
<h5 id="2-【强制】-创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"><a href="#2-【强制】-创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。" class="headerlink" title="2. 【强制】 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"></a>2. <span style="color:brown;">【强制】</span> 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</h5><p><code style="color:green;">正例：</code> 自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给 <code>whatFeatureOfGroup</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AutomicInteger nextId = <span class="keyword">new</span> AutomicInteger(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义线程组名称，在利用 jstack 来排查问题时，非常有帮助</span></span><br><span class="line">    UserThreadFactory(String whatFeatureOfGroup) &#123;</span><br><span class="line">        namePrefix = <span class="string">&quot;From UserThreadFactory&#x27;s&quot;</span> + whatFeatureFactory + <span class="string">&quot;-Worker-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        String name = namePrefix + nextId.getAndIncrement();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">null</span>, task, name, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        System.out.println(thread.getName());</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-【强制】-线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。"><a href="#3-【强制】-线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。" class="headerlink" title="3. 【强制】 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。"></a>3. <span style="color:brown;">【强制】</span> 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</h5><p><span style="color:sienna;">说明：</span> 线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
<h5 id="4-【强制】-线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"><a href="#4-【强制】-线程池不允许使用-Executors-去创建，而是通过-ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。" class="headerlink" title="4. 【强制】 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"></a>4. <span style="color:brown;">【强制】</span> 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</h5><p><span style="color:sienna;">说明：</span> Executors 返回的线程池对象的弊端如下：</p>
<ol>
<li><p><span style="color:orangered;">FixedThreadPool</span> 和 <span style="color:orangered;">SingleThreadPool：</span></p>
<p>允许的请求队列长度为 <code>Integer.MAX_VALUE</code>, 可能会堆积大量的请求，从而导致 OOM。</p>
</li>
<li><p><span style="color:orangered;">CachedThreadPool：</span></p>
<p>允许的创建线程数量为 <code>Integer.MAX_VALUE</code>, 可能会创建大量的线程，从而导致 OOM。</p>
</li>
</ol>
<h5 id="5-【强制】-SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为-static-必须加锁，或者使用DateUtils工具类。"><a href="#5-【强制】-SimpleDateFormat-是线程不安全的类，一般不要定义为-static-变量，如果定义为-static-必须加锁，或者使用DateUtils工具类。" class="headerlink" title="5. 【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static, 必须加锁，或者使用DateUtils工具类。"></a>5. <span style="color:brown;">【强制】</span> <code>SimpleDateFormat</code> 是线程不安全的类，一般不要定义为 <code>static</code> 变量，如果定义为 <code>static</code>, 必须加锁，或者使用<code>DateUtils</code>工具类。</h5><p><code style="color:green;">正例：</code> 注意线程安全，使用 <code>DateUtils。</code> 亦推荐如下处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:sienna;">说明：</span> 如果是 JDK8 的应用，可以使用 <code>Instant</code> 代替 <code>Date</code>, <code>LocalDateTime</code> 代替 <code>Calendar</code>,</p>
<p><code>DateTimeFormatter</code> 代替 <code>SimpleDateFormat</code>, 官方给出的解释：<code>simple beautiful strong immutable thread-safe</code>。</p>
<h5 id="6-【强制】-必须回收自定义的-ThreadLocal-变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的-ThreadLocal-变量，可能会影响后续业务逻辑和造成内存泄漏等问题。尽量在代理中使用-try-finally-块进行回收。"><a href="#6-【强制】-必须回收自定义的-ThreadLocal-变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的-ThreadLocal-变量，可能会影响后续业务逻辑和造成内存泄漏等问题。尽量在代理中使用-try-finally-块进行回收。" class="headerlink" title="6. 【强制】 必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄漏等问题。尽量在代理中使用 try-finally 块进行回收。"></a>6. <span style="color:brown;">【强制】</span> 必须回收自定义的 <code>ThreadLocal</code> 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 <code>ThreadLocal</code> 变量，可能会影响后续业务逻辑和造成内存泄漏等问题。尽量在代理中使用 try-finally 块进行回收。</h5><p><span style="color:green;">正例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obejectThreadLocal.set(userInfo);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;fianlly &#123;</span><br><span class="line">    objectThreadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-【强制】-高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"><a href="#7-【强制】-高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。" class="headerlink" title="7. 【强制】 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"></a>7. <span style="color:brown;">【强制】</span> 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</h5><p><span style="color:sienna;">说明：</span> 尽可能使加锁的代码工作量尽可能的小，避免在锁代码块中调用 <code>RPC</code> 方法。</p>
<h5 id="8-【强制】-对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"><a href="#8-【强制】-对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。" class="headerlink" title="8. 【强制】 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。"></a>8. <span style="color:brown;">【强制】</span> 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</h5><p><span style="color:sienna;">说明：</span> 线程一需要对表<code>A、B、C</code> 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 <code>A、B、C</code>，否则可能出现死锁。</p>
<p>死锁的定义：</p>
<p style="color:orangered;">
    多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源释放。由于线程被无限期地阻塞，因此程序不可能正常终止。
</p>

<h5 id="9-【强制】-在使用阻塞等待获取锁地方式中，必须在-try-代码块之外，并且在加锁方法与-try-代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在-finally-中无法解锁。"><a href="#9-【强制】-在使用阻塞等待获取锁地方式中，必须在-try-代码块之外，并且在加锁方法与-try-代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在-finally-中无法解锁。" class="headerlink" title="9. 【强制】 在使用阻塞等待获取锁地方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。"></a>9. <span style="color:brown;">【强制】</span> 在使用阻塞等待获取锁地方式中，必须在 <code>try</code> 代码块之外，并且在加锁方法与 <code>try</code> 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 <code>finally</code> 中无法解锁。</h5><p><span style="color:sienna;">说明一：</span> 如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。</p>
<p><span style="color:sienna;">说明二：</span> 如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock 对未加锁的对象加锁，它会调用 <code>AQS</code> 的 <code>tryRelease</code> 方法（取决于具体实现类），抛出 <code>IllegalMonitorStateException</code> 异常。</p>
<p><span style="color:sienna;">说明三：</span> 在 Lock 对象的 lock 方法实现中可能抛出 <code>unchecked</code> 异常，产生的后果与说明二相同。</p>
<p><span style="color:green;">正例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> XxxLock();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    doOthers();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:red;">反例：</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> XxxLock();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果此处抛出异常，则直接执行 finally 代码块</span></span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="comment">// 无论加锁是否成功，finally 代码块都会执行</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    doOthers();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-【强制】-在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。"><a href="#10-【强制】-在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。" class="headerlink" title="10. 【强制】 在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。"></a>10. <span style="color:brown;">【强制】</span> 在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。</h5><p><span style="color:sienna;">说明：</span> Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 <code>tryRelease</code> 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 <code>IllegalMonitorStateException</code> 异常。</p>
<p><span style="color:green;"> 正例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> XxxLock();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">boolean</span> isLocked = lock.tryLock();</span><br><span class="line"><span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="11-【强制】-并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。"><a href="#11-【强制】-并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用-version-作为更新依据。" class="headerlink" title="11. 【强制】 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。"></a>11. <span style="color:brown;">【强制】</span> 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 <code>version</code> 作为更新依据。</h5><p><span style="color:sienna;">说明：</span> 如果每次访问冲突概率小于 <code>20%</code>, 推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 <code>3</code> 次。</p>
<h5 id="12-【强制】-多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。"><a href="#12-【强制】-多线程并行处理定时任务时，Timer-运行多个-TimeTask-时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用-ScheduledExecutorService-则没有这个问题。" class="headerlink" title="12. 【强制】 多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。"></a>12. <span style="color:brown;">【强制】</span> 多线程并行处理定时任务时，Timer 运行多个 <code>TimeTask</code> 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 <span style="color:red;">ScheduledExecutorService</span> 则没有这个问题。</h5><h5 id="13-【推荐】-资金相关的金融敏感信息，使用悲观锁策略。"><a href="#13-【推荐】-资金相关的金融敏感信息，使用悲观锁策略。" class="headerlink" title="13.  【推荐】 资金相关的金融敏感信息，使用悲观锁策略。"></a>13.  <span style="color:gold;">【推荐】</span> 资金相关的金融敏感信息，使用悲观锁策略。</h5><p><span style="color:sienna;">说明：</span> 乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</p>
<p><span style="color:green;">正例：</span> 悲观锁遵循 <span style="color:red;">一锁、二判、三更新、四释放</span> 的原则。</p>
<h5 id="14-【推荐】-使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown-方法，线程执行代码注意-catch-异常，确保-countDown-方法被执行到，避免主线程无法执行至-await-方法，直到超时才返回结果。"><a href="#14-【推荐】-使用-CountDownLatch-进行异步转同步操作，每个线程退出前必须调用-countDown-方法，线程执行代码注意-catch-异常，确保-countDown-方法被执行到，避免主线程无法执行至-await-方法，直到超时才返回结果。" class="headerlink" title="14. 【推荐】 使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果。"></a>14. <span style="color:gold;">【推荐】</span> 使用 <code>CountDownLatch</code> 进行异步转同步操作，每个线程退出前必须调用 <code>countDown</code> 方法，线程执行代码注意 <code>catch</code> 异常，确保 <code>countDown</code> 方法被执行到，避免主线程无法执行至 <code>await</code> 方法，直到超时才返回结果。</h5><p><span style="color: sienna;">说明：</span> 注意，子线程抛出异常堆栈，不能在主线程 <code>try-catch</code> 到。</p>
<h5 id="15-【推荐】-避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一-seed-导致的性能下降。"><a href="#15-【推荐】-避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一-seed-导致的性能下降。" class="headerlink" title="15. 【推荐】 避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。"></a>15. <span style="color:gold;">【推荐】</span> 避免 <code>Random</code> 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 <code>seed</code> 导致的性能下降。</h5><p><span style="color:sienna;">说明：</span> <code>Random</code> 实例包括 <code>java.util.Random</code> 的实例或者 <code>Math.random()</code> 的方式。</p>
<p><span style="color:green;">正例：</span> 在 JDK7 之后，可以直接使用 <code>API ThreadLocalRandom</code>, 而在 JDK7 之前，需要编码保证每个线程持有一个单独的 <code>Random</code> 实例。</p>
<h5 id="16-【推荐】-通过双重检查锁（double-checked-locking）-在并发场景下-存在延迟初始化的优化问题隐患（可参考-The-quot-Double-Checked-Locking-is-Broken-quot-Declaration），推荐解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型，比如将-helper-的属性声明修改为-private-volatile-Helper-helper-null-。"><a href="#16-【推荐】-通过双重检查锁（double-checked-locking）-在并发场景下-存在延迟初始化的优化问题隐患（可参考-The-quot-Double-Checked-Locking-is-Broken-quot-Declaration），推荐解决方案中较为简单一种（适用于-JDK5-及以上版本），将目标属性声明为-volatile-型，比如将-helper-的属性声明修改为-private-volatile-Helper-helper-null-。" class="headerlink" title="16. 【推荐】 通过双重检查锁（double-checked locking）(在并发场景下) 存在延迟初始化的优化问题隐患（可参考 The &quot;Double-Checked Locking is Broken&quot; Declaration），推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型，比如将 helper 的属性声明修改为 private volatile Helper helper = null;。"></a>16. <span style="color:gold;">【推荐】</span> 通过双重检查锁（double-checked locking）(在并发场景下) 存在延迟初始化的优化问题隐患（可参考 <code>The &quot;Double-Checked Locking is Broken&quot; Declaration</code>），推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 <code>volatile</code> 型，比如将 <code>helper</code> 的属性声明修改为 <code>private volatile Helper helper = null;</code>。</h5><p><span style="color:green;">正例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other fields and methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="17-【参考】-volatile-解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。"><a href="#17-【参考】-volatile-解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。" class="headerlink" title="17. 【参考】 volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。"></a>17. <span style="color:green;">【参考】</span> <code>volatile</code> 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</h5><p><span style="color:sienna;">说明：</span> 如果是 <code>count++</code> 操作，使用如下类实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">count.addAndGet(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>如果是 <code>JDK8</code>，推荐使用 <code>LongAdder</code> 对象，比 <code>AtomicLong</code> 性能更好（减少乐观锁的重试次数）。</p>
<h5 id="18-【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。"><a href="#18-【参考】-HashMap-在容量不够进行-resize-时由于高并发可能出现死链，导致-CPU-飙升，在开发过程中注意规避此风险。" class="headerlink" title="18. 【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。"></a>18. <span style="color:green;">【参考】</span> <code>HashMap</code> 在容量不够进行 <code>resize</code> 时由于高并发可能出现死链，导致 <code>CPU</code> 飙升，在开发过程中注意规避此风险。</h5><h5 id="19-【参考】-ThreadLocal-对象使用-static-修饰，ThreadLocal-无法解决共享对象的更新问题。"><a href="#19-【参考】-ThreadLocal-对象使用-static-修饰，ThreadLocal-无法解决共享对象的更新问题。" class="headerlink" title="19. 【参考】 ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。"></a>19. <span style="color:green;">【参考】</span> <code>ThreadLocal</code> 对象使用 <code>static</code> 修饰，<code>ThreadLocal</code> 无法解决共享对象的更新问题。</h5><p><span style="color:sienna;">说明：</span> 这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所以此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操控这个变量。</p>
<h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><h5 id="1-【强制】-在一个-switch-块内，每个-case-要么通过-continue-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；在一个-switch-块内，都必须包含一个-default-语句并且放在最后，即使它什么代码也没有。"><a href="#1-【强制】-在一个-switch-块内，每个-case-要么通过-continue-break-return-等来终止，要么注释说明程序将继续执行到哪一个-case-为止；在一个-switch-块内，都必须包含一个-default-语句并且放在最后，即使它什么代码也没有。" class="headerlink" title="1. 【强制】 在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。"></a>1. <span style="color:brown;">【强制】</span> 在一个 <code>switch</code> 块内，每个 <code>case</code> 要么通过 <code>continue/break/return</code> 等来终止，要么注释说明程序将继续执行到哪一个 <code>case</code> 为止；在一个 <code>switch</code> 块内，都必须包含一个 <code>default</code> 语句并且放在最后，即使它什么代码也没有。</h5><p><span style="color:sienna;">说明：</span> 注意 <code>break</code> 是退出 <code>switch</code> 语句块，而 <code>return</code> 是退出方法体。</p>
<h5 id="2-【强制】-当-switch-括号内的变量类型为-String-并且此变量为外部参数时，必须先进行-null-判断。"><a href="#2-【强制】-当-switch-括号内的变量类型为-String-并且此变量为外部参数时，必须先进行-null-判断。" class="headerlink" title="2. 【强制】 当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null 判断。"></a>2. <span style="color:brown;">【强制】</span> 当 <code>switch</code> 括号内的变量类型为 <code>String</code> 并且此变量为外部参数时，必须先进行 <code>null</code> 判断。</h5><p><span style="color:red;">反例：</span> 如下的代码输出是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (param) &#123;</span><br><span class="line">            <span class="comment">// 肯定不是进入这里    </span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;sth&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;it&#x27;s sth&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 也不是进入这里    </span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;null&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;it&#x27;s null&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 也不是进入这里    </span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-【强制】-在-if-else-for-while-do-语句中必须使用大括号。"><a href="#3-【强制】-在-if-else-for-while-do-语句中必须使用大括号。" class="headerlink" title="3. 【强制】 在 if/else/for/while/do 语句中必须使用大括号。"></a>3. <span style="color:brown;">【强制】</span> 在 <code>if/else/for/while/do</code> 语句中必须使用大括号。</h5><p><span style="color:sienna;">说明：</span> 即使只有一行代码，也禁止不采用大括号的编码方式：<code>if (condition) statements;</code></p>
<h5 id="4-【强制】-三目运算符-condition-表达式1-表达式2-中，高度注意表达式-1-和-2-在类型对齐时，可能抛出因自动拆箱导致的-NPE-异常。"><a href="#4-【强制】-三目运算符-condition-表达式1-表达式2-中，高度注意表达式-1-和-2-在类型对齐时，可能抛出因自动拆箱导致的-NPE-异常。" class="headerlink" title="4. 【强制】 三目运算符 condition ? 表达式1 : 表达式2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE  异常。"></a>4. <span style="color:brown;">【强制】</span> 三目运算符 <code>condition ? 表达式1 : 表达式2</code> 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 <code>NPE</code>  异常。</h5><p><span style="color:sienna;">说明：</span> 以下两种场景会触发类型对齐的拆箱操作：</p>
<ol>
<li>表达式 1 或表达式 2 的值只要有一个是原始类型。</li>
<li>表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。</li>
</ol>
<p><span style="color:red;">反例：</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="keyword">null</span>;</span><br><span class="line">Boolean flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// a * b 的结果是 int 类型，那么 c 会强制拆箱成 int 类型，抛出 NPE 异常</span></span><br><span class="line">Integer result = flag ? a * b : c;</span><br></pre></td></tr></table></figure>
<h5 id="5-【强制】-在高并发场景中，避免使用-等于-判断作为中断或退出的条件。"><a href="#5-【强制】-在高并发场景中，避免使用-等于-判断作为中断或退出的条件。" class="headerlink" title="5. 【强制】 在高并发场景中，避免使用 等于 判断作为中断或退出的条件。"></a>5. <span style="color:brown;">【强制】</span> 在高并发场景中，避免使用 <code>等于</code> 判断作为中断或退出的条件。</h5><p><span style="color:sienna;">说明：</span> 如果并发控制没有处理好，容易产生等值判断被 “击穿” 的情况，使用大于或小于的区间判断条件来代替。</p>
<p><span style="color:red;">反例：</span> 判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。</p>
<h5 id="6-【推荐】-当某个方法的代码总行数超过-10-行时，return-throw-等中断逻辑的右大括号后均需要加一个空行。"><a href="#6-【推荐】-当某个方法的代码总行数超过-10-行时，return-throw-等中断逻辑的右大括号后均需要加一个空行。" class="headerlink" title="6. 【推荐】 当某个方法的代码总行数超过 10 行时，return/throw 等中断逻辑的右大括号后均需要加一个空行。"></a>6. <span style="color:orange;">【推荐】</span> 当某个方法的代码总行数超过 10 行时，<code>return/throw</code> 等中断逻辑的右大括号后均需要加一个空行。</h5><p><span style="color:sienna;">说明：</span> 这样做逻辑清晰，有利于代码阅读时重点关注。</p>
<h5 id="7-【推荐】-表达异常的分支时，少用-if-else-方式，这种方式可以改写成："><a href="#7-【推荐】-表达异常的分支时，少用-if-else-方式，这种方式可以改写成：" class="headerlink" title="7. 【推荐】 表达异常的分支时，少用 if-else 方式，这种方式可以改写成："></a>7. <span style="color:orange;">【推荐】</span> 表达异常的分支时，少用 <code>if-else</code> 方式，这种方式可以改写成：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> obj;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着写 else 的业务逻辑代码；</span></span><br></pre></td></tr></table></figure>
<p><span style="color:sienna;">说明：</span> 如果非使用 <code>if()...else if()...else ...</code> 方式表达逻辑，避免后续代码维护困难，请勿超过 3 层。</p>
<p><span style="color:green;">正例：</span> 超过 3 层的 <code>if-else</code> 的逻辑判断代码可以使用 <span style="color:red;">卫语句、策略模式、状态模式等</span> 来实现，其中 <strong>卫语句</strong> 示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findBoyfriend</span> <span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (man.isUgly()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本姑娘是外貌协会的资深会员&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (man.isPoor()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;贫贱夫妻百事哀&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (man.isBadTemper()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;银河有多远，你就给我滚多远&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;可以先交往一段时间看看&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-【推荐】-除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"><a href="#8-【推荐】-除常用方法（如-getXxx-isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。" class="headerlink" title="8. 【推荐】 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。"></a>8. <span style="color:orange;">【推荐】</span> 除常用方法（如 <code>getXxx/isXxx</code>）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</h5><p><span style="color:sienna;">说明：</span> 很多 if 语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。</p>
<p><span style="color:green;">正例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码如下</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">&quot;w&quot;</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...);</span><br><span class="line">    <span class="keyword">if</span> (existed) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:red;">反例：</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span> <span class="params">( <span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    	acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">    	selfInterrupt();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="9-【推荐】-不要在其它表达式（尤其是条件表达式）中，插入赋值语句。"><a href="#9-【推荐】-不要在其它表达式（尤其是条件表达式）中，插入赋值语句。" class="headerlink" title="9. 【推荐】 不要在其它表达式（尤其是条件表达式）中，插入赋值语句。"></a>9. <span style="color:orange;">【推荐】</span> 不要在其它表达式（尤其是条件表达式）中，插入赋值语句。</h5><p><span style="color:sienna;">说明：</span> 赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。</p>
<p><span style="color:red;">反例：</span> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lock <span class="title">getLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 算术表达式中出现赋值操作，容易忽略 count 值已经被改变</span></span><br><span class="line">    threshold = (count = Integer.MAX_VALUE) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 条件表达式中出现赋值操作，容易误认为是 sync == fair</span></span><br><span class="line">    <span class="keyword">return</span> (sync == fair) ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-【推荐】-循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，惊醒不必要的-try-catch-操作（这个-try-catch-是否可以移至循环体外）。"><a href="#10-【推荐】-循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，惊醒不必要的-try-catch-操作（这个-try-catch-是否可以移至循环体外）。" class="headerlink" title="10. 【推荐】 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，惊醒不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。"></a>10. <span style="color:orange;">【推荐】</span> 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，惊醒不必要的 <code>try-catch</code> 操作（这个 <code>try-catch</code> 是否可以移至循环体外）。</h5><h5 id="11-【推荐】-避免采用取反逻辑运算符。"><a href="#11-【推荐】-避免采用取反逻辑运算符。" class="headerlink" title="11. 【推荐】 避免采用取反逻辑运算符。"></a>11. <span style="color:orange;">【推荐】</span> 避免采用取反逻辑运算符。</h5><p><span style="color:sienna;">说明：</span> 取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。</p>
<p><span style="color:green;">正例：</span> 使用 <code>if (x &lt; 628)</code> 来表达 x 小于 628。</p>
<p><span style="color:red;">反例：</span> 使用 <code>if (!(x &gt;= 628))</code> 来表达 x 小于 628 。</p>
<h5 id="12-【推荐】-公开接口需要进行入参保护，尤其是批量操作的接口。"><a href="#12-【推荐】-公开接口需要进行入参保护，尤其是批量操作的接口。" class="headerlink" title="12. 【推荐】 公开接口需要进行入参保护，尤其是批量操作的接口。"></a>12. <span style="color:orange;">【推荐】</span> 公开接口需要进行入参保护，尤其是批量操作的接口。</h5><p><span style="color:red;">反例：</span> 某业务系统，提供一个用户批量 批量查询的接口，<code>API</code> 文档上有说最多查多少个，但接口实现上没做任何保护，导致调用方传了一个 1000 的用户 id 数组过来后，查询信息后，内存爆了。</p>
<h5 id="13-【参考】-下列情形，需要进行参数校验："><a href="#13-【参考】-下列情形，需要进行参数校验：" class="headerlink" title="13. 【参考】 下列情形，需要进行参数校验："></a>13. <span style="color:green;">【参考】</span> 下列情形，需要进行参数校验：</h5><ol>
<li>调用频次低的方法。</li>
<li>执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。</li>
<li>需要极高稳定性和可用性的方法。</li>
<li>对外提供的开放接口，不管是<code>RPC/API/HTTP</code> 接口。</li>
<li>敏感权限入口。</li>
</ol>
<h5 id="14-【参考】-下列情形中，不需要进行参数校验："><a href="#14-【参考】-下列情形中，不需要进行参数校验：" class="headerlink" title="14. 【参考】 下列情形中，不需要进行参数校验："></a>14. <span style="color:green;">【参考】</span> 下列情形中，不需要进行参数校验：</h5><ol>
<li>极有可能被循环调用的方法，但在方法说明里必须注明外部参数检查。</li>
<li>底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 <code>DAO</code> 层与 <code>Service</code> 层都在同一个应用中，部署在同一台服务器中，所以 <code>DAO</code> 的参数校验，可以省略。</li>
<li>被声明成 <code>private</code> 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li>
</ol>
<h4 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h4><h5 id="1-【强制】-类、类属性、类方法的注释必须使用-javadoc-规范，使用-内容-，不得使用-xxx-方式。"><a href="#1-【强制】-类、类属性、类方法的注释必须使用-javadoc-规范，使用-内容-，不得使用-xxx-方式。" class="headerlink" title="1. 【强制】 类、类属性、类方法的注释必须使用 javadoc 规范，使用/** 内容 */，不得使用 // xxx 方式。"></a>1. <span style="color:brown;">【强制】</span> 类、类属性、类方法的注释必须使用 <code>javadoc</code> 规范，使用<code>/** 内容 */</code>，不得使用 <code>// xxx</code> 方式。</h5><p><span style="color:sienna;">说明：</span> 在 IDE 编辑窗口中，<code>Javadoc</code> 方式会提示相关注释，生成 <code>Javadoc</code> 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p>
<h5 id="2-【强制】-所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"><a href="#2-【强制】-所有的抽象方法（包括接口中的方法）必须要用-Javadoc-注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。" class="headerlink" title="2.  【强制】 所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。"></a>2.  <span style="color:brown;">【强制】</span> 所有的抽象方法（包括接口中的方法）必须要用 <code>Javadoc</code> 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</h5><h5 id="说明：-对子类的实现要求，或者调用注意事项，请一并说明。"><a href="#说明：-对子类的实现要求，或者调用注意事项，请一并说明。" class="headerlink" title="说明： 对子类的实现要求，或者调用注意事项，请一并说明。"></a><span style="color:sienna;">说明：</span> 对子类的实现要求，或者调用注意事项，请一并说明。</h5><h5 id="3-【强制】-所有的类必须添加创建者和创建日期。"><a href="#3-【强制】-所有的类必须添加创建者和创建日期。" class="headerlink" title="3.  【强制】 所有的类必须添加创建者和创建日期。"></a>3.  <span style="color:brown;">【强制】</span> 所有的类必须添加创建者和创建日期。</h5><p> <span style="color:sienna;">说明：</span> 在设置模板时，注意 <code>IDEA</code> 的 <code>@author</code> 为 <code>$&#123;USER&#125;</code>，而 <code>eclipse</code> 的 <code>@author</code> 为 <code>$&#123;user&#125;</code>， 大小写有区别，而日期的设置统一为  <span style="color:red;">yyyy/MM/dd</span> 的格式。</p>
<p><span style="color:green;">正例：</span> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author yangguo</span><br><span class="line"> * @date 2016&#x2F;01&#x2F;31</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h5 id="4-【强制】-方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释使用-注释，注意与代码对齐。"><a href="#4-【强制】-方法内部单行注释，在被注释语句上方另起一行，使用-注释。方法内部多行注释使用-注释，注意与代码对齐。" class="headerlink" title="4. 【强制】 方法内部单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部多行注释使用 /* */ 注释，注意与代码对齐。"></a>4. <span style="color:brown;">【强制】</span> 方法内部单行注释，在被注释语句上方另起一行，使用 <code>//</code> 注释。方法内部多行注释使用 <code>/* */</code> 注释，注意与代码对齐。</h5><h5 id="5-【强制】-所有的枚举类型字段必须要有注释，说明每个数据项的用途。"><a href="#5-【强制】-所有的枚举类型字段必须要有注释，说明每个数据项的用途。" class="headerlink" title="5. 【强制】 所有的枚举类型字段必须要有注释，说明每个数据项的用途。"></a>5. <span style="color:brown;">【强制】</span> 所有的枚举类型字段必须要有注释，说明每个数据项的用途。</h5><h5 id="6-【推荐】-与其-“半吊子”-英文来注释，不如用中文注释把问题说清楚。专用名词与关键字保持英文原文即可。"><a href="#6-【推荐】-与其-“半吊子”-英文来注释，不如用中文注释把问题说清楚。专用名词与关键字保持英文原文即可。" class="headerlink" title="6.  【推荐】 与其 “半吊子” 英文来注释，不如用中文注释把问题说清楚。专用名词与关键字保持英文原文即可。"></a>6.  <span style="color:orange;">【推荐】</span> 与其 “半吊子” 英文来注释，不如用中文注释把问题说清楚。专用名词与关键字保持英文原文即可。</h5><p><span style="color:red;">反例：</span> “TCP 连接超时” 解释成 “传输控制协议连接超时”，理解反而费脑筋。</p>
<h5 id="7-【推荐】-代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"><a href="#7-【推荐】-代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。" class="headerlink" title="7. 【推荐】 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。"></a>7. <span style="color:orange;">【推荐】</span> 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</h5><p><span style="color:sienna;">说明：</span> 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就是去了导航的意义。</p>
<h5 id="8-【推荐】-在类中删除未使用的任何字段、方法、内部类；在方法中删除未使用的任何参数声明与内部变量。"><a href="#8-【推荐】-在类中删除未使用的任何字段、方法、内部类；在方法中删除未使用的任何参数声明与内部变量。" class="headerlink" title="8. 【推荐】 在类中删除未使用的任何字段、方法、内部类；在方法中删除未使用的任何参数声明与内部变量。"></a>8. <span style="color:orange;">【推荐】</span> 在类中删除未使用的任何字段、方法、内部类；在方法中删除未使用的任何参数声明与内部变量。</h5><h5 id="9-【参考】-谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。"><a href="#9-【参考】-谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。" class="headerlink" title="9. 【参考】 谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。"></a>9. <span style="color:green;">【参考】</span> 谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</h5><p><span style="color:sienna;">说明：</span> 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。</p>
<h5 id="10-【参考】-对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。"><a href="#10-【参考】-对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。" class="headerlink" title="10. 【参考】 对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。"></a>10. <span style="color:green;">【参考】</span> 对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</h5><h5 id="11-【参考】-好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。"><a href="#11-【参考】-好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。" class="headerlink" title="11. 【参考】 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。"></a>11. <span style="color:green;">【参考】</span> 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。</h5><p><span style="color:red;">反例：</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put elephant into fridge</span></span><br><span class="line">put(elephant, fridge)</span><br></pre></td></tr></table></figure>
<p>方法名 put， 加上两个有意义的变量名，<code>elephant和fridge</code>，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</p>
<h5 id="12-【参考】-特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。"><a href="#12-【参考】-特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。" class="headerlink" title="12. 【参考】 特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。"></a>12. <span style="color:green;">【参考】</span> 特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</h5><ol>
<li><p>待办事项（<span style="color:blue;">TODO</span>）：（标记人，标记时间，[预计处理时间]）</p>
<p>表示需要实现，但目前还未实现的功能。这实际上是一个 <code>Javadoc</code> 的标签，目前的 <code>Javadoc</code> 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 <code>Javadoc</code> 标签）。</p>
</li>
<li><p>错误，不能工作（<span style="color:blue;">FIXME</span>）：（标记人，标记时间，[预计处理时间]）</p>
<p>在注释中用 <code>FIXME</code> 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p>
</li>
</ol>
<h4 id="前后端规约"><a href="#前后端规约" class="headerlink" title="前后端规约"></a>前后端规约</h4><h5 id="1-【强制】-前后端交互的-API，需要明确协议、域名、路径、请求方法、状态码、响应体。"><a href="#1-【强制】-前后端交互的-API，需要明确协议、域名、路径、请求方法、状态码、响应体。" class="headerlink" title="1. 【强制】 前后端交互的 API，需要明确协议、域名、路径、请求方法、状态码、响应体。"></a>1. <span style="color:brown;">【强制】</span> 前后端交互的 <code>API</code>，需要明确协议、域名、路径、请求方法、状态码、响应体。</h5><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a><span style="color:sienna;">说明：</span></h5><ol>
<li>协议：生产环境必须使用 <code>HTTPS</code></li>
<li>路径：每一个 <code>API</code> 需对应一个路径，表示 <code>API</code> 具体的请求地址：<ol>
<li>代表一种资源，只能为名词，推荐使用复数，不能为动词，请求方法已经表达动作意义。</li>
<li><code>URL</code> 路径不能使用大写，单词如果需要分割，统一使用下划线。</li>
<li>路径禁止携带表示请求内容类型的后缀，比如 <code>.json</code>, <code>.xml</code>,通过 <code>accept</code> 头表达即可。</li>
</ol>
</li>
<li>请求方法：对具体操作的定义，常见的请求方法如下：<ol>
<li><code>GET</code> ：从服务器取出资源</li>
<li><code>POST</code>：在服务器新建一个资源</li>
<li><code>PUT</code>：在服务器更新资源</li>
<li><code>DELETE</code>：从服务器删除资源</li>
</ol>
</li>
<li>请求内容：<code>URL</code> 带的参数必须无敏感信息或符合安全要求；<code>body</code> 里带参数时必须设置 <code>Content-Type</code>。</li>
<li>响应体：响应体 <code>body</code> 可放置多种数据类型，由 <code>Content-Type</code> 头来确定。</li>
</ol>
<h5 id="2-【强制】-前后端数据列表相关的接口返回，如果为空，则返回空数组-或空集合-。"><a href="#2-【强制】-前后端数据列表相关的接口返回，如果为空，则返回空数组-或空集合-。" class="headerlink" title="2. 【强制】 前后端数据列表相关的接口返回，如果为空，则返回空数组[] 或空集合 {}。"></a>2. <span style="color:brown;">【强制】</span> 前后端数据列表相关的接口返回，如果为空，则返回空数组<code>[]</code> 或空集合 <code>&#123;&#125;</code>。</h5><p><span style="color:sienna;">说明：</span> 此条约定有利于数据层面上的协议更加高效，减少前端很多琐碎的 <code>null</code> 判断。</p>
<h5 id="3-【强制】-服务器发生错误时，返回给前端的响应信息必须包含-HTTP-状态码、errorCode、errorMessage、用户提示信息四个部分。"><a href="#3-【强制】-服务器发生错误时，返回给前端的响应信息必须包含-HTTP-状态码、errorCode、errorMessage、用户提示信息四个部分。" class="headerlink" title="3. 【强制】 服务器发生错误时，返回给前端的响应信息必须包含 HTTP 状态码、errorCode、errorMessage、用户提示信息四个部分。"></a>3. <span style="color:brown;">【强制】</span> 服务器发生错误时，返回给前端的响应信息必须包含 <code>HTTP</code> 状态码、<code>errorCode</code>、<code>errorMessage</code>、用户提示信息四个部分。</h5><p><span style="color:sienna;">说明：</span> 四个部分的涉众对象分别是浏览器、前端开发、错误排查人员、用户。其中输出给用户的提示信息要求：<span style="color:red;">简短清晰、提示友好，</span> 引导用户进行下一步操作或解释错误原因，提示信息可以包括错误原因、上下文环境、推荐操作等。<code>errorCode</code>：略。<code>errorMessage</code>：简要描述后端出错原因，便于错误排查人员快速定位问题，注意不要包含敏感数据信息。</p>
<p><span style="color:green;">正例：</span> 常见的 <code>HTTP</code> 状态码如下：</p>
<ol>
<li><code>200 OK</code>：表明该请求被成功的完成，所请求的资源发送到客户端。</li>
<li><code>401 Unauthorized</code>：请求要求身份验证，常见对于需要登录而用户未登录的情况。</li>
<li><code>403 Forbidden</code>：服务器拒绝请求，常见于机密信息或复制其它登录用户链接访问服务器的情况。</li>
<li><code>404 Not Found</code>：服务器无法取得所请求的网页，请求资源不存在。</li>
<li><code>500 Internal Server Error</code>：服务器内部错误。</li>
</ol>
<h5 id="4-【强制】-在前后端交互的-JSON-格式数据中，所有的-key-必须是小写字母开始的lowerCamelCase风格，符合英文表达习惯，且表意完整。"><a href="#4-【强制】-在前后端交互的-JSON-格式数据中，所有的-key-必须是小写字母开始的lowerCamelCase风格，符合英文表达习惯，且表意完整。" class="headerlink" title="4. 【强制】 在前后端交互的 JSON 格式数据中，所有的 key 必须是小写字母开始的lowerCamelCase风格，符合英文表达习惯，且表意完整。"></a>4. <span style="color:brown;">【强制】</span> 在前后端交互的 <code>JSON</code> 格式数据中，所有的 <code>key</code> 必须是小写字母开始的<code>lowerCamelCase</code>风格，符合英文表达习惯，且表意完整。</h5><p><span style="color:green;">正例：</span> <code>errorCode / errorMessage / assetStatus / menuList</code></p>
<p><span style="color:red;">反例：</span> <code>ERRORCODE / ERRORMESSAGE / error_message / error-message</code></p>
<h5 id="5-【强制】-errorMessage-是前后端错误追踪机制的体现，可以在前端输出到-type-quot-hidden-quot-文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。"><a href="#5-【强制】-errorMessage-是前后端错误追踪机制的体现，可以在前端输出到-type-quot-hidden-quot-文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。" class="headerlink" title="5. 【强制】 errorMessage 是前后端错误追踪机制的体现，可以在前端输出到 type=&quot;hidden&quot; 文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。"></a>5. <span style="color:brown;">【强制】</span> <code>errorMessage</code> 是前后端错误追踪机制的体现，可以在前端输出到 <code>type=&quot;hidden&quot;</code> 文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。</h5><h5 id="6-【强制】-对于需要使用超大整数的场景，服务端一律使用-String-字符串类型返回，禁止使用-Long-类型。"><a href="#6-【强制】-对于需要使用超大整数的场景，服务端一律使用-String-字符串类型返回，禁止使用-Long-类型。" class="headerlink" title="6. 【强制】 对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用 Long 类型。"></a>6. <span style="color:brown;">【强制】</span> 对于需要使用超大整数的场景，服务端一律使用 <code>String</code> 字符串类型返回，禁止使用 <code>Long</code> 类型。</h5><p><span style="color:sienna;">说明：</span> <code>Java</code> 服务端如果直接返回 <code>Long</code> 整型数据给前端，<code>JS</code> 会自动转换为 <code>Number</code> 类型（注：此类型为双精度浮点数，表示原理与取值范围等同于 <code>Java</code> 中的 <code>Double</code>）。<code>Long</code> 类型能表示的最大值为 <code>2</code> 的 <code>63</code> 次方 <code>- 1</code>，在取值范围内，超过  <code>2</code> 的 <code>53</code> 次方（9007199254740992）的数值转化为 <code>JS</code> 的 <code>Number</code> 时，有些数值会有精度损失。扩展说明，在 <code>Long</code> 取值范围内，任何 <code>2</code> 的指数次整数都是绝对不会存在精度损失的，所以说精度损失是一个概率问题。若浮点数尾数位与指数位空间不限，则可以精确表示任何整数，但很不幸，双精度浮点数的尾数位只有 <code>52</code> 位。</p>
<p><span style="color:red;">反例：</span> 通常在订单号或交易号大于等于 <code>16</code> 位，大概率会出现前后端单据不一致的情况，比如，<code>&quot;orderId: 362909601374617692&quot;</code>，前端拿到的值却是：<code>362909601374617660</code>。</p>
<h5 id="7-【强制】-HTTP-请求通过-URL-传递参数时，不能超过-2048-字节。"><a href="#7-【强制】-HTTP-请求通过-URL-传递参数时，不能超过-2048-字节。" class="headerlink" title="7. 【强制】 HTTP 请求通过 URL 传递参数时，不能超过 2048 字节。"></a>7. <span style="color:brown;">【强制】</span> <code>HTTP</code> 请求通过 <code>URL</code> 传递参数时，不能超过 <code>2048</code> 字节。</h5><p><span style="color:sienna;">说明：</span> 不同浏览器对于 <code>URL</code> 的最大长度限制略有不同，并且对超出最大长度的处理逻辑也有差异， <code>2048</code> 字节是取所有浏览器的最小值。</p>
<p><span style="color:red;">反例：</span> 某业务将退货的商品 <code>id</code> 列表放在 <code>URL</code> 中作为参数传递，当一次退货商品数量过多时，<code>URL</code> 参数超长，传递到后端的参数被截断，导致部分商品未能正确退货。</p>
<h5 id="8-【强制】-HTTP-请求通过-body-传递内容时，必须控制长度，超出最大长度后，后端解析会出错。"><a href="#8-【强制】-HTTP-请求通过-body-传递内容时，必须控制长度，超出最大长度后，后端解析会出错。" class="headerlink" title="8. 【强制】 HTTP 请求通过 body 传递内容时，必须控制长度，超出最大长度后，后端解析会出错。"></a>8. <span style="color:brown;">【强制】</span> <code>HTTP</code> 请求通过 <code>body</code> 传递内容时，必须控制长度，超出最大长度后，后端解析会出错。</h5><p><span style="color:sienna;">说明：</span> <code>nginx</code> 默认限制是 <code>1MB</code>，<code>tomcat</code> 的默认限制为 <code>2MB</code>，当确实有业务需要传较大内容时，可以通过调大服务器端的限制。</p>
<h5 id="9-【强制】-在翻页场景中，用户输入的参数小于-1，-则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。"><a href="#9-【强制】-在翻页场景中，用户输入的参数小于-1，-则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。" class="headerlink" title="9. 【强制】 在翻页场景中，用户输入的参数小于 1， 则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。"></a>9. <span style="color:brown;">【强制】</span> 在翻页场景中，用户输入的参数小于 <code>1</code>， 则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。</h5><h5 id="10-【强制】-服务器内部重定向必须使用-forward；外部重定向地址必须使用-URL-统一代理模块生成，否则会因线上采用-HTTPS-协议而导致浏览器提示-”不安全“，并且还会带来-URL-维护不一致的问题。"><a href="#10-【强制】-服务器内部重定向必须使用-forward；外部重定向地址必须使用-URL-统一代理模块生成，否则会因线上采用-HTTPS-协议而导致浏览器提示-”不安全“，并且还会带来-URL-维护不一致的问题。" class="headerlink" title="10. 【强制】 服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL 统一代理模块生成，否则会因线上采用 HTTPS 协议而导致浏览器提示 ”不安全“，并且还会带来 URL 维护不一致的问题。"></a>10. <span style="color:brown;">【强制】</span> 服务器内部重定向必须使用 <code>forward</code>；外部重定向地址必须使用 <code>URL</code> 统一代理模块生成，否则会因线上采用 <code>HTTPS</code> 协议而导致浏览器提示 ”不安全“，并且还会带来 <code>URL</code> 维护不一致的问题。</h5><h5 id="11-【推荐】-服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果。"><a href="#11-【推荐】-服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果。" class="headerlink" title="11. 【推荐】 服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果。"></a>11. <span style="color:orange;">【推荐】</span> 服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果。</h5><p><span style="color:sienna;">说明：</span> 缓存有利于减少交互次数，减少交互的平均延迟。</p>
<p><span style="color:green;">正例：</span> <code>http 1.1</code> 中，<code>s-maxage</code> 告诉服务器进行缓存，时间单位为秒，用法如下，<code>response.setHeader(&quot;Cache-Control&quot;, &quot;s-maxage=&quot; + cacheSeconds);</code></p>
<h5 id="12-【推荐】-服务器返回的数据，使用-JSON-格式而非-XML。"><a href="#12-【推荐】-服务器返回的数据，使用-JSON-格式而非-XML。" class="headerlink" title="12. 【推荐】 服务器返回的数据，使用 JSON 格式而非 XML。"></a>12. <span style="color:orange;">【推荐】</span> 服务器返回的数据，使用 <code>JSON</code> 格式而非 <code>XML</code>。</h5><p><span style="color:sienna;">说明：</span> 尽管 <code>HTTP</code> 支持使用不同的输出格式，例如纯文本，<code>JSON, CSV, XML, RSS</code> 甚至 <code>HTML</code>。如果我们使用的面向用户的服务，应该选择 <code>JSON</code> 作为通信中使用的标准数据交换格式，包括请求和响应。此外， <code>application/JSON</code> 是一种通用的 <code>MIME</code> 类型，具有实用、精简、易读的特点。</p>
<h5 id="13-【推荐】-前后端的时间格式统一为-yyyy-MM-dd-HH-mm-ss，统一为-GMT。"><a href="#13-【推荐】-前后端的时间格式统一为-yyyy-MM-dd-HH-mm-ss，统一为-GMT。" class="headerlink" title="13. 【推荐】 前后端的时间格式统一为 yyyy-MM-dd HH:mm:ss，统一为 GMT。"></a>13. <span style="color:orange;">【推荐】</span> 前后端的时间格式统一为 <code>yyyy-MM-dd HH:mm:ss</code>，统一为 <code>GMT</code>。</h5><h5 id="14-【参考】-在接口路径中不要加入版本号，版本控制在-HTTP-头信息中体现，有利于向前兼容。"><a href="#14-【参考】-在接口路径中不要加入版本号，版本控制在-HTTP-头信息中体现，有利于向前兼容。" class="headerlink" title="14. 【参考】 在接口路径中不要加入版本号，版本控制在 HTTP 头信息中体现，有利于向前兼容。"></a>14. <span style="color:green;">【参考】</span> 在接口路径中不要加入版本号，版本控制在 <code>HTTP</code> 头信息中体现，有利于向前兼容。</h5><p><span style="color:sienna;">说明：</span> 当用户在低版本和高版本之间反复切换工作时，会导致迁移复杂度升高，存在数据错乱风险。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="1-【强制】-在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"><a href="#1-【强制】-在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。" class="headerlink" title="1. 【强制】 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"></a>1. <span style="color:brown;">【强制】</span> 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</h5><p><span style="color:sienna;">说明：</span> 不要在方法体内定义：<code>Pattern pattern = Pattern.compile(&quot;规则&quot;);</code></p>
<h5 id="2-【强制】-避免用-Apache-Beanutils-进行属性的-copy。"><a href="#2-【强制】-避免用-Apache-Beanutils-进行属性的-copy。" class="headerlink" title="2. 【强制】 避免用 Apache Beanutils 进行属性的 copy。"></a>2. <span style="color:brown;">【强制】</span> 避免用 <code>Apache Beanutils</code> 进行属性的 <code>copy</code>。</h5><p><span style="color:sienna;">说明：</span> <code>Apache Beanutils</code> 性能较差，可以使用其他方案比如 <code>Spring BeanUtils, Cglib BeanCopier</code>，注意均是浅拷贝。</p>
<h5 id="3-【强制】-velocity-调用-POJO-类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用-POJO-的-getXxx-，如果是-boolean-基本数据类型变量（boolean-命名不需要加-js-前缀），会自动调用-isXxx-方法。"><a href="#3-【强制】-velocity-调用-POJO-类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用-POJO-的-getXxx-，如果是-boolean-基本数据类型变量（boolean-命名不需要加-js-前缀），会自动调用-isXxx-方法。" class="headerlink" title="3. 【强制】 velocity 调用 POJO 类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 js 前缀），会自动调用 isXxx() 方法。"></a>3. <span style="color:brown;">【强制】</span> <code>velocity</code> 调用 <code>POJO</code> 类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用 <code>POJO</code> 的 <code>getXxx()</code>，如果是 <code>boolean</code> 基本数据类型变量（boolean 命名不需要加 <code>js</code> 前缀），会自动调用 <code>isXxx()</code> 方法。</h5><p><span style="color:sienna;">说明：</span> 注意如果是 <code>Boolean</code> 包装类对象，优先调用 <code>getXxx()</code> 的方法。</p>
<h5 id="4-【强制】-后台输送给页面的变量必须加-var-——-中间的感叹号。"><a href="#4-【强制】-后台输送给页面的变量必须加-var-——-中间的感叹号。" class="headerlink" title="4. 【强制】 后台输送给页面的变量必须加 $!{var} —— 中间的感叹号。"></a>4. <span style="color:brown;">【强制】</span> 后台输送给页面的变量必须加 <code>$!&#123;var&#125;</code> —— 中间的感叹号。</h5><p><span style="color:sienna;">说明：</span> 如果 <code>var</code> 等于 <code>null</code> 或者不存在，那么 <code>$&#123;var&#125;</code> 会直接显示在页面上。</p>
<h5 id="5-【强制】-注意-Math-random-这个方法返回的是-double-类型，注意取值的范围-0-lt-x-lt-1-能够取到零值，注意除零异常-，如果想获取整数类型的随机数，不要将-x-放大-10-的若干倍然后取整，直接使用-Random-对象的-nextInt-或者-nextLong-方法。"><a href="#5-【强制】-注意-Math-random-这个方法返回的是-double-类型，注意取值的范围-0-lt-x-lt-1-能够取到零值，注意除零异常-，如果想获取整数类型的随机数，不要将-x-放大-10-的若干倍然后取整，直接使用-Random-对象的-nextInt-或者-nextLong-方法。" class="headerlink" title="5. 【强制】 注意 Math.random() 这个方法返回的是 double 类型，注意取值的范围 0 &lt;= x &lt; 1 (能够取到零值，注意除零异常)，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。"></a>5. <span style="color:brown;">【强制】</span> 注意 <code>Math.random()</code> 这个方法返回的是 <code>double</code> 类型，注意取值的范围 <code>0 &lt;= x &lt; 1</code> (能够取到<span style="color:blue;">零</span>值，注意除零异常)，如果想获取整数类型的随机数，不要将 <code>x</code> 放大 <code>10</code> 的若干倍然后取整，直接使用 <code>Random</code> 对象的 <span style="color:blue;">nextInt</span> 或者 <span style="color:blue;">nextLong</span> 方法。</h5><h5 id="6-【推荐】-不要在视图模板中加入任何复杂的逻辑。"><a href="#6-【推荐】-不要在视图模板中加入任何复杂的逻辑。" class="headerlink" title="6. 【推荐】 不要在视图模板中加入任何复杂的逻辑。"></a>6. <span style="color:orange;">【推荐】</span> 不要在视图模板中加入任何复杂的逻辑。</h5><p><span style="color:sienna;">说明：</span> 根据 <code>MVC</code> 理论，视图的职责是展示，不要抢模型和控制器的活。</p>
<h5 id="7-【推荐】-任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"><a href="#7-【推荐】-任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。" class="headerlink" title="7. 【推荐】 任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。"></a>7. <span style="color:orange;">【推荐】</span> 任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</h5><h5 id="8-【推荐】-及时清理不再使用的代码段或配置信息。"><a href="#8-【推荐】-及时清理不再使用的代码段或配置信息。" class="headerlink" title="8. 【推荐】 及时清理不再使用的代码段或配置信息。"></a>8. <span style="color:orange;">【推荐】</span> 及时清理不再使用的代码段或配置信息。</h5><p><span style="color:sienna;">说明：</span> 对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。</p>
<p><span style="color:green;">正例：</span> 对于暂时被注释掉，后续可能恢复使用的代码片段，在注释代码上方，统一规定使用三个斜杠（<code>///</code>）来说明注释掉代码的理由。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 业务方通知活动暂停</span></span><br><span class="line">    <span class="comment">// Business business = new Business();</span></span><br><span class="line">    <span class="comment">// business.active();</span></span><br><span class="line">    System.out.println(<span class="string">&quot;it&#x27;s finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router基本使用</title>
    <url>/2020/08/06/vue-router%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="从零开始简单的路由"><a href="#从零开始简单的路由" class="headerlink" title="从零开始简单的路由"></a>从零开始简单的路由</h4><blockquote>
<p>如果你只需要非常简单的路由而不想引入一个功能完整的路由库，可以像这样动态渲染一个页面级的组件。</p>
</blockquote>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;Page not found&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> Home = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;home page&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> About = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;about page&lt;/p&gt;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = &#123;</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>: Home,</span><br><span class="line">  <span class="string">&#x27;/about&#x27;</span>: About</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentRoute: <span class="built_in">window</span>.location.pathname</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ViewComponent () &#123;</span><br><span class="line">      <span class="keyword">return</span> routes[<span class="built_in">this</span>.currentRoute] || NotFound</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render (h) &#123; <span class="keyword">return</span> h(<span class="built_in">this</span>.ViewComponent) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Vue-Router基础篇"><a href="#Vue-Router基础篇" class="headerlink" title="Vue Router基础篇"></a>Vue Router基础篇</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>Vue Router是<code>vue.js</code>的官方的路由管理器。它和Vue.js的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于Vue.js过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的CSS class的链接</li>
<li>HTML5历史模式或hash模式，在ie9中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
<h5 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h5><blockquote>
<p>用 Vue.js + Vue Router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。</p>
</blockquote>
<h6 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/foo&quot;</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/bar&quot;</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义 (路由) 组件。</span></span><br><span class="line"><span class="comment">// 可以从其他文件 import 进来</span></span><br><span class="line"><span class="keyword">const</span> Foo = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;foo&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;bar&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义路由</span></span><br><span class="line"><span class="comment">// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是</span></span><br><span class="line"><span class="comment">// 通过 Vue.extend() 创建的组件构造器，</span></span><br><span class="line"><span class="comment">// 或者，只是一个组件配置对象。</span></span><br><span class="line"><span class="comment">// 我们晚点再讨论嵌套路由。</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: Foo &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/bar&#x27;</span>, <span class="attr">component</span>: Bar &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 router 实例，然后传 `routes` 配置</span></span><br><span class="line"><span class="comment">// 你还可以传别的配置参数, 不过先这么简单着吧。</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes <span class="comment">// (缩写) 相当于 routes: routes</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建和挂载根实例。</span></span><br><span class="line"><span class="comment">// 记得要通过 router 配置参数注入路由，</span></span><br><span class="line"><span class="comment">// 从而让整个应用都有路由功能</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，应用已经启动了！</span></span><br></pre></td></tr></table></figure>
<p>通过注入路由，我们可以在任何组件内通过<code>this.$router</code>来访问路由器，也可以通过<code>this.$router</code>来访问当前路由。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">username</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 我们很快就会看到 `params` 是什么</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$route.params.username</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">goBack</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.history.length &gt; <span class="number">1</span> ? <span class="built_in">this</span>.$router.go(-<span class="number">1</span>) : <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该文档通篇都常使用 <code>router</code> 实例。留意一下 <code>this.$router</code> 和 <code>router</code> 使用起来完全一样。我们使用 <code>this.$router</code> 的原因是我们并不想在每个独立需要封装路由的组件中都导入路由。</p>
</blockquote>
<h5 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h5><p>我们经常需要把某种模式匹配到所有的路由，全部映射到同一个组件。</p>
<p>例如，我们有一个<code>User</code>组件，对于所有ID各不相同的用户，都要使用这个组件来渲染。</p>
<p>那么我们可以在<code>vue-router</code>的路由路径中使用”动态路径参数”(dynamic segment)来达到这个效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;User&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在呢，像<code>/user/foo</code>和<code>user/bar</code>都将映射到相同的路径。</p>
<p>一个”路径参数”使用冒号<code>:</code>标记。当匹配到一个路由时，参数值会被设置到<code>this.$router.params</code>,可以在每个组件中使用。于是，我们可以更新<code>User</code>的模板，输出当前用户的ID。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在一个路由中设置多段”路径参数”，对应的值会被设置到<code>$router.params</code>中。例如:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配路径</th>
<th>$route.params</th>
</tr>
</thead>
<tbody>
<tr>
<td>/user/:username</td>
<td>/user/evan</td>
<td><code>&#123; username: &#39;evan&#39; &#125;</code></td>
</tr>
<tr>
<td>/user/:username/post/:post_id</td>
<td>/user/evan/post/123</td>
<td><code>&#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125;</code></td>
</tr>
</tbody>
</table>
</div>
<p><em>除了<code>$router.params</code>之外，<code>$router</code>对象还提供了其它有用的信息，例如，<code>$router.query</code>(如果URL中有查询参数)、<code>$router.hash</code>等等</em></p>
<h6 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h6><p>当使用路由参数时，例如从<code>/user/foo</code>导航到<code>/user/bar</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同一个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p>
<p>复用组件时，若想对路由参数的变化作出响应的话，可以简单的<code>watch</code>(监测变化)<code>$router</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用 <code>beforeRouterUpdate</code> <strong>导航守卫</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// react to route changes...</span></span><br><span class="line">    <span class="comment">// don&#x27;t forget to call next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="捕获所有的路由或404-Not-found-路由"><a href="#捕获所有的路由或404-Not-found-路由" class="headerlink" title="捕获所有的路由或404 Not found 路由"></a>捕获所有的路由或404 Not found 路由</h6><p>常规参数只会匹配被<code>/</code>分割的URL片段中的字符。如果想匹配<strong>任意路径</strong>，我们可以使用通配符(<code>*</code>)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 会匹配所有路径</span></span><br><span class="line">  path: <span class="string">&#x27;*&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 会匹配以 `/user-` 开头的任意路径</span></span><br><span class="line">  path: <span class="string">&#x27;/user-*&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用 <em>通配符</em> 路由时，请确保路由的顺序是正确的，也就是说含有 <em>通配符</em> 的路由应该放在 <strong>最后</strong>。</p>
<p>路由 <code>&#123;path: *&#125;</code> 通常用于客户端404错误。如果你使用了 <em>History</em> 模式，请确保 <strong>正确配置你的服务器</strong>。</p>
<p>当使用一个 <em>通配符</em> 时，<code>$router.params</code>内会自动添加一个名为 <code>pathMatch</code> 的参数。</p>
<p>它包含了URL通过 <em>通配符</em> 被匹配的部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给出一个路由 &#123; path: &#x27;/user-*&#x27; &#125;</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/user-admin&#x27;</span>)</span><br><span class="line"><span class="built_in">this</span>.$route.params.pathMatch <span class="comment">// &#x27;admin&#x27;</span></span><br><span class="line"><span class="comment">// 给出一个路由 &#123; path: &#x27;*&#x27; &#125;</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/non-existing&#x27;</span>)</span><br><span class="line"><span class="built_in">this</span>.$route.params.pathMatch <span class="comment">// &#x27;/non-existing&#x27;</span></span><br></pre></td></tr></table></figure>
<h6 id="高级匹配模式"><a href="#高级匹配模式" class="headerlink" title="高级匹配模式"></a>高级匹配模式</h6><p><code>vue-router</code> 使用 <strong>path-to-regexp</strong> 作为路径匹配引擎，所以支持很多的高级匹配模式。</p>
<p>例如：可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义的正则匹配。</p>
<h6 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h6><p>有时候同一个路径可以匹配多个路由，此时，匹配的优先级就按照 <strong>路由的定义顺序：谁先定义的，谁的优先级就高</strong>。</p>
<h5 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h5><p>实际生活中的应用界面，通常是由多层嵌套的组件组合而成的。</p>
<p>同样的，URL中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/user/foo/profile                     /user/foo/posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure>
<p>借助 <code>vue-router</code> ,使用嵌套路由配置，就可以很简单的表达这种关系。</p>
<p>看下面的栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>&lt;router-view&gt;</code>是最顶层的出口，渲染最高级路由匹配到的组件。同样的，一个被渲染组件同样可以包含自己的嵌套 <code>&lt;router-view&gt;</code>。</p>
<p>例如，在<code>User</code>组件的模板添加一个<code>&lt;router-view&gt;</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要在嵌套的出口中渲染组件，需要在<code>VueRouter</code>的参数中使用<code>children</code>配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/profile 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">&#x27;profile&#x27;</span>,</span><br><span class="line">          component: UserProfile</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">          <span class="comment">// UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">          path: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">          component: UserPosts</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>要注意，以 <code>/</code> 开头的嵌套路径会被当做根路径。这让你充分的使用嵌套组件而无须设置嵌套的路径</strong>。</p>
<p>你会发现，<code>children</code>配置就是像<code>routes</code>配置一样的路由配置数组，所以呢，你可以嵌套多层路由。</p>
<p>此时，基于上面的配置，当你访问<code>/user/foo</code>时，<code>User</code>的出口是不会渲染任何东西的，这是因为没有匹配到合适的 <em>子路由</em>。如果你想要渲染点什么的话，可以提供一个 <em>空的</em> 子路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User,</span><br><span class="line">      children: [</span><br><span class="line">        <span class="comment">// 当 /user/:id 匹配成功，</span></span><br><span class="line">        <span class="comment">// UserHome 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: UserHome &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...其他子路由</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h5><p>除了使用<code>&lt;router-link&gt;</code>创建a标签来定义导航链接，我们还可以借助router的实例方法，通过编写代码来实现。</p>
<h6 id="router-push-location-onComplete-onAbort"><a href="#router-push-location-onComplete-onAbort" class="headerlink" title="router.push(location, onComplete?, onAbort?)"></a><code>router.push(location, onComplete?, onAbort?)</code></h6><p><strong>注意：在Vue实例内部，你可以通过<code>$router</code>访问路由实例。因此你可以调用<code>this.$router.push</code></strong></p>
<p>想要导航到不同的url，则使用<code>router.push</code>方法。</p>
<p>这个方法会向history栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的URL。</p>
<p>当你点击<code>&lt;router-link&gt;</code>时，这个方法会在内部调用，所以说，点击<code>&lt;router-link to=&quot;...&quot;&gt;</code>等同于调用<code>router.push(...)</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">声明式</th>
<th style="text-align:center">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td style="text-align:center">router.push(…)</td>
</tr>
</tbody>
</table>
</div>
<p><em>该方法的参数可以是一个字符串路径，或者一个描述地址的对象</em>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">&#x27;123&#x27;</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意：如果提供了<code>path</code>，<code>params</code>会被忽略，上述例子中的<code>query</code>并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的<code>name</code>或手写完整的带有参数的<code>path</code></strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br></pre></td></tr></table></figure>
<p>同样的规则也适用于<code>router-link</code>组件的<code>to</code>属性。</p>
<blockquote>
<p>在 2.2.0+，可选的在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。在 3.1.0+，可以省略第二个和第三个参数，此时如果支持 Promise，<code>router.push</code> 或 <code>router.replace</code> 将返回一个 Promise。</p>
<p><strong>注意</strong>： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 <code>/users/1</code> -&gt; <code>/users/2</code>)，你需要使用 <a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#响应路由参数的变化"><code>beforeRouteUpdate</code></a> 来响应这个变化 (比如抓取用户信息)。</p>
</blockquote>
<h6 id="router-replace-location-onComplete-onAbort"><a href="#router-replace-location-onComplete-onAbort" class="headerlink" title="router.replace(location, onComplete?, onAbort?)"></a><code>router.replace(location, onComplete?, onAbort?)</code></h6><p>跟<code>router.push</code>很像，唯一不同的就是，它不会向history添加新记录，而是跟它的方法名一样，<strong>替换掉当前的history记录</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td><code>router.replace(...)</code></td>
</tr>
</tbody>
</table>
</div>
<h6 id="router-go-n"><a href="#router-go-n" class="headerlink" title="router.go(n)"></a><code>router.go(n)</code></h6><p>这个方法的参数是一个整数，意思是在history记录中间向前或者后退多少步，类似<code>window.hostory.go(n)</code>。</p>
<p>一个栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(-<span class="number">100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h6 id="操作-History"><a href="#操作-History" class="headerlink" title="操作 History"></a>操作 History</h6><blockquote>
<p>你也许注意到 <code>router.push</code>、 <code>router.replace</code> 和 <code>router.go</code> 跟 <a href="https://developer.mozilla.org/en-US/docs/Web/API/History"><code>window.history.pushState</code>、 <code>window.history.replaceState</code> 和 <code>window.history.go</code></a>好像， 实际上它们确实是效仿 <code>window.history</code> API 的。</p>
<p>Vue Router 的导航方法 (<code>push</code>、 <code>replace</code>、 <code>go</code>) 在各类路由模式 (<code>history</code>、 <code>hash</code> 和 <code>abstract</code>) 下表现一致。</p>
</blockquote>
<h5 id="命令路由"><a href="#命令路由" class="headerlink" title="命令路由"></a>命令路由</h5><p>有时候，通过一个名称来标识一个路由显得更方便一点，特别是在链接一个路由，或者是执行一些跳转的时候。</p>
<p>你可以在创建Router实例的时候，在<code>routes</code>配置中给某个路由设置名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/user/:userId&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">      component: User</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要链接到一个命名路由，可以给<code>router-link</code>的<code>to</code>属性传一个对象：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这跟代码调用<code>router.push()</code>是一回事：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这两种方式都会把路由导航到<code>/user/123</code>路径。</p>
<h5 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h5><p>有时候想同时(同级)展示多个视图，而不是嵌套展示，例如创建一个布局，有<code>sidebar</code>(侧导航)和<code>main</code>(主内容)两个视图，这个时候命名视图就派上用场了。</p>
<p>你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。</p>
<p>如果<code>router-view</code>没有设置名字，那么默认为<code>default</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view two&quot;</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view three&quot;</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个视图使用一个组件渲染，因此对于同一个路由，多个视图就需要多个组件。</p>
<p>确保正确使用<code>componets</code>配置(<strong>带上s</strong>):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="keyword">default</span>: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="嵌套命名视图"><a href="#嵌套命名视图" class="headerlink" title="嵌套命名视图"></a>嵌套命名视图</h6><p>我们也有可能使用命名视图创建嵌套视图的复杂布局。</p>
<p>这时你也需要命名用到的嵌套<code>router-view</code>组件。</p>
<p>我们以一个设置面板为例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/settings/emails                                       /settings/profile</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br><span class="line">| UserSettings                      |                  | UserSettings                 |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |</span><br><span class="line">| |     +-------------------------+ |                  | |     +--------------------+ |</span><br><span class="line">| |     |                         | |                  | |     | UserProfilePreview | |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Nav</code>只是一个常规组件。</li>
<li><code>UserSettings</code>是一个视图组件。</li>
<li><code>UserEmailsSubscriptions</code>、<code>UserProfile</code>、<code>UserProfilePreview</code> 是嵌套的视图组件。</li>
</ul>
<p><strong>注意：<em>我们先忘记html/css具体的布局的样子，只专注在用到的组件上</em></strong>。</p>
<p><code>UserSettings</code>组件的<code>&lt;template&gt;</code>部分应该是类似下面的这段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserSettings.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Settings<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NavBar</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;helper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后你可以使用下面的这个路由配置来完成该布局：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/settings&#x27;</span>,</span><br><span class="line">  <span class="comment">// 你也可以在顶级路由就配置命名视图</span></span><br><span class="line">  component: UserSettings,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: <span class="string">&#x27;emails&#x27;</span>,</span><br><span class="line">    component: UserEmailsSubscriptions</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: <span class="string">&#x27;profile&#x27;</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">      <span class="keyword">default</span>: UserProfile,</span><br><span class="line">      helper: UserProfilePreview</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h5><h6 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h6><p>重定向也是通过<code>routes</code>配置来完成的，</p>
<p>下面的栗子是从<code>/a</code>重定向到<code>/b</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/b&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>重定向的目标也可以是一个命名的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>甚至是一个方法，动态返回重定向目标：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意<code>导航守卫</code>并没有应用在跳转路由上，而仅仅应用在其目标上。</strong></p>
<p>一个高级的栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">const Home &#x3D; &#123; template: &#39;&lt;router-view&gt;&lt;&#x2F;router-view&gt;&#39; &#125;</span><br><span class="line">const Default &#x3D; &#123; template: &#39;&lt;div&gt;default&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line">const Foo &#x3D; &#123; template: &#39;&lt;div&gt;foo&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line">const Bar &#x3D; &#123; template: &#39;&lt;div&gt;bar&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line">const Baz &#x3D; &#123; template: &#39;&lt;div&gt;baz&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line">const WithParams &#x3D; &#123; template: &#39;&lt;div&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line">const Foobar &#x3D; &#123; template: &#39;&lt;div&gt;foobar&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line">const FooBar &#x3D; &#123; template: &#39;&lt;div&gt;FooBar&lt;&#x2F;div&gt;&#39; &#125;</span><br><span class="line"></span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  base: __dirname,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;&#39;, component: Home,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; path: &#39;&#39;, component: Default &#125;,</span><br><span class="line">        &#123; path: &#39;foo&#39;, component: Foo &#125;,</span><br><span class="line">        &#123; path: &#39;bar&#39;, component: Bar &#125;,</span><br><span class="line">        &#123; path: &#39;baz&#39;, name: &#39;baz&#39;, component: Baz &#125;,</span><br><span class="line">        &#123; path: &#39;with-params&#x2F;:id&#39;, component: WithParams &#125;,</span><br><span class="line">        &#x2F;&#x2F; relative redirect to a sibling route</span><br><span class="line">        &#123; path: &#39;relative-redirect&#39;, redirect: &#39;foo&#39; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; absolute redirect</span><br><span class="line">    &#123; path: &#39;&#x2F;absolute-redirect&#39;, redirect: &#39;&#x2F;bar&#39; &#125;,</span><br><span class="line">    &#x2F;&#x2F; dynamic redirect, note that the target route &#96;to&#96; is available for the redirect function</span><br><span class="line">    &#123; path: &#39;&#x2F;dynamic-redirect&#x2F;:id?&#39;,</span><br><span class="line">      redirect: to &#x3D;&gt; &#123;</span><br><span class="line">        const &#123; hash, params, query &#125; &#x3D; to</span><br><span class="line">        if (query.to &#x3D;&#x3D;&#x3D; &#39;foo&#39;) &#123;</span><br><span class="line">          return &#123; path: &#39;&#x2F;foo&#39;, query: null &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hash &#x3D;&#x3D;&#x3D; &#39;#baz&#39;) &#123;</span><br><span class="line">          return &#123; name: &#39;baz&#39;, hash: &#39;&#39; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (params.id) &#123;</span><br><span class="line">          return &#39;&#x2F;with-params&#x2F;:id&#39;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return &#39;&#x2F;bar&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; named redirect</span><br><span class="line">    &#123; path: &#39;&#x2F;named-redirect&#39;, redirect: &#123; name: &#39;baz&#39; &#125;&#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; redirect with params</span><br><span class="line">    &#123; path: &#39;&#x2F;redirect-with-params&#x2F;:id&#39;, redirect: &#39;&#x2F;with-params&#x2F;:id&#39; &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; redirect with caseSensitive</span><br><span class="line">    &#123; path: &#39;&#x2F;foobar&#39;, component: Foobar, caseSensitive: true &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; redirect with pathToRegexpOptions</span><br><span class="line">    &#123; path: &#39;&#x2F;FooBar&#39;, component: FooBar, pathToRegexpOptions: &#123; sensitive: true &#125;&#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; catch all redirect</span><br><span class="line">    &#123; path: &#39;*&#39;, redirect: &#39;&#x2F;&#39; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &lt;h1&gt;Redirect&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;relative-redirect&quot;&gt;</span><br><span class="line">          &#x2F;relative-redirect (redirects to &#x2F;foo)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;relative-redirect?foo&#x3D;bar&quot;&gt;</span><br><span class="line">          &#x2F;relative-redirect?foo&#x3D;bar (redirects to &#x2F;foo?foo&#x3D;bar)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;absolute-redirect&quot;&gt;</span><br><span class="line">          &#x2F;absolute-redirect (redirects to &#x2F;bar)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;dynamic-redirect&quot;&gt;</span><br><span class="line">          &#x2F;dynamic-redirect (redirects to &#x2F;bar)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;dynamic-redirect&#x2F;123&quot;&gt;</span><br><span class="line">          &#x2F;dynamic-redirect&#x2F;123 (redirects to &#x2F;with-params&#x2F;123)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;dynamic-redirect?to&#x3D;foo&quot;&gt;</span><br><span class="line">          &#x2F;dynamic-redirect?to&#x3D;foo (redirects to &#x2F;foo)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;dynamic-redirect#baz&quot;&gt;</span><br><span class="line">          &#x2F;dynamic-redirect#baz (redirects to &#x2F;baz)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;named-redirect&quot;&gt;</span><br><span class="line">          &#x2F;named-redirect (redirects to &#x2F;baz)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;redirect-with-params&#x2F;123&quot;&gt;</span><br><span class="line">          &#x2F;redirect-with-params&#x2F;123 (redirects to &#x2F;with-params&#x2F;123)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;foobar&quot;&gt;</span><br><span class="line">          &#x2F;foobar</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;FooBar&quot;&gt;</span><br><span class="line">          &#x2F;FooBar</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;not-found&quot;&gt;</span><br><span class="line">          &#x2F;not-found (redirects to &#x2F;)</span><br><span class="line">        &lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;&#x2F;ul&gt;</span><br><span class="line">      &lt;router-view class&#x3D;&quot;view&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>
<h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p>“重定向”的意思是，当用户方位<code>/a</code>时，URL将会被替换成<code>/b</code>，然后匹配路由为<code>/b</code>，那么“别名”又是什么呢？</p>
<p><strong><code>/a</code>的别名是<code>/b</code>，意味着，当用户访问<code>/b</code>时，URL会保持为<code>/b</code>，但是路由匹配则为<code>/a</code>，就像用户访问<code>/a</code>一样。</strong></p>
<p>上面对应的路由匹配为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">component</span>: A, <span class="attr">alias</span>: <span class="string">&#x27;/b&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><em>“别名”的功能让你可以自由的将UI结构映射到任意的URL，而不是受限于配置的嵌套路由结构。</em></p>
<h5 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h5><p>在组件中使用<code>$route</code>会使之与其对应路由形成高度的耦合，从而使组件只能在某些特定的URL上使用，限制其灵活性。</p>
<p><strong>使用<code>props</code>属性将组件和路由解耦</strong></p>
<ul>
<li><p>取代与<code>$route</code>的耦合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>props</code>解耦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  props: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">      components: &#123; <span class="attr">default</span>: User, <span class="attr">sidebar</span>: Sidebar &#125;,</span><br><span class="line">      props: &#123; <span class="attr">default</span>: <span class="literal">true</span>, <span class="attr">sidebar</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。</p>
</li>
</ul>
<h6 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h6><p>如果<code>props</code>被设置为<code>true</code>,<code>route.params</code>将会被设置为组件属性。</p>
<h6 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h6><p>如果<code>props</code>是一个对象，它会被按原样设置为组件属性。当<code>props</code>是静态的时候有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/promotion/from-newsletter&#x27;</span>, <span class="attr">component</span>: Promotion, <span class="attr">props</span>: &#123; <span class="attr">newsletterPopup</span>: <span class="literal">false</span> &#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h6><p>你可以创建一个函数返回<code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/search&#x27;</span>,</span><br><span class="line">      components: SearchUser,</span><br><span class="line">      props: <span class="function">(<span class="params">route</span>) =&gt;</span> (&#123;<span class="attr">query</span>: route.query.q&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>URL<code>/search?q=vue</code>会将<code>&#123;query: &#39;vue&#39;&#125;</code>作为属性传递给<code>SearchUser</code>组件。</p>
<p>请尽可能保持<code>props</code>函数为无状态的，因为它只会在路由发生变化时起作用。</p>
<p>如果你需要状态来定义<code>props</code>，请使用包装组件，这样Vue才可以对状态变化做出反应。</p>
<p>一个高级的栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">&#x27;./Hello.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dynamicPropsFn</span> (<span class="params">route</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: (now.getFullYear() + <span class="built_in">parseInt</span>(route.params.years)) + <span class="string">&#x27;!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  base: __dirname,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: Hello &#125;, <span class="comment">// No props, no nothing</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/hello/:name&#x27;</span>, <span class="attr">component</span>: Hello, <span class="attr">props</span>: <span class="literal">true</span> &#125;, <span class="comment">// Pass route.params to props</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/static&#x27;</span>, <span class="attr">component</span>: Hello, <span class="attr">props</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;world&#x27;</span> &#125;&#125;, <span class="comment">// static values</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/dynamic/:years&#x27;</span>, <span class="attr">component</span>: Hello, <span class="attr">props</span>: dynamicPropsFn &#125;, <span class="comment">// custom logic for mapping between route and props</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/attrs&#x27;</span>, <span class="attr">component</span>: Hello, <span class="attr">props</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;attrs&#x27;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Route props&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;/&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/hello/you&quot;&gt;/hello/you&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/static&quot;&gt;/static&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/dynamic/1&quot;&gt;/dynamic/1&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;router-link to=&quot;/attrs&quot;&gt;/attrs&lt;/router-link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">      &lt;router-view class=&quot;view&quot; foo=&quot;123&quot;&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="HTML5-History模式"><a href="#HTML5-History模式" class="headerlink" title="HTML5 History模式"></a>HTML5 History模式</h5><p><code>vue-route</code>默认hash模式——使用URL的hash来模拟一个完成的URL，于是当URL发生改变时，页面不会重新加载。</p>
<p>如果不想要很丑的hash，我们可以使用路由的 <strong>History模式</strong>，这种模式充分利用<code>history.pushState</code>API来完成URL跳转而无须重新加载页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当你使用history模式时，URL就像正常的url，例如<code>http://yoursite.com/user/id</code>，也好看！</p>
<p>不过这种模式要玩好，还需要后台的配置支持。因为我们的页面是一个单页面客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问<code>http://yoursite.com/user/id</code>就会报404错误，这就不好看啦！:cry:</p>
<p>所以呢，你要在服务器增加一个覆盖所有情况的 <strong>候选资源</strong>：如果URL匹配不到任何的静态资源，则应该返回同一个<code>index.html</code>页面，这个页面就是你app依赖的页面。</p>
<h6 id="后端配置栗子"><a href="#后端配置栗子" class="headerlink" title="后端配置栗子"></a>后端配置栗子</h6><p><strong>注意：下面示例假设你在根目录服务这个应用。</strong></p>
<blockquote>
<p>如果想部署到一个子目录，你需要使用 <a href="https://cli.vuejs.org/zh/config/#publicpath">Vue CLI 的 <code>publicPath</code> 选项</a> 和相关的 <a href="https://router.vuejs.org/zh/api/#base">router <code>base</code> property</a>。你还需要把下列示例中的根目录调整成为子目录 (例如用 <code>RewriteBase /name-of-your-subfolder/</code> 替换掉 <code>RewriteBase /</code>)。</p>
<h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">  RewriteEngine On</span><br><span class="line">  RewriteBase /</span><br><span class="line">  RewriteRule ^index\.html$ - [L]</span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">  RewriteRule . /index.html [L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>除了 <code>mod_rewrite</code>，你也可以使用 <a href="https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource"><code>FallbackResource</code></a>。</p>
<p>nginx</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">  <span class="attribute">try_files</span> $uri $uri/ /index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原生 Node.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> httpPort = <span class="number">80</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;index.htm&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, content</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;We cannot open &quot;index.htm&quot; file.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=utf-8&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    res.end(content)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(httpPort, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server listening on: http://localhost:%s&#x27;</span>, httpPort)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Vue-Router进阶篇"><a href="#Vue-Router进阶篇" class="headerlink" title="Vue Router进阶篇"></a>Vue Router进阶篇</h4><h5 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h5><blockquote>
<p>“导航“表示路由正在发生改变。</p>
</blockquote>
<p>正如其名，<code>vue-router</code>提供的导航守卫主要用来通过跳转或取消的方式守卫导航。</p>
<p>有多种机会植入路由导航过程中：全局的，单个路由独享的，或者组件级的。</p>
<p>记住 <strong>参数或者查询的变化并不会触发进行/离开的导航守卫。</strong></p>
<p>你可以通过 <strong>观察<code>$router</code>对象</strong> 来应对这些变化，或使用 <code>beforeRouteUpdate</code>的组件内守卫。</p>
<h6 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h6><p>你可以使用<code>route.beforeEach</code>来注册一个全局的前置守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;....&#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当一个导航触发时，全局前置守卫按照创建顺序调用。</p>
<p>守卫是异步解析执行，此时导航在所有守卫<code>reslove</code>完之前一直处于 <strong>等待中。</strong></p>
<p>每个守卫接收三个参数：</p>
<ul>
<li><code>to: Route</code>：即将要进入的目标 <strong>路由对象</strong></li>
<li><code>from: Route</code>：当前导航正要离开的路由</li>
<li><code>next: Function</code>：一定要调用该方法来<code>reslove</code>这个钩子。执行效果依赖next函数的调用参数。<ul>
<li><code>next()</code>：进入管道种的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed(确认的)。</strong></li>
<li><code>next(false)</code>：中断当前的导航。如果浏览器的URL改变了(可能是用户手动或者浏览器的后退按钮)，那么URL地址会重置到<code>from</code>路由对应的地址。</li>
<li><code>next(&#39;/&#39;)</code>或者<code>next(&#123;path: &#39;/&#39;&#125;)</code>：跳转到一个不同的地址。当前的导航被中断，然后进行一次新的导航。你可以向<code>next</code>传递任意位置的对象，且允许设置诸如<code>replace: true</code>、<code>name: &#39;home&#39;</code>之类的选项以及任何用在<code>route-link</code>的<code>to</code> <strong>prop</strong> 或<code>route.push</code>中的选项。</li>
<li><code>next(error)</code>：如果传入<code>next</code>的参数是一个<code>Error</code>实例，则导航会被终止且该错误会被传递给<code>route.onError()</code>注册过的回调。</li>
</ul>
</li>
</ul>
<p><strong>确保<code>next</code>函数在任何给定的导航守卫中都被严格的调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。</strong></p>
<p>这里有一个在用户未能验证身份时，重定向到<code>/login</code>的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) next(&#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;)</span><br><span class="line">  <span class="comment">// 如果用户未能验证身份，则 `next` 会被调用两次</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) next(&#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">else</span> next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h6><p>你可以用<code>router.beforeReslove</code>注册一个全局守卫。这和<code>router.beforeEach</code>类似，区别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后，</strong>解析守卫就会被调用。</p>
<h6 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h6><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受<code>next</code>函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h6><p>你可以在路由配置上直接定义<code>beforeEnter</code>守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这些守卫与全局前置守卫的方法参数是一样的。</p>
<h6 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h6><p>最后，你可以在路由组件内直接定义以下的路由导航守卫：</p>
<ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code></li>
<li><code>beforeRouteLeave</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>beforeRouteEnter</code>守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>
<p>不过，你可以传一个回调给<code>next</code>来访问组件实例。</p>
<p>在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过`vm`访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意<code>beforeRouteEnter</code>是支持给<code>next</code>传递回调的唯一守卫。</strong></p>
<p>对于<code>beforeRouteUpdate</code>和<code>beforeRouteLevel</code>来说，<code>this</code>已经可以用了，所以 <strong>不支持</strong> 传递回调，因为没有必要了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteUpdate (to, form, next) &#123;</span><br><span class="line">  <span class="comment">// just use `this`</span></span><br><span class="line">  <span class="built_in">this</span>.name = to.params.name</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。</p>
<p>该导航可以通过<code>next(false)</code>来取消。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteLevel (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">&#x27;Do you really want to level?you have unsaved changes!&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span>(answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h6><ol>
<li>导航被触发</li>
<li>在失活的组件里调用<code>beforeRouteLevel</code>守卫</li>
<li>调用全局的<code>beforeEach</code>守卫</li>
<li>在重用的组件里调用<code>beforeRouteUpdate</code>守卫</li>
<li>在路由配置中调用<code>beforeEnter</code></li>
<li>解析异步路由组件</li>
<li>在被激活的路由组件中调用<code>beforeRouteEnter</code></li>
<li>调用全局的<code>beforeReslove</code></li>
<li>导航被确认</li>
<li>调用全局的<code>afterEach</code>钩子</li>
<li>触发DOM更新</li>
<li>调用<code>beforeRouteEnter</code>守卫中传给<code>next</code>的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ol>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint</title>
    <url>/2020/08/21/ESLint/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。在许多方面，它和 JSLint、JSHint相似，除了少数的例外：</p>
<ul>
<li>ESLint 使用 <strong>Espree</strong> 解析 JavaScript。</li>
<li>ESLint 使用 AST 去分析代码中的模式。</li>
<li>ESLint 是完全插件化的。每一个规则都是一个插件并且你可以在运行时添加更多的规则。</li>
</ul>
<span id="more"></span>
<h4 id="配置-ESLint"><a href="#配置-ESLint" class="headerlink" title="配置 ESLint"></a>配置 ESLint</h4><p>ESLint 被设计为完全可配置的，这意味着你可以关闭每一个规则而只运行基本语法验证，或混合和匹配 ESLint 默认绑定的规则和你的自定义规则，以让 ESLint 更适合你的项目。</p>
<p>有两种主要的方式来配置 ESLint：</p>
<ol>
<li><strong>Configuration Comments</strong> - 使用 JavaScript 注释把配置信息直接嵌入到一个代码源文件中。</li>
<li><strong>Configuration Files</strong> - 使用 JavaScript、JSON 或者 YAML 文件为整个目录（除了你的主目录）和它的子目录指定配置信息。可以配置一个独立的 <code>.eslintrc.*</code> 文件，或者直接在 <code>package.json</code> 文件里的 <code>eslintConfig</code> 字段指定配置，ESLint 会查找和自动读取它们，再者，你可以在 <strong>命令行</strong> 运行时，指定一个任意的配置文件。</li>
</ol>
<p>如果你在你的主目录（通常 <code>~/</code>）有一个配置文件，ESLint 只有在无法找到其他配置文件时才使用它。</p>
<p>有很多信息可以配置：</p>
<ul>
<li><strong>Environments</strong> - 指定脚本的运行环境。每种环境都有一组特定的预定义的全局变量。</li>
<li><strong>Globals</strong> - 脚本在执行期间访问的额外的全局变量。</li>
<li><strong>Rules</strong> - 启用的规则及其各自的错误级别。</li>
</ul>
<p>所有这些选项让你可以细粒度地控制 ESLint 如何对待你的代码。</p>
<h5 id="Specifying-Parse-Options"><a href="#Specifying-Parse-Options" class="headerlink" title="Specifying Parse Options"></a>Specifying Parse Options</h5><blockquote>
<p>ESLint 允许你指定你想要支持的 JavaScript 语言选项。默认情况下，ESLint 支持 ECMAScript 5 语法。你可以覆盖该设置，以启用对 ECMAScript 其它版本和 JSX 的支持。</p>
<p>请注意，支持 JSX 语法并不等同于支持 React。React 对 ESLint 无法识别的JSX语法应用特定的语义。如果你正在使用 React 并且想要 React 语义支持，我们建议你使用 <a href="https://github.com/yannickcr/eslint-plugin-react">eslint-plugin-react</a>。</p>
<p>同样的，支持 ES6 语法并不意味着同时支持新的 ES6 全局变量或类型（比如 <code>Set</code> 等新类型）。对于 ES6 语法，使用 <code>&#123; &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 6 &#125; &#125;</code>；对于新的 ES6 全局变量，使用 <code>&#123; &quot;env&quot;:&#123; &quot;es6&quot;: true &#125; &#125;</code>. <code>&#123; &quot;env&quot;: &#123; &quot;es6&quot;: true &#125; &#125;</code> 自动启用es6语法，但 <code>&#123; &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 6 &#125; &#125;</code> 不自动启用es6全局变量。</p>
<p>解析器选项可以在 <code>.eslintrc.*</code> 文件使用 <code>parserOptions</code> 属性设置。可用的选项有：</p>
<ul>
<li><p><code>ecmaVersion</code> - 默认设置为 3，5（默认）， 你可以使用 6、7、8、9 或 10 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）或 2018（同 9）或 2019 (same as 10)</p>
</li>
<li><p><code>sourceType</code> - 设置为 <code>&quot;script&quot;</code> (默认) 或 <code>&quot;module&quot;</code>（如果你的代码是 ECMAScript 模块)。</p>
</li>
<li><p>```plaintext<br>ecmaFeatures</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  \- 这是个对象，表示你想使用的额外的语言特性:</span><br><span class="line"></span><br><span class="line">  - &#96;globalReturn&#96; - 允许在全局作用域下使用 &#96;return&#96; 语句</span><br><span class="line">  - &#96;impliedStrict&#96; - 启用全局 [strict mode](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Strict_mode) (如果 &#96;ecmaVersion&#96; 是 5 或更高)</span><br><span class="line">  - &#96;jsx&#96; - 启用 [JSX](http:&#x2F;&#x2F;facebook.github.io&#x2F;jsx&#x2F;)</span><br><span class="line">  - &#96;experimentalObjectRestSpread&#96; - 启用实验性的 [object rest&#x2F;spread properties](https:&#x2F;&#x2F;github.com&#x2F;sebmarkbage&#x2F;ecmascript-rest-spread) 支持。(**重要：**这是一个实验性的功能,在未来可能会有明显改变。 建议你写的规则 **不要** 依赖该功能，除非当它发生改变时你愿意承担维护成本。)</span><br><span class="line"></span><br><span class="line">一个 &#96;.eslintrc.json&#96; 文件的栗子：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;json</span><br><span class="line">&#123;</span><br><span class="line">   &quot;parserOptions&quot;: &#123;</span><br><span class="line">       &quot;ecmaVersion&quot;: 6,</span><br><span class="line">       &quot;sourceType&quot;: &quot;module&quot;,</span><br><span class="line">       &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">           &quot;jsx&quot;: true</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;rules&quot;: &#123;</span><br><span class="line">       &quot;semi&quot;: &quot;error&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="Specifying-Parser"><a href="#Specifying-Parser" class="headerlink" title="Specifying Parser"></a>Specifying Parser</h5><blockquote>
<p>ESLint 默认使用<a href="https://github.com/eslint/espree">Espree</a>作为其解析器，你可以在配置文件中指定一个不同的解析器，只要该解析器符合下列要求：</p>
<ol>
<li>它必须是一个 Node 模块，可以从它出现的配置文件中加载。通常，这意味着应该使用 npm 单独安装解析器包。</li>
<li>它必须符合 <a href="http://eslint.cn/docs/developer-guide/working-with-plugins#working-with-custom-parsers">parser interface</a>。</li>
</ol>
<p>注意，即使满足这些兼容性要求，也不能保证一个外部解析器可以与 ESLint 正常配合工作，ESLint 也不会修复与其它解析器不兼容的相关 bug。</p>
<p>为了表明使用该 npm 模块作为你的解析器，你需要在你的 <code>.eslintrc</code> 文件里指定 <code>parser</code> 选项。例如，下面的配置指定了 Esprima 作为解析器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;parser&quot;: &quot;esprima&quot;,</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;semi&quot;: &quot;error&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下解析器与 ESLint 兼容：</p>
<ul>
<li><a href="https://www.npmjs.com/package/esprima">Esprima</a></li>
<li><a href="https://www.npmjs.com/package/babel-eslint">Babel-ESLint</a> - 一个对<a href="https://babeljs.io/">Babel</a>解析器的包装，使其能够与 ESLint 兼容。</li>
<li><a href="https://www.npmjs.com/package/@typescript-eslint/parser">@typescript-eslint/parser</a> - 将 TypeScript 转换成与 estree 兼容的形式，以便在ESLint中使用。</li>
</ul>
<p>注意，在使用自定义解析器时，为了让 ESLint 在处理非 ECMAScript 5 特性时正常工作，配置属性 <code>parserOptions</code> 仍然是必须的。解析器会被传入 <code>parserOptions</code>，但是不一定会使用它们来决定功能特性的开关。</p>
</blockquote>
<h5 id="Specifying-Processor"><a href="#Specifying-Processor" class="headerlink" title="Specifying Processor"></a>Specifying Processor</h5><blockquote>
<p>插件可以提供处理器。处理器可以从另一种文件中提取 JavaScript 代码，然后让 ESLint 检测 JavaScript 代码。或者处理器可以在预处理中转换 JavaScript 代码。</p>
<p>若要在配置文件中指定处理器，请使用 <code>processor</code> 键，并使用由插件名和处理器名组成的串接字符串加上斜杠。例如，下面的选项启用插件 <code>a-plugin</code> 提供的处理器 <code>a-processor</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [&quot;a-plugin&quot;],</span><br><span class="line">    &quot;processor&quot;: &quot;a-plugin&#x2F;a-processor&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为特定类型的文件指定处理器，请使用 <code>overrides</code> 键和 <code>processor</code> 键的组合。例如，下面对 <code>*.md</code> 文件使用处理器 <code>a-plugin/markdown</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [&quot;a-plugin&quot;],</span><br><span class="line">    &quot;overrides&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;files&quot;: [&quot;*.md&quot;],</span><br><span class="line">            &quot;processor&quot;: &quot;a-plugin&#x2F;markdown&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理器可以生成命名的代码块，如 <code>0.js</code> 和 <code>1.js</code>。ESLint 将这样的命名代码块作为原始文件的子文件处理。你可以在配置的 <code>overrides</code> 部分为已命名的代码块指定附加配置。例如，下面的命令对以 <code>.js</code> 结尾的 markdown 文件中的已命名代码块禁用 <code>strict</code> 规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [&quot;a-plugin&quot;],</span><br><span class="line">    &quot;overrides&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;files&quot;: [&quot;*.md&quot;],</span><br><span class="line">            &quot;processor&quot;: &quot;a-plugin&#x2F;markdown&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;files&quot;: [&quot;**&#x2F;*.md&#x2F;*.js&quot;],</span><br><span class="line">            &quot;rules&quot;: &#123;</span><br><span class="line">                &quot;strict&quot;: &quot;off&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ESLint 检查指定代码块的文件扩展名，如果 <a href="http://eslint.cn/docs/user-guide/command-line-interface#--ext"><code>--ext</code> CLI option</a> 不包含文件扩展名，则忽略这些扩展名。如果您想要删除除 <code>*.js</code> 之外的已命名代码块，请确保指定 <code>--ext</code> 选项。</p>
</blockquote>
<h5 id="Specifying-Environments"><a href="#Specifying-Environments" class="headerlink" title="Specifying Environments"></a>Specifying Environments</h5><blockquote>
<p>一个环境定义了一组预定义的全局变量。可用的环境包括：</p>
<ul>
<li><code>browser</code> - 浏览器环境中的全局变量。</li>
<li><code>node</code> - Node.js 全局变量和 Node.js 作用域。</li>
<li><code>commonjs</code> - CommonJS 全局变量和 CommonJS 作用域 (用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。</li>
<li><code>shared-node-browser</code> - Node.js 和 Browser 通用全局变量。</li>
<li><code>es6</code> - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 <code>ecmaVersion</code> 解析器选项为 6）。</li>
<li><code>worker</code> - Web Workers 全局变量。</li>
<li><code>amd</code> - 将 <code>require()</code> 和 <code>define()</code> 定义为像 <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">amd</a> 一样的全局变量。</li>
<li><code>mocha</code> - 添加所有的 Mocha 测试全局变量。</li>
<li><code>jasmine</code> - 添加所有的 Jasmine 版本 1.3 和 2.0 的测试全局变量。</li>
<li><code>jest</code> - Jest 全局变量。</li>
<li><code>phantomjs</code> - PhantomJS 全局变量。</li>
<li><code>protractor</code> - Protractor 全局变量。</li>
<li><code>qunit</code> - QUnit 全局变量。</li>
<li><code>jquery</code> - jQuery 全局变量。</li>
<li><code>prototypejs</code> - Prototype.js 全局变量。</li>
<li><code>shelljs</code> - ShellJS 全局变量。</li>
<li><code>meteor</code> - Meteor 全局变量。</li>
<li><code>mongo</code> - MongoDB 全局变量。</li>
<li><code>applescript</code> - AppleScript 全局变量。</li>
<li><code>nashorn</code> - Java 8 Nashorn 全局变量。</li>
<li><code>serviceworker</code> - Service Worker 全局变量。</li>
<li><code>atomtest</code> - Atom 测试全局变量。</li>
<li><code>embertest</code> - Ember 测试全局变量。</li>
<li><code>webextensions</code> - WebExtensions 全局变量。</li>
<li><code>greasemonkey</code> - GreaseMonkey 全局变量。</li>
</ul>
<p>这些环境并不是互斥的，所以你可以同时定义多个。</p>
<p>可以在源文件里、在配置文件中或使用 <a href="http://eslint.cn/docs/user-guide/command-line-interface">命令行</a> 的 <code>--env</code> 选项来指定环境。</p>
<p>要在你的 JavaScript 文件中使用注释来指定环境，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-env node, mocha *&#x2F;</span><br></pre></td></tr></table></figure>
<p>该设置启用了 Node.js 和 Mocha 环境。</p>
<p>要在配置文件里指定环境，使用 <code>env</code> 关键字指定你想启用的环境，并设置它们为 <code>true</code>。例如，以下示例启用了 browser 和 Node.js 的环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;node&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或在 <code>package.json</code> 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;mypackage&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">    &quot;eslintConfig&quot;: &#123;</span><br><span class="line">        &quot;env&quot;: &#123;</span><br><span class="line">            &quot;browser&quot;: true,</span><br><span class="line">            &quot;node&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">  env:</span><br><span class="line">    browser: true</span><br><span class="line">    node: true</span><br></pre></td></tr></table></figure>
<p>如果你想在一个特定的插件中使用一种环境，确保提前在 <code>plugins</code> 数组里指定了插件名，然后在 env 配置中不带前缀的插件名后跟一个 <code>/</code> ，紧随着环境名。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [&quot;example&quot;],</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;example&#x2F;custom&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或在 <code>package.json</code> 文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;mypackage&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">    &quot;eslintConfig&quot;: &#123;</span><br><span class="line">        &quot;plugins&quot;: [&quot;example&quot;],</span><br><span class="line">        &quot;env&quot;: &#123;</span><br><span class="line">            &quot;example&#x2F;custom&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 文件中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">example/custom:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Specifying-Globals"><a href="#Specifying-Globals" class="headerlink" title="Specifying Globals"></a>Specifying Globals</h5><blockquote>
<p>当访问当前源文件内未定义的变量时，<a href="http://eslint.cn/docs/rules/no-undef">no-undef</a> 规则将发出警告。如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。</p>
<p>要在你的 JavaScript 文件中，用注释指定全局变量，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* global var1, var2 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>这定义了两个全局变量，<code>var1</code> 和 <code>var2</code>。如果你想选择性地指定这些全局变量可以被写入(而不是只被读取)，那么你可以用一个 <code>&quot;writable&quot;</code> 的标志来设置它们:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* global var1:writable, var2:writable *&#x2F;</span><br></pre></td></tr></table></figure>
<p>要在配置文件中配置全局变量，请将 <code>globals</code> 配置属性设置为一个对象，该对象包含以你希望使用的每个全局变量。对于每个全局变量键，将对应的值设置为 <code>&quot;writable&quot;</code> 以允许重写变量，或 <code>&quot;readonly&quot;</code> 不允许重写变量。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;globals&quot;: &#123;</span><br><span class="line">        &quot;var1&quot;: &quot;writable&quot;,</span><br><span class="line">        &quot;var2&quot;: &quot;readonly&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">  globals:</span><br><span class="line">    var1: writable</span><br><span class="line">    var2: readonly</span><br></pre></td></tr></table></figure>
<p>在这些例子中 <code>var1</code> 允许被重写，<code>var2</code> 不允许被重写。</p>
<p>可以使用字符串 <code>&quot;off&quot;</code> 禁用全局变量。例如，在大多数 ES2015 全局变量可用但 <code>Promise</code> 不可用的环境中，你可以使用以下配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;es6&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;globals&quot;: &#123;</span><br><span class="line">        &quot;Promise&quot;: &quot;off&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于历史原因，布尔值 <code>false</code> 和字符串值 <code>&quot;readable&quot;</code> 等价于 <code>&quot;readonly&quot;</code>。类似地，布尔值 <code>true</code> 和字符串值 <code>&quot;writeable&quot;</code> 等价于 <code>&quot;writable&quot;</code>。但是，不建议使用旧值。</p>
<p><strong>注意：</strong>要启用<a href="http://eslint.cn/docs/rules/no-global-assign">no-global-assign</a>规则来禁止对只读的全局变量进行修改。</p>
</blockquote>
<h5 id="Configuring-Plugins"><a href="#Configuring-Plugins" class="headerlink" title="Configuring Plugins"></a>Configuring Plugins</h5><blockquote>
<p>ESLint 支持使用第三方插件。在使用插件之前，你必须使用 npm 安装它。</p>
<p>在配置文件里配置插件时，可以使用 <code>plugins</code> 关键字来存放插件名字的列表。插件名称可以省略 <code>eslint-plugin-</code> 前缀。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;plugin1&quot;,</span><br><span class="line">        &quot;eslint-plugin-plugin2&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">  plugins:</span><br><span class="line">    - plugin1</span><br><span class="line">    - eslint-plugin-plugin2</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>插件是相对于 ESLint 进程的当前工作目录解析的。换句话说，ESLint 将加载与用户通过从项目 Node 交互解释器运行 <code>(&#39;eslint-plugin-pluginname&#39;)</code> 获得的相同的插件。</p>
</blockquote>
<h5 id="Configuring-Rules"><a href="#Configuring-Rules" class="headerlink" title="Configuring Rules"></a>Configuring Rules</h5><blockquote>
<p>ESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用的规则。要改变一个规则设置，你必须将规则 ID 设置为下列值之一：</p>
<ul>
<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>
<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出)</li>
<li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出)</li>
</ul>
<h3 id="Using-Configuration-Comments"><a href="#Using-Configuration-Comments" class="headerlink" title="Using Configuration Comments"></a>Using Configuration Comments</h3><p>为了在文件注释里配置规则，使用以下格式的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; *&#x2F;</span><br></pre></td></tr></table></figure>
<p>在这个例子里，<a href="http://eslint.cn/docs/rules/eqeqeq"><code>eqeqeq</code></a> 规则被关闭，<a href="http://eslint.cn/docs/rules/curly"><code>curly</code></a> 规则被打开，定义为错误级别。你也可以使用对应的数字定义规则严重程度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint eqeqeq: 0, curly: 2 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>这个例子和上个例子是一样的，只不过它是用的数字而不是字符串。<code>eqeqeq</code> 规则是关闭的，<code>curly</code> 规则被设置为错误级别。</p>
<p>如果一个规则有额外的选项，你可以使用数组字面量指定它们，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint quotes: [&quot;error&quot;, &quot;double&quot;], curly: 2 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>这条注释为规则 <a href="http://eslint.cn/docs/rules/quotes"><code>quotes</code></a> 指定了 “double”选项。数组的第一项总是规则的严重程度（数字或字符串）。</p>
<h3 id="Using-Configuration-Files"><a href="#Using-Configuration-Files" class="headerlink" title="Using Configuration Files"></a>Using Configuration Files</h3><p>还可以使用 <code>rules</code> 连同错误级别和任何你想使用的选项，在配置文件中进行规则配置。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;eqeqeq&quot;: &quot;off&quot;,</span><br><span class="line">        &quot;curly&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">rules:</span><br><span class="line">  eqeqeq: off</span><br><span class="line">  curly: error</span><br><span class="line">  quotes:</span><br><span class="line">    - error</span><br><span class="line">    - double</span><br></pre></td></tr></table></figure>
<p>配置定义在插件中的一个规则的时候，你必须使用 <code>插件名/规则ID</code> 的形式。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;plugin1&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;eqeqeq&quot;: &quot;off&quot;,</span><br><span class="line">        &quot;curly&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],</span><br><span class="line">        &quot;plugin1&#x2F;rule1&quot;: &quot;error&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">plugins:</span><br><span class="line">  - plugin1</span><br><span class="line">rules:</span><br><span class="line">  eqeqeq: 0</span><br><span class="line">  curly: error</span><br><span class="line">  quotes:</span><br><span class="line">    - error</span><br><span class="line">    - &quot;double&quot;</span><br><span class="line">  plugin1&#x2F;rule1: error</span><br></pre></td></tr></table></figure>
<p>在这些配置文件中，规则 <code>plugin1/rule1</code> 表示来自插件 <code>plugin1</code> 的 <code>rule1</code> 规则。你也可以使用这种格式的注释配置，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint &quot;plugin1&#x2F;rule1&quot;: &quot;error&quot; *&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>当指定来自插件的规则时，确保删除 <code>eslint-plugin-</code> 前缀。ESLint 在内部只使用没有前缀的名称去定位规则。</p>
<h2 id="Disabling-Rules-with-Inline-Comments"><a href="#Disabling-Rules-with-Inline-Comments" class="headerlink" title="Disabling Rules with Inline Comments"></a>Disabling Rules with Inline Comments</h2><p>可以在你的文件中使用以下格式的块注释来临时禁止规则出现警告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable *&#x2F;</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-enable *&#x2F;</span><br></pre></td></tr></table></figure>
<p>你也可以对指定的规则启用或禁用警告:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable no-alert, no-console *&#x2F;</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line">console.log(&#39;bar&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-enable no-alert, no-console *&#x2F;</span><br></pre></td></tr></table></figure>
<p>如果在整个文件范围内禁止规则出现警告，将 <code>/* eslint-disable */</code> 块注释放在文件顶部：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable *&#x2F;</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>
<p>你也可以对整个文件启用或禁用警告:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable no-alert *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Disables no-alert for the rest of the file</span><br><span class="line">alert(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>
<p>可以在你的文件中使用以下格式的行注释或块注释在某一特定的行上禁用所有规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(&#39;foo&#39;); &#x2F;&#x2F; eslint-disable-line</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eslint-disable-next-line</span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable-next-line *&#x2F;</span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;); &#x2F;* eslint-disable-line *&#x2F;</span><br></pre></td></tr></table></figure>
<p>在某一特定的行上禁用某个指定的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(&#39;foo&#39;); &#x2F;&#x2F; eslint-disable-line no-alert</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eslint-disable-next-line no-alert</span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;); &#x2F;* eslint-disable-line no-alert *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable-next-line no-alert *&#x2F;</span><br><span class="line">alert(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>
<p>在某个特定的行上禁用多个规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(&#39;foo&#39;); &#x2F;&#x2F; eslint-disable-line no-alert, quotes, semi</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eslint-disable-next-line no-alert, quotes, semi</span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;); &#x2F;* eslint-disable-line no-alert, quotes, semi *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable-next-line no-alert, quotes, semi *&#x2F;</span><br><span class="line">alert(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>
<p>上面的所有方法同样适用于插件规则。例如，禁止 <code>eslint-plugin-example</code> 的 <code>rule-name</code> 规则，把插件名（<code>example</code>）和规则名（<code>rule-name</code>）结合为 <code>example/rule-name</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo(); &#x2F;&#x2F; eslint-disable-line example&#x2F;rule-name</span><br><span class="line">foo(); &#x2F;* eslint-disable-line example&#x2F;rule-name *&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>为文件的某部分禁用警告的注释，告诉 ESLint 不要对禁用的代码报告规则的冲突。ESLint 仍解析整个文件，然而，禁用的代码仍需要是有效的 JavaScript 语法。</p>
<h3 id="Disabling-Rules-Only-for-a-Group-of-Files"><a href="#Disabling-Rules-Only-for-a-Group-of-Files" class="headerlink" title="Disabling Rules Only for a Group of Files"></a>Disabling Rules Only for a Group of Files</h3><p>若要禁用一组文件的配置文件中的规则，请使用 <code>overrides</code> 和 <code>files</code>。例如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;...&#125;,</span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;*-test.js&quot;</span>,<span class="string">&quot;*.spec.js&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;no-unused-expressions&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Adding-Shared-Settings"><a href="#Adding-Shared-Settings" class="headerlink" title="Adding Shared Settings"></a>Adding Shared Settings</h5><blockquote>
<p>ESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用的规则。要改变一个规则设置，你必须将规则 ID 设置为下列值之一：</p>
<ul>
<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>
<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出)</li>
<li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出)</li>
</ul>
<h3 id="Using-Configuration-Comments-1"><a href="#Using-Configuration-Comments-1" class="headerlink" title="Using Configuration Comments"></a>Using Configuration Comments</h3><p>为了在文件注释里配置规则，使用以下格式的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; *&#x2F;</span><br></pre></td></tr></table></figure>
<p>在这个例子里，<a href="http://eslint.cn/docs/rules/eqeqeq"><code>eqeqeq</code></a> 规则被关闭，<a href="http://eslint.cn/docs/rules/curly"><code>curly</code></a> 规则被打开，定义为错误级别。你也可以使用对应的数字定义规则严重程度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint eqeqeq: 0, curly: 2 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>这个例子和上个例子是一样的，只不过它是用的数字而不是字符串。<code>eqeqeq</code> 规则是关闭的，<code>curly</code> 规则被设置为错误级别。</p>
<p>如果一个规则有额外的选项，你可以使用数组字面量指定它们，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint quotes: [&quot;error&quot;, &quot;double&quot;], curly: 2 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>这条注释为规则 <a href="http://eslint.cn/docs/rules/quotes"><code>quotes</code></a> 指定了 “double”选项。数组的第一项总是规则的严重程度（数字或字符串）。</p>
<h3 id="Using-Configuration-Files-1"><a href="#Using-Configuration-Files-1" class="headerlink" title="Using Configuration Files"></a>Using Configuration Files</h3><p>还可以使用 <code>rules</code> 连同错误级别和任何你想使用的选项，在配置文件中进行规则配置。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;eqeqeq&quot;: &quot;off&quot;,</span><br><span class="line">        &quot;curly&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">rules:</span><br><span class="line">  eqeqeq: off</span><br><span class="line">  curly: error</span><br><span class="line">  quotes:</span><br><span class="line">    - error</span><br><span class="line">    - double</span><br></pre></td></tr></table></figure>
<p>配置定义在插件中的一个规则的时候，你必须使用 <code>插件名/规则ID</code> 的形式。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;plugin1&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;eqeqeq&quot;: &quot;off&quot;,</span><br><span class="line">        &quot;curly&quot;: &quot;error&quot;,</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],</span><br><span class="line">        &quot;plugin1&#x2F;rule1&quot;: &quot;error&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">plugins:</span><br><span class="line">  - plugin1</span><br><span class="line">rules:</span><br><span class="line">  eqeqeq: 0</span><br><span class="line">  curly: error</span><br><span class="line">  quotes:</span><br><span class="line">    - error</span><br><span class="line">    - &quot;double&quot;</span><br><span class="line">  plugin1&#x2F;rule1: error</span><br></pre></td></tr></table></figure>
<p>在这些配置文件中，规则 <code>plugin1/rule1</code> 表示来自插件 <code>plugin1</code> 的 <code>rule1</code> 规则。你也可以使用这种格式的注释配置，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint &quot;plugin1&#x2F;rule1&quot;: &quot;error&quot; *&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>当指定来自插件的规则时，确保删除 <code>eslint-plugin-</code> 前缀。ESLint 在内部只使用没有前缀的名称去定位规则。</p>
<h2 id="Disabling-Rules-with-Inline-Comments-1"><a href="#Disabling-Rules-with-Inline-Comments-1" class="headerlink" title="Disabling Rules with Inline Comments"></a>Disabling Rules with Inline Comments</h2><p>可以在你的文件中使用以下格式的块注释来临时禁止规则出现警告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable *&#x2F;</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-enable *&#x2F;</span><br></pre></td></tr></table></figure>
<p>你也可以对指定的规则启用或禁用警告:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable no-alert, no-console *&#x2F;</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line">console.log(&#39;bar&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-enable no-alert, no-console *&#x2F;</span><br></pre></td></tr></table></figure>
<p>如果在整个文件范围内禁止规则出现警告，将 <code>/* eslint-disable */</code> 块注释放在文件顶部：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable *&#x2F;</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>
<p>你也可以对整个文件启用或禁用警告:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* eslint-disable no-alert *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Disables no-alert for the rest of the file</span><br><span class="line">alert(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>
<p>可以在你的文件中使用以下格式的行注释或块注释在某一特定的行上禁用所有规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(&#39;foo&#39;); &#x2F;&#x2F; eslint-disable-line</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eslint-disable-next-line</span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable-next-line *&#x2F;</span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;); &#x2F;* eslint-disable-line *&#x2F;</span><br></pre></td></tr></table></figure>
<p>在某一特定的行上禁用某个指定的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(&#39;foo&#39;); &#x2F;&#x2F; eslint-disable-line no-alert</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eslint-disable-next-line no-alert</span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;); &#x2F;* eslint-disable-line no-alert *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable-next-line no-alert *&#x2F;</span><br><span class="line">alert(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>
<p>在某个特定的行上禁用多个规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(&#39;foo&#39;); &#x2F;&#x2F; eslint-disable-line no-alert, quotes, semi</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; eslint-disable-next-line no-alert, quotes, semi</span><br><span class="line">alert(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">alert(&#39;foo&#39;); &#x2F;* eslint-disable-line no-alert, quotes, semi *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable-next-line no-alert, quotes, semi *&#x2F;</span><br><span class="line">alert(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>
<p>上面的所有方法同样适用于插件规则。例如，禁止 <code>eslint-plugin-example</code> 的 <code>rule-name</code> 规则，把插件名（<code>example</code>）和规则名（<code>rule-name</code>）结合为 <code>example/rule-name</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo(); &#x2F;&#x2F; eslint-disable-line example&#x2F;rule-name</span><br><span class="line">foo(); &#x2F;* eslint-disable-line example&#x2F;rule-name *&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>为文件的某部分禁用警告的注释，告诉 ESLint 不要对禁用的代码报告规则的冲突。ESLint 仍解析整个文件，然而，禁用的代码仍需要是有效的 JavaScript 语法。</p>
<h3 id="Disabling-Rules-Only-for-a-Group-of-Files-1"><a href="#Disabling-Rules-Only-for-a-Group-of-Files-1" class="headerlink" title="Disabling Rules Only for a Group of Files"></a>Disabling Rules Only for a Group of Files</h3><p>若要禁用一组文件的配置文件中的规则，请使用 <code>overrides</code> 和 <code>files</code>。例如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;...&#125;,</span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;*-test.js&quot;</span>,<span class="string">&quot;*.spec.js&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;no-unused-expressions&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Adding-Shared-Settings-1"><a href="#Adding-Shared-Settings-1" class="headerlink" title="Adding Shared Settings"></a>Adding Shared Settings</h5><blockquote>
<p>ESLint 支持在配置文件添加共享设置。你可以添加 <code>settings</code> 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置。</p>
<p>在 JSON 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;sharedData&quot;: &quot;Hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line">  <span class="attr">settings:</span></span><br><span class="line">    <span class="attr">sharedData:</span> <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Using-Configuration-Files-2"><a href="#Using-Configuration-Files-2" class="headerlink" title="Using Configuration Files"></a>Using Configuration Files</h2><p>有两种方式使用配置文件。</p>
<p>使用配置文件的第一种方式是通过 <code>.eslintrc.*</code> 和 <code>package.json</code> 文件。ESLint 将自动在要检测的文件目录里寻找它们，紧接着是父级目录，一直到文件系统的根目录（除非指定 <code>root: true</code>）。当你想对一个项目的不同部分的使用不同配置，或当你希望别人能够直接使用 ESLint，而无需记住要在配置文件中传递什么，这种方式就很有用。</p>
<p>第二种方式是使用 <code>-c</code> 选项传递命令行将文件保持到你喜欢的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint -c myconfig.json myfiletotest.js</span><br></pre></td></tr></table></figure>
<p>如果你使用一个配置文件，想要 ESLint 忽略任何 <code>.eslintrc.*</code> 文件，请确保使用 <code>--no-eslintrc</code> 的同时，加上 <code>-c</code> 标记。</p>
<p>每种情况，配置文件都会覆盖默认设置。</p>
<h2 id="Configuration-File-Formats"><a href="#Configuration-File-Formats" class="headerlink" title="Configuration File Formats"></a>Configuration File Formats</h2><p>ESLint 支持几种格式的配置文件：</p>
<ul>
<li><strong>JavaScript</strong> - 使用 <code>.eslintrc.js</code> 然后输出一个配置对象。</li>
<li><strong>YAML</strong> - 使用 <code>.eslintrc.yaml</code> 或 <code>.eslintrc.yml</code> 去定义配置的结构。</li>
<li><strong>JSON</strong> - 使用 <code>.eslintrc.json</code> 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。</li>
<li><strong>(弃用)</strong> - 使用 <code>.eslintrc</code>，可以使 JSON 也可以是 YAML。</li>
<li><strong>package.json</strong> - 在 <code>package.json</code> 里创建一个 <code>eslintConfig</code>属性，在那里定义你的配置。</li>
</ul>
<p>如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：</p>
<ol>
<li><code>.eslintrc.js</code></li>
<li><code>.eslintrc.yaml</code></li>
<li><code>.eslintrc.yml</code></li>
<li><code>.eslintrc.json</code></li>
<li><code>.eslintrc</code></li>
<li><code>package.json</code></li>
</ol>
<h2 id="Configuration-Cascading-and-Hierarchy"><a href="#Configuration-Cascading-and-Hierarchy" class="headerlink" title="Configuration Cascading and Hierarchy"></a>Configuration Cascading and Hierarchy</h2><p>当使用 <code>.eslintrc.*</code> 和 <code>package.json</code>文件的配置时，你可以利用层叠配置。例如，假如你有以下结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your-project</span><br><span class="line">├── .eslintrc</span><br><span class="line">├── lib</span><br><span class="line">│ └── source.js</span><br><span class="line">└─┬ tests</span><br><span class="line">  ├── .eslintrc</span><br><span class="line">  └── test.js</span><br></pre></td></tr></table></figure>
<p>层叠配置使用离要检测的文件最近的 <code>.eslintrc</code>文件作为最高优先级，然后才是父目录里的配置文件，等等。当你在这个项目中允许 ESLint 时，<code>lib/</code> 下面的所有文件将使用项目根目录里的 <code>.eslintrc</code> 文件作为它的配置文件。当 ESLint 遍历到 <code>test/</code> 目录，<code>your-project/.eslintrc</code> 之外，它还会用到 <code>your-project/tests/.eslintrc</code>。所以 <code>your-project/tests/test.js</code> 是基于它的目录层次结构中的两个<code>.eslintrc</code> 文件的组合，并且离的最近的一个优先。通过这种方式，你可以有项目级 ESLint 设置，也有覆盖特定目录的 ESLint 设置。</p>
<p>同样的，如果在根目录的 <code>package.json</code> 文件中有一个 <code>eslintConfig</code> 字段，其中的配置将使用于所有子目录，但是当 <code>tests</code> 目录下的 <code>.eslintrc</code> 文件中的规则与之发生冲突时，就会覆盖它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">your-project</span><br><span class="line">├── package.json</span><br><span class="line">├── lib</span><br><span class="line">│ └── source.js</span><br><span class="line">└─┬ tests</span><br><span class="line">  ├── .eslintrc</span><br><span class="line">  └── test.js</span><br></pre></td></tr></table></figure>
<p>如果同一目录下 <code>.eslintrc</code> 和 <code>package.json</code> 同时存在，<code>.eslintrc</code> 优先级高会被使用，<code>package.json</code> 文件将不会被使用。</p>
<p><strong>注意：</strong>如果在你的主目录下有一个自定义的配置文件 (<code>~/.eslintrc</code>) ，如果没有其它配置文件时它才会被使用。因为个人配置将适用于用户目录下的所有目录和文件，包括第三方的代码，当 ESLint 运行时可能会导致问题。</p>
<p>默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 <code>package.json</code> 文件或者 <code>.eslintrc.*</code> 文件里的 <code>eslintConfig</code> 字段下设置 <code>&quot;root&quot;: true</code>。ESLint 一旦发现配置文件中有 <code>&quot;root&quot;: true</code>，它就会停止在父级目录中寻找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;root&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 YAML 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">  root: true</span><br></pre></td></tr></table></figure>
<p>例如，<code>projectA</code> 的 <code>lib/</code> 目录下的 <code>.eslintrc</code> 文件中设置了 <code>&quot;root&quot;: true</code>。这种情况下，当检测 <code>main.js</code> 时，<code>lib/</code> 下的配置将会被使用，<code>projectA/</code> 下的 <code>.eslintrc</code> 将不会被使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">home</span><br><span class="line">└── user</span><br><span class="line">    ├── .eslintrc &lt;- Always skipped if other configs present</span><br><span class="line">    └── projectA</span><br><span class="line">        ├── .eslintrc  &lt;- Not used</span><br><span class="line">        └── lib</span><br><span class="line">            ├── .eslintrc  &lt;- &#123; &quot;root&quot;: true &#125;</span><br><span class="line">            └── main.js</span><br></pre></td></tr></table></figure>
<p>完整的配置层次结构，从最高优先级最低的优先级，如下:</p>
<ol>
<li>行内配置<ol>
<li><code>/*eslint-disable*/</code> 和 <code>/*eslint-enable*/</code></li>
<li><code>/*global*/</code></li>
<li><code>/*eslint*/</code></li>
<li><code>/*eslint-env*/</code></li>
</ol>
</li>
<li>命令行选项（或 CLIEngine 等价物）：<ol>
<li><code>--global</code></li>
<li><code>--rule</code></li>
<li><code>--env</code></li>
<li><code>-c</code>、<code>--config</code></li>
</ol>
</li>
<li>项目级配置：<ol>
<li>与要检测的文件在同一目录下的 <code>.eslintrc.*</code> 或 <code>package.json</code> 文件</li>
<li>继续在父级目录寻找 <code>.eslintrc</code> 或 <code>package.json</code>文件，直到根目录（包括根目录）或直到发现一个有<code>&quot;root&quot;: true</code>的配置。</li>
</ol>
</li>
<li>如果不是（1）到（3）中的任何一种情况，退回到 <code>~/.eslintrc</code> 中自定义的默认配置。</li>
</ol>
<h2 id="Extending-Configuration-Files"><a href="#Extending-Configuration-Files" class="headerlink" title="Extending Configuration Files"></a>Extending Configuration Files</h2><p>一个配置文件可以被基础配置中的已启用的规则继承。</p>
<p><code>extends</code> 属性值可以是：</p>
<ul>
<li>指定配置的字符串(配置文件的路径、可共享配置的名称、<code>eslint:recommended</code> 或 <code>eslint:all</code>)</li>
<li>字符串数组：每个配置继承它前面的配置</li>
</ul>
<p>ESLint递归地扩展配置，因此基本配置也可以具有 <code>extends</code> 属性。<code>extends</code> 属性中的相对路径和可共享配置名从配置文件中出现的位置解析。</p>
<p><code>rules</code> 属性可以做下面的任何事情以扩展（或覆盖）规则：</p>
<ul>
<li>启用额外的规则</li>
<li>改变继承的规则级别而不改变它的选项：<ul>
<li>基础配置：<code>&quot;eqeqeq&quot;: [&quot;error&quot;, &quot;allow-null&quot;]</code></li>
<li>派生的配置：<code>&quot;eqeqeq&quot;: &quot;warn&quot;</code></li>
<li>最后生成的配置：<code>&quot;eqeqeq&quot;: [&quot;warn&quot;, &quot;allow-null&quot;]</code></li>
</ul>
</li>
<li>覆盖基础配置中的规则的选项<ul>
<li>基础配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;, &quot;avoid-escape&quot;]</code></li>
<li>派生的配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code></li>
<li>最后生成的配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code></li>
</ul>
</li>
</ul>
<h3 id="Using-quot-eslint-recommended-quot"><a href="#Using-quot-eslint-recommended-quot" class="headerlink" title="Using &quot;eslint:recommended&quot;"></a>Using <code>&quot;eslint:recommended&quot;</code></h3><p>值为 <code>&quot;eslint:recommended&quot;</code> 的 <code>extends</code> 属性启用一系列核心规则，这些规则报告一些常见问题，在 <a href="http://eslint.cn/docs/rules/">规则页面</a> 中被标记为 。这个推荐的子集只能在 ESLint 主要版本进行更新。</p>
<p>如果你的配置集成了推荐的规则：在你升级到 ESLint 新的主版本之后，在你使用<a href="http://eslint.cn/docs/user-guide/command-line-interface#fix">命令行</a>的 <code>--fix</code> 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的推荐的规则将更改代码。</p>
<p><code>eslint --init</code> 命令可以创建一个配置，这样你就可以继承推荐的规则。</p>
<p>JavaScript 格式的一个配置文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &#x2F;&#x2F; enable additional rules</span><br><span class="line">        &quot;indent&quot;: [&quot;error&quot;, 4],</span><br><span class="line">        &quot;linebreak-style&quot;: [&quot;error&quot;, &quot;unix&quot;],</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],</span><br><span class="line">        &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;],</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; override default options for rules from base configurations</span><br><span class="line">        &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always&quot;],</span><br><span class="line">        &quot;no-cond-assign&quot;: [&quot;error&quot;, &quot;always&quot;],</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; disable rules from base configurations</span><br><span class="line">        &quot;no-console&quot;: &quot;off&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Using-a-shareable-configuration-package"><a href="#Using-a-shareable-configuration-package" class="headerlink" title="Using a shareable configuration package"></a>Using a shareable configuration package</h3><p><a href="http://eslint.cn/docs/developer-guide/shareable-configs">可共享的配置</a> 是一个 npm 包，它输出一个配置对象。要确保这个包安装在 ESLint 能请求到的目录下。</p>
<p><code>extends</code> 属性值可以省略包名的前缀 <code>eslint-config-</code>。</p>
<p><code>eslint --init</code> 命令可以创建一个配置，这样你就可以扩展一个流行的风格指南（比如，<code>eslint-config-standard</code>）。</p>
<p>YAML 格式的一个配置文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends: standard</span><br><span class="line">rules:</span><br><span class="line">  comma-dangle:</span><br><span class="line">    - error</span><br><span class="line">    - always</span><br><span class="line">  no-empty: warn</span><br></pre></td></tr></table></figure>
<h3 id="Using-the-configuration-from-a-plugin"><a href="#Using-the-configuration-from-a-plugin" class="headerlink" title="Using the configuration from a plugin"></a>Using the configuration from a plugin</h3><p><a href="http://eslint.cn/docs/developer-guide/working-with-plugins">插件</a> 是一个 npm 包，通常输出规则。一些插件也可以输出一个或多个命名的 <a href="http://eslint.cn/docs/developer-guide/working-with-plugins#configs-in-plugins">配置</a>。要确保这个包安装在 ESLint 能请求到的目录下。</p>
<p><code>plugins</code> <a href="http://eslint.cn/docs/user-guide/configuring#configuring-plugins">属性值</a> 可以省略包名的前缀 <code>eslint-plugin-</code>。</p>
<p><code>extends</code> 属性值可以由以下组成：</p>
<ul>
<li><code>plugin:</code></li>
<li>包名 (省略了前缀，比如，<code>react</code>)</li>
<li><code>/</code></li>
<li>配置名称 (比如 <code>recommended</code>)</li>
</ul>
<p>JSON 格式的一个配置文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;react&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:react&#x2F;recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">       &quot;no-set-state&quot;: &quot;off&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Using-a-configuration-file"><a href="#Using-a-configuration-file" class="headerlink" title="Using a configuration file"></a>Using a configuration file</h3><p><code>extends</code> 属性值可以是到基本<a href="http://eslint.cn/docs/user-guide/configuring#using-configuration-files">配置文件</a>的绝对路径，也可以是相对路径。ESLint 解析一个相对于使用它的配置文件的基本配置文件的相对路径。</p>
<p>ESLint 解析基本配置文件的相对路径相对你你使用的配置文件，<strong>除非</strong>那个文件在你的主目录或非 ESLint 安装目录的父级目录。在这些情况下，ESLint 解析基本配合文件的相对路径相对于被检测的 <strong>项目</strong>目录（尤其是当前工作目录）。</p>
<p>JSON 格式的一个配置文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;.&#x2F;node_modules&#x2F;coding-standard&#x2F;eslintDefaults.js&quot;,</span><br><span class="line">        &quot;.&#x2F;node_modules&#x2F;coding-standard&#x2F;.eslintrc-es6&quot;,</span><br><span class="line">        &quot;.&#x2F;node_modules&#x2F;coding-standard&#x2F;.eslintrc-jsx&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;eqeqeq&quot;: &quot;warn&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Using-quot-eslint-all-quot"><a href="#Using-quot-eslint-all-quot" class="headerlink" title="Using &quot;eslint:all&quot;"></a>Using <code>&quot;eslint:all&quot;</code></h3><p><code>extends</code> 属性值可以是 <code>&quot;eslint:all&quot;</code>，启用当前安装的 ESLint 中所有的核心规则。这些规则可以在 ESLint 的任何版本进行更改。</p>
<p><strong>重要：</strong>这些配置 <strong>不推荐在产品中使用</strong>，因为它随着 ESLint 版本进行更改。使用的话，请自己承担风险。</p>
<p>如果你配置 ESLint 升级时自动地启用新规则，当源码没有任何改变时，ESLint 可以报告新问题，因此任何 ESLint 的新的小版本好像有破坏性的更改。</p>
<p>当你决定在一个项目上使用的规则和选项，尤其是如果你很少覆盖选项或禁用规则，你可能启用所有核心规则作为一种快捷方式使用。规则的默认选项并不是 ESLint 推荐的（例如，<code>quotes</code> 规则的默认选项并不意味着双引号要比单引号好）。</p>
<p>如果你的配置扩展了所有的核心规则：在你升级到一个新的大或小的 ESLint 版本，在你使用<a href="http://eslint.cn/docs/user-guide/command-line-interface#fix">命令行</a>的 <code>--fix</code> 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的规则将更改代码。</p>
<p>JavaScript 格式的一个配置文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &quot;extends&quot;: &quot;eslint:all&quot;,</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &#x2F;&#x2F; override default options</span><br><span class="line">        &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always&quot;],</span><br><span class="line">        &quot;indent&quot;: [&quot;error&quot;, 2],</span><br><span class="line">        &quot;no-cond-assign&quot;: [&quot;error&quot;, &quot;always&quot;],</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; disable now, but enable in the future</span><br><span class="line">        &quot;one-var&quot;: &quot;off&quot;, &#x2F;&#x2F; [&quot;error&quot;, &quot;never&quot;]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; disable</span><br><span class="line">        &quot;init-declarations&quot;: &quot;off&quot;,</span><br><span class="line">        &quot;no-console&quot;: &quot;off&quot;,</span><br><span class="line">        &quot;no-inline-comments&quot;: &quot;off&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Configuration-Based-on-Glob-Patterns"><a href="#Configuration-Based-on-Glob-Patterns" class="headerlink" title="Configuration Based on Glob Patterns"></a>Configuration Based on Glob Patterns</h2><p><strong>v4.1.0+.</strong> 有时，你可能需要更精细的配置，比如，如果同一个目录下的文件需要有不同的配置。因此，你可以在配置中使用 <code>overrides</code> 键，它只适用于匹配特定的 glob 模式的文件，使用你在命令行上传递的格式 (e.g., <code>app/**/*.test.js</code>)。</p>
<h3 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h3><ul>
<li><p>Glob 模式覆盖只能在配置文件 (<code>.eslintrc.*</code> 或 <code>package.json</code>) 中进行配置。</p>
</li>
<li><p>模式应用于相对于配置文件的目录的文件路径。 比如，如果你的配置文件的路径为 <code>/Users/john/workspace/any-project/.eslintrc.js</code> 而你要检测的路径为 <code>/Users/john/workspace/any-project/lib/util.js</code>，那么你在 <code>.eslintrc.js</code> 中提供的模式是相对于 <code>lib/util.js</code> 来执行的.</p>
</li>
<li><p>在相同的配置文件中，Glob 模式覆盖比其他常规配置具有更高的优先级。 同一个配置中的多个覆盖将按顺序被应用。也就是说，配置文件中的最后一个覆盖会有最高优先级。</p>
</li>
<li><p>一个 glob 特定的配置几乎与 ESLint 的其他配置相同。覆盖块可以包含常规配置中的除了</p>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br></pre></td></tr></table></figure>
<p>  之外的其他任何有效配置选项，</p>
<ul>
<li>一个 glob 特定的配置可以有 <code>extends</code> 设置，但是会忽略扩展配置中的 <code>root</code> 属性。</li>
<li>只有当父配置和子配置的 glob 模式匹配时，才会应用嵌套的 <code>overrides</code> 设置。当扩展配置具有 <code>overrides</code> 设置时也是如此。</li>
</ul>
<ul>
<li><p>可以在单个覆盖块中提供多个 glob 模式。一个文件必须匹配至少一个配置中提供的模式。</p>
</li>
<li><p>覆盖块也可以指定从匹配中排除的模式。如果一个文件匹配了任何一个排除模式，该配置将不再被应用。</p>
</li>
</ul>
<h3 id="Relative-glob-patterns"><a href="#Relative-glob-patterns" class="headerlink" title="Relative glob patterns"></a>Relative glob patterns</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project-root</span><br><span class="line">├── app</span><br><span class="line">│   ├── lib</span><br><span class="line">│   │   ├── foo.js</span><br><span class="line">│   │   ├── fooSpec.js</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   ├── bar.js</span><br><span class="line">│   │   ├── barSpec.js</span><br><span class="line">│   ├── .eslintrc.json</span><br><span class="line">├── server</span><br><span class="line">│   ├── server.js</span><br><span class="line">│   ├── serverSpec.js</span><br><span class="line">├── .eslintrc.json</span><br></pre></td></tr></table></figure>
<p>在 <code>app/.eslintrc.json</code> 文件中的配置定义了 <code>**/*Spec.js</code> glob 模式。该模式相对于 <code>app/.eslintrc.json</code> 的基准目录。因此，该模式匹配 <code>app/lib/fooSpec.js</code> 和 <code>app/components/barSpec.js</code>，但 <strong>不匹配</strong> <code>server/serverSpec.js</code>。如果你在项目根目录的 <code>.eslintrc.json</code> 文件中定义相同的模式，它将匹配所有三个 <code>*Spec</code> 文件。</p>
<h3 id="Example-configuration"><a href="#Example-configuration" class="headerlink" title="Example configuration"></a>Example configuration</h3><p>在你的 <code>.eslintrc.json</code> 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: [&quot;bin&#x2F;*.js&quot;, &quot;lib&#x2F;*.js&quot;],</span><br><span class="line">      &quot;excludedFiles&quot;: &quot;*.test.js&quot;,</span><br><span class="line">      &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Comments-in-Configuration-Files"><a href="#Comments-in-Configuration-Files" class="headerlink" title="Comments in Configuration Files"></a>Comments in Configuration Files</h2><p>JSON 和 YAML 配置文件格式都支持注释 ( <code>package.json</code> 文件不应该包括注释)。你可以在其他类型的文件中使用 JavaScript 风格的注释或使用 YAML 风格的注释，ESLint 会忽略它们。这允许你的配置更加人性化。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &#x2F;&#x2F; Override our default settings just for this directory</span><br><span class="line">        &quot;eqeqeq&quot;: &quot;warn&quot;,</span><br><span class="line">        &quot;strict&quot;: &quot;off&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Specifying-File-extensions-to-Lint"><a href="#Specifying-File-extensions-to-Lint" class="headerlink" title="Specifying File extensions to Lint"></a>Specifying File extensions to Lint</h2><p>目前，告诉 ESLint 哪个文件扩展名要检测的唯一方法是使用 <a href="http://eslint.cn/docs/user-guide/command-line-interface#ext"><code>--ext</code></a> 命令行选项指定一个逗号分隔的扩展名列表。注意，该标记只在与目录一起使用时有效，如果使用文件名或 glob 模式，它将会被忽略。</p>
<h2 id="Ignoring-Files-and-Directories"><a href="#Ignoring-Files-and-Directories" class="headerlink" title="Ignoring Files and Directories"></a>Ignoring Files and Directories</h2><h3 id="eslintignore"><a href="#eslintignore" class="headerlink" title=".eslintignore"></a><code>.eslintignore</code></h3><p>你可以通过在项目根目录创建一个 <code>.eslintignore</code> 文件告诉 ESLint 去忽略特定的文件和目录。<code>.eslintignore</code> 文件是一个纯文本文件，其中的每一行都是一个 glob 模式表明哪些路径应该忽略检测。例如，以下将忽略所有的 JavaScript 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**&#x2F;*.js</span><br></pre></td></tr></table></figure>
<p>当 ESLint 运行时，在确定哪些文件要检测之前，它会在当前工作目录中查找一个 <code>.eslintignore</code> 文件。如果发现了这个文件，当遍历目录时，将会应用这些偏好设置。一次只有一个 <code>.eslintignore</code> 文件会被使用，所以，不是当前工作目录下的 <code>.eslintignore</code> 文件将不会被用到。</p>
<p>Globs 匹配使用 <a href="https://github.com/kaelzhang/node-ignore">node-ignore</a>，所以大量可用的特性有：</p>
<ul>
<li>以 <code>#</code> 开头的行被当作注释，不影响忽略模式。</li>
<li>路径是相对于 <code>.eslintignore</code> 的位置或当前工作目录。通过 <code>--ignore-pattern</code> <a href="http://eslint.cn/docs/user-guide/command-line-interface#--ignore-pattern">command</a> 传递的路径也是如此。</li>
<li>忽略模式同 <code>.gitignore</code> <a href="https://git-scm.com/docs/gitignore">规范</a></li>
<li>以 <code>!</code> 开头的行是否定模式，它将会重新包含一个之前被忽略的模式。</li>
<li>忽略模式依照 <code>.gitignore</code> <a href="https://git-scm.com/docs/gitignore">规范</a>.</li>
</ul>
<p>特别值得注意的是，就像 <code>.gitignore</code> 文件，所有用作 <code>.eslintignore</code> 和 <code>--ignore-pattern</code> 模式的路径必须使用前斜杠作为它们的路径分隔符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Valid</span><br><span class="line">&#x2F;root&#x2F;src&#x2F;*.js</span><br><span class="line"></span><br><span class="line"># Invalid</span><br><span class="line">\root\src\*.js</span><br></pre></td></tr></table></figure>
<p>请参参阅 <code>.gitignore</code> 规范查看有关有效语法的更多示例。</p>
<p>除了 <code>.eslintignore</code> 文件中的模式，ESLint总是忽略 <code>/node_modules/*</code> 和 <code>/bower_components/*</code> 中的文件。</p>
<p>例如：把下面 <code>.eslintignore</code> 文件放到当前工作目录里，将忽略项目根目录下的 <code>node_modules</code>，<code>bower_components</code> 以及 <code>build/</code> 目录下除了 <code>build/index.js</code> 的所有文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;node_modules&#x2F;* and &#x2F;bower_components&#x2F;* in the project root are ignored by default</span><br><span class="line"></span><br><span class="line"># Ignore built files except build&#x2F;index.js</span><br><span class="line">build&#x2F;*</span><br><span class="line">!build&#x2F;index.js</span><br></pre></td></tr></table></figure>
<p><strong>重要：</strong>注意代码库的 <code>node_modules</code> 目录，比如，一个 <code>packages</code> 目录，默认情况下不会被忽略，需要手动添加到 <code>.eslintignore</code>。</p>
<h3 id="Using-an-Alternate-File"><a href="#Using-an-Alternate-File" class="headerlink" title="Using an Alternate File"></a>Using an Alternate File</h3><p>如果相比于当前工作目录下 <code>.eslintignore</code> 文件，你更想使用一个不同的文件，你可以在命令行使用 <code>--ignore-path</code> 选项指定它。例如，你可以使用 <code>.jshintignore</code> 文件，因为它有相同的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint --ignore-path .jshintignore file.js</span><br></pre></td></tr></table></figure>
<p>你也可以使用你的 <code>.gitignore</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint --ignore-path .gitignore file.js</span><br></pre></td></tr></table></figure>
<p>任何文件只要满足标准忽略文件格式都可以用。记住，指定 <code>--ignore-path</code> 意味着任何现有的 <code>.eslintignore</code> 文件将不被使用。请注意，<code>.eslintignore</code> 中的匹配规则比 <code>.gitignore</code> 中的更严格。</p>
<h3 id="Using-eslintIgnore-in-package-json"><a href="#Using-eslintIgnore-in-package-json" class="headerlink" title="Using eslintIgnore in package.json"></a>Using eslintIgnore in package.json</h3><p>如果没有发现 <code>.eslintignore</code> 文件，也没有指定替代文件，ESLint 将在 package.json 文件中查找 <code>eslintIgnore</code> 键，来检查要忽略的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;mypackage&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;eslintConfig&quot;: &#123;</span><br><span class="line">      &quot;env&quot;: &#123;</span><br><span class="line">          &quot;browser&quot;: true,</span><br><span class="line">          &quot;node&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintIgnore&quot;: [&quot;hello.js&quot;, &quot;world.js&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ignored-File-Warnings"><a href="#Ignored-File-Warnings" class="headerlink" title="Ignored File Warnings"></a>Ignored File Warnings</h3><p>当你传递目录给 ESLint，文件和目录是默默被忽略的。如果你传递一个指定的文件给 ESLint，你会看到一个警告，表明该文件被跳过了。例如，假如你有一个像这样的 <code>.eslintignore</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.js</span><br></pre></td></tr></table></figure>
<p>然后你执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint foo.js</span><br></pre></td></tr></table></figure>
<p>你将会看到这个警告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.js</span><br><span class="line">  0:0  warning  File ignored because of your .eslintignore file. Use --no-ignore to override.</span><br><span class="line"></span><br><span class="line">✖ 1 problem (0 errors, 1 warning)</span><br></pre></td></tr></table></figure>
<p>这种消息出现是因为 ESLint 不确定你是否想检测文件。正如这个消息表明的那样，你可以使用 <code>--no-ignore</code> 覆盖忽略的规则。</p>
</blockquote>
<h4 id="规则-Rules"><a href="#规则-Rules" class="headerlink" title="规则 Rules"></a>规则 Rules</h4><p>为了让你对规则有个更好的理解，ESLint 对其进行了分门别类。</p>
<p>所有的规则默认都是禁用的。</p>
<p>在 <strong>配置文件</strong> 中，使用 <code>&quot;extends&quot;: &quot;eslint:recommend&quot;</code> 来启用推荐的规则，报告一些常见的问题，在下文中这些推荐的规则都带有一个 ✔ 标记。</p>
<h5 id="Possible-Errors"><a href="#Possible-Errors" class="headerlink" title="Possible Errors"></a>Possible Errors</h5><p>这些规则与 JavaScript 代码中可能的错误或逻辑错误有关：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标记</th>
<th></th>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/for-direction">for-direction</a></td>
<td>强制 “for” 循环中更新子句的计数器朝着正确的方向移动</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/getter-return">getter-return</a></td>
<td>强制 getter 函数中出现 <code>return</code> 语句</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-async-promise-executor">no-async-promise-executor</a></td>
<td>禁止使用异步函数作为 Promise executor</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-await-in-loop">no-await-in-loop</a></td>
<td>禁止在循环中出现 <code>await</code></td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-compare-neg-zero">no-compare-neg-zero</a></td>
<td>禁止与 -0 进行比较</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-cond-assign">no-cond-assign</a></td>
<td>禁止条件表达式中出现赋值操作符</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-console">no-console</a></td>
<td>禁用 <code>console</code></td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-constant-condition">no-constant-condition</a></td>
<td>禁止在条件中使用常量表达式</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-control-regex">no-control-regex</a></td>
<td>禁止在正则表达式中使用控制字符</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-debugger">no-debugger</a></td>
<td>禁用 <code>debugger</code></td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-dupe-args">no-dupe-args</a></td>
<td>禁止 <code>function</code> 定义中出现重名参数</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-dupe-keys">no-dupe-keys</a></td>
<td>禁止对象字面量中出现重复的 key</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-duplicate-case">no-duplicate-case</a></td>
<td>禁止出现重复的 case 标签</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-empty">no-empty</a></td>
<td>禁止出现空语句块</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-empty-character-class">no-empty-character-class</a></td>
<td>禁止在正则表达式中使用空字符集</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-ex-assign">no-ex-assign</a></td>
<td>禁止对 <code>catch</code> 子句的参数重新赋值</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-extra-boolean-cast">no-extra-boolean-cast</a></td>
<td>禁止不必要的布尔转换</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-extra-parens">no-extra-parens</a></td>
<td>禁止不必要的括号</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-extra-semi">no-extra-semi</a></td>
<td>禁止不必要的分号</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-func-assign">no-func-assign</a></td>
<td>禁止对 <code>function</code> 声明重新赋值</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-inner-declarations">no-inner-declarations</a></td>
<td>禁止在嵌套的块中出现变量声明或 <code>function</code> 声明</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-invalid-regexp">no-invalid-regexp</a></td>
<td>禁止 <code>RegExp</code> 构造函数中存在无效的正则表达式字符串</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-irregular-whitespace">no-irregular-whitespace</a></td>
<td>禁止不规则的空白</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-misleading-character-class">no-misleading-character-class</a></td>
<td>不允许在字符类语法中出现由多个代码点组成的字符</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-obj-calls">no-obj-calls</a></td>
<td>禁止把全局对象作为函数调用</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-prototype-builtins">no-prototype-builtins</a></td>
<td>禁止直接调用 <code>Object.prototypes</code> 的内置属性</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-regex-spaces">no-regex-spaces</a></td>
<td>禁止正则表达式字面量中出现多个空格</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-sparse-arrays">no-sparse-arrays</a></td>
<td>禁用稀疏数组</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-template-curly-in-string">no-template-curly-in-string</a></td>
<td>禁止在常规字符串中出现模板字面量占位符语法</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-unexpected-multiline">no-unexpected-multiline</a></td>
<td>禁止出现令人困惑的多行表达式</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-unreachable">no-unreachable</a></td>
<td>禁止在 <code>return</code>、<code>throw</code>、<code>continue</code> 和 <code>break</code> 语句之后出现不可达代码</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-unsafe-finally">no-unsafe-finally</a></td>
<td>禁止在 <code>finally</code> 语句块中出现控制流语句</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/no-unsafe-negation">no-unsafe-negation</a></td>
<td>禁止对关系运算符的左操作数使用否定操作符</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/require-atomic-updates">require-atomic-updates</a></td>
<td>禁止由于 <code>await</code> 或 <code>yield</code>的使用而可能导致出现竞态条件的赋值</td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/use-isnan">use-isnan</a></td>
<td>要求使用 <code>isNaN()</code> 检查 <code>NaN</code></td>
</tr>
<tr>
<td>✔</td>
<td></td>
<td><a href="http://eslint.cn/docs/rules/valid-typeof">valid-typeof</a></td>
<td>强制 <code>typeof</code> 表达式与有效的字符串进行比较</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
